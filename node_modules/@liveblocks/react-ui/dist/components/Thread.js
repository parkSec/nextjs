'use client';
'use strict';

var react = require('@liveblocks/react');
var TogglePrimitive = require('@radix-ui/react-toggle');
var React = require('react');
var ArrowDown = require('../icons/ArrowDown.js');
var Resolve = require('../icons/Resolve.js');
var Resolved = require('../icons/Resolved.js');
var overrides = require('../overrides.js');
var classNames = require('../utils/class-names.js');
var findLastIndex = require('../utils/find-last-index.js');
var Comment = require('./Comment.js');
var Composer = require('./Composer.js');
var Button = require('./internal/Button.js');
var Tooltip = require('./internal/Tooltip.js');
var TooltipPrimitive = require('@radix-ui/react-tooltip');

function _interopNamespaceDefault(e) {
  var n = Object.create(null);
  if (e) {
    Object.keys(e).forEach(function (k) {
      if (k !== 'default') {
        var d = Object.getOwnPropertyDescriptor(e, k);
        Object.defineProperty(n, k, d.get ? d : {
          enumerable: true,
          get: function () { return e[k]; }
        });
      }
    });
  }
  n.default = e;
  return Object.freeze(n);
}

var TogglePrimitive__namespace = /*#__PURE__*/_interopNamespaceDefault(TogglePrimitive);

const Thread = React.forwardRef(
  ({
    thread,
    indentCommentContent = true,
    showActions = "hover",
    showDeletedComments,
    showResolveAction = true,
    showReactions = true,
    showComposer = "collapsed",
    onResolvedChange,
    onCommentEdit,
    onCommentDelete,
    onThreadDelete,
    onAuthorClick,
    onMentionClick,
    overrides: overrides$1,
    className,
    ...props
  }, forwardedRef) => {
    const markThreadAsResolved = react.useMarkThreadAsResolved();
    const markThreadAsUnresolved = react.useMarkThreadAsUnresolved();
    const $ = overrides.useOverrides(overrides$1);
    const firstCommentIndex = React.useMemo(() => {
      return showDeletedComments ? 0 : thread.comments.findIndex((comment) => comment.body);
    }, [showDeletedComments, thread.comments]);
    const lastCommentIndex = React.useMemo(() => {
      return showDeletedComments ? thread.comments.length - 1 : findLastIndex.findLastIndex(thread.comments, (comment) => comment.body);
    }, [showDeletedComments, thread.comments]);
    const { status: subscriptionStatus, unreadSince } = react.useThreadSubscription(
      thread.id
    );
    const unreadIndex = React.useMemo(() => {
      if (subscriptionStatus !== "subscribed") {
        return;
      }
      if (unreadSince === null) {
        return firstCommentIndex;
      }
      const unreadIndex2 = thread.comments.findIndex(
        (comment) => (showDeletedComments ? true : comment.body) && comment.createdAt > unreadSince
      );
      return unreadIndex2 >= 0 && unreadIndex2 < thread.comments.length ? unreadIndex2 : void 0;
    }, [
      firstCommentIndex,
      showDeletedComments,
      subscriptionStatus,
      thread.comments,
      unreadSince
    ]);
    const [newIndex, setNewIndex] = React.useState();
    const newIndicatorIndex = newIndex === void 0 ? unreadIndex : newIndex;
    React.useEffect(() => {
      if (unreadIndex) {
        setNewIndex(
          (persistedUnreadIndex) => Math.min(persistedUnreadIndex ?? Infinity, unreadIndex)
        );
      }
    }, [unreadIndex]);
    const stopPropagation = React.useCallback((event) => {
      event.stopPropagation();
    }, []);
    const handleResolvedChange = React.useCallback(
      (resolved) => {
        onResolvedChange?.(resolved);
        if (resolved) {
          markThreadAsResolved(thread.id);
        } else {
          markThreadAsUnresolved(thread.id);
        }
      },
      [
        markThreadAsResolved,
        markThreadAsUnresolved,
        onResolvedChange,
        thread.id
      ]
    );
    const handleCommentDelete = React.useCallback(
      (comment) => {
        onCommentDelete?.(comment);
        const filteredComments = thread.comments.filter(
          (comment2) => comment2.body
        );
        if (filteredComments.length <= 1) {
          onThreadDelete?.(thread);
        }
      },
      [onCommentDelete, onThreadDelete, thread]
    );
    return /* @__PURE__ */ React.createElement(TooltipPrimitive.TooltipProvider, null, /* @__PURE__ */ React.createElement("div", {
      className: classNames.classNames(
        "lb-root lb-thread",
        showActions === "hover" && "lb-thread:show-actions-hover",
        className
      ),
      "data-resolved": thread.resolved ? "" : void 0,
      "data-unread": unreadIndex !== void 0 ? "" : void 0,
      dir: $.dir,
      ...props,
      ref: forwardedRef
    }, /* @__PURE__ */ React.createElement("div", {
      className: "lb-thread-comments"
    }, thread.comments.map((comment, index) => {
      const isFirstComment = index === firstCommentIndex;
      const isUnread = unreadIndex !== void 0 && index >= unreadIndex;
      const children = /* @__PURE__ */ React.createElement(Comment.Comment, {
        key: comment.id,
        className: "lb-thread-comment",
        "data-unread": isUnread ? "" : void 0,
        comment,
        indentContent: indentCommentContent,
        showDeleted: showDeletedComments,
        showActions,
        showReactions,
        onCommentEdit,
        onCommentDelete: handleCommentDelete,
        onAuthorClick,
        onMentionClick,
        autoMarkReadThreadId: index === lastCommentIndex && isUnread ? thread.id : void 0,
        additionalActionsClassName: isFirstComment ? "lb-thread-actions" : void 0,
        additionalActions: isFirstComment && showResolveAction ? /* @__PURE__ */ React.createElement(Tooltip.Tooltip, {
          content: thread.resolved ? $.THREAD_UNRESOLVE : $.THREAD_RESOLVE
        }, /* @__PURE__ */ React.createElement(TogglePrimitive__namespace.Root, {
          pressed: thread.resolved,
          onPressedChange: handleResolvedChange,
          asChild: true
        }, /* @__PURE__ */ React.createElement(Button.Button, {
          className: "lb-comment-action",
          onClick: stopPropagation,
          "aria-label": thread.resolved ? $.THREAD_UNRESOLVE : $.THREAD_RESOLVE
        }, thread.resolved ? /* @__PURE__ */ React.createElement(Resolved.ResolvedIcon, {
          className: "lb-button-icon"
        }) : /* @__PURE__ */ React.createElement(Resolve.ResolveIcon, {
          className: "lb-button-icon"
        })))) : null
      });
      return index === newIndicatorIndex && newIndicatorIndex !== firstCommentIndex && newIndicatorIndex <= lastCommentIndex ? /* @__PURE__ */ React.createElement(React.Fragment, {
        key: comment.id
      }, /* @__PURE__ */ React.createElement("div", {
        className: "lb-thread-new-indicator",
        "aria-label": $.THREAD_NEW_INDICATOR_DESCRIPTION
      }, /* @__PURE__ */ React.createElement("span", {
        className: "lb-thread-new-indicator-label"
      }, /* @__PURE__ */ React.createElement(ArrowDown.ArrowDownIcon, {
        className: "lb-thread-new-indicator-label-icon"
      }), $.THREAD_NEW_INDICATOR)), children) : children;
    })), showComposer && /* @__PURE__ */ React.createElement(Composer.Composer, {
      className: "lb-thread-composer",
      threadId: thread.id,
      defaultCollapsed: showComposer === "collapsed" ? true : void 0,
      overrides: {
        COMPOSER_PLACEHOLDER: $.THREAD_COMPOSER_PLACEHOLDER,
        COMPOSER_SEND: $.THREAD_COMPOSER_SEND
      }
    })));
  }
);

exports.Thread = Thread;
//# sourceMappingURL=Thread.js.map
