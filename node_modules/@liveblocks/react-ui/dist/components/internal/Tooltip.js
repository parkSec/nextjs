'use client';
'use strict';

var TooltipPrimitive = require('@radix-ui/react-tooltip');
var React = require('react');
var config = require('../../config.js');
var constants = require('../../constants.js');
var classNames = require('../../utils/class-names.js');
var isApple = require('../../utils/is-apple.js');

function _interopNamespaceDefault(e) {
  var n = Object.create(null);
  if (e) {
    Object.keys(e).forEach(function (k) {
      if (k !== 'default') {
        var d = Object.getOwnPropertyDescriptor(e, k);
        Object.defineProperty(n, k, d.get ? d : {
          enumerable: true,
          get: function () { return e[k]; }
        });
      }
    });
  }
  n.default = e;
  return Object.freeze(n);
}

var TooltipPrimitive__namespace = /*#__PURE__*/_interopNamespaceDefault(TooltipPrimitive);

const KEYS = {
  alt: () => ({ title: "Alt", key: "\u2325" }),
  mod: () => isApple.isApple() ? { title: "Command", key: "\u2318" } : { title: "Ctrl", key: "\u2303" },
  shift: () => {
    return { title: "Shift", key: "\u21E7" };
  },
  enter: () => {
    return { title: "Enter", key: "\u23CE" };
  }
};
const Tooltip = React.forwardRef(
  ({ children, content, multiline, className, ...props }, forwardedRef) => {
    const { portalContainer } = config.useLiveblocksUIConfig();
    return /* @__PURE__ */ React.createElement(TooltipPrimitive__namespace.Root, {
      disableHoverableContent: true
    }, /* @__PURE__ */ React.createElement(TooltipPrimitive__namespace.Trigger, {
      asChild: true,
      ref: forwardedRef
    }, children), /* @__PURE__ */ React.createElement(TooltipPrimitive__namespace.Portal, {
      container: portalContainer
    }, /* @__PURE__ */ React.createElement(TooltipPrimitive__namespace.Content, {
      className: classNames.classNames(
        "lb-root lb-portal lb-tooltip",
        multiline && "lb-tooltip:multiline",
        className
      ),
      side: "top",
      align: "center",
      sideOffset: constants.FLOATING_ELEMENT_SIDE_OFFSET,
      collisionPadding: constants.FLOATING_ELEMENT_COLLISION_PADDING,
      ...props
    }, content)));
  }
);
const ShortcutTooltip = React.forwardRef(({ children, content, shortcut, ...props }, forwardedRef) => {
  return /* @__PURE__ */ React.createElement(Tooltip, {
    content: /* @__PURE__ */ React.createElement(React.Fragment, null, content, shortcut && /* @__PURE__ */ React.createElement("kbd", {
      className: "lb-tooltip-shortcut"
    }, shortcut)),
    ...props,
    ref: forwardedRef
  }, children);
});
function ShortcutTooltipKey({
  name,
  ...props
}) {
  const { title, key } = React.useMemo(() => KEYS[name]?.(), [name]);
  return /* @__PURE__ */ React.createElement("abbr", {
    title,
    ...props
  }, key);
}

Object.defineProperty(exports, 'TooltipProvider', {
  enumerable: true,
  get: function () { return TooltipPrimitive.TooltipProvider; }
});
exports.ShortcutTooltip = ShortcutTooltip;
exports.ShortcutTooltipKey = ShortcutTooltipKey;
exports.Tooltip = Tooltip;
//# sourceMappingURL=Tooltip.js.map
