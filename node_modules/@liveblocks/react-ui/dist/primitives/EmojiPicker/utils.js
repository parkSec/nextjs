'use strict';

var constants = require('../../constants.js');
var capitalize = require('../../utils/capitalize.js');
var chunk = require('../../utils/chunk.js');

const EMOJIBASE_VERSION = "15.3.0";
const EMOJIBASE_CDN_URL = `https://cdn.jsdelivr.net/npm/emojibase-data@${EMOJIBASE_VERSION}`;
const EMOJIBASE_EMOJIS_URL = (locale) => `${EMOJIBASE_CDN_URL}/${locale}/data.json`;
const EMOJIBASE_MESSAGES_URL = (locale) => `${EMOJIBASE_CDN_URL}/${locale}/messages.json`;
const EMOJIBASE_LOCALES = [
  "bn",
  "da",
  "de",
  "en",
  "en-gb",
  "es",
  "es-mx",
  "et",
  "fi",
  "fr",
  "hi",
  "hu",
  "it",
  "ja",
  "ko",
  "lt",
  "ms",
  "nb",
  "nl",
  "pl",
  "pt",
  "ru",
  "sv",
  "th",
  "uk",
  "zh",
  "zh-hant"
];
const EMOJIBASE_DEFAULT_LOCALE = "en";
const CACHE_EMOJI_DATA_KEY = (locale) => `lb-emoji-data-${locale}`;
const CACHE_EMOJI_METADATA_KEY = (locale) => `lb-emoji-metadata-${locale}`;
const CACHE_EMOJI_SESSION_METADATA_KEY = "lb-emoji-metadata";
const EMOJI_DETECTION_CANVAS_WIDTH = 20;
const EMOJI_DETECTION_CANVAS_HEIGHT = 25;
const EMOJI_DETECTION_COUNTRY_FLAG = "\u{1F1EB}\u{1F1F7}";
function generateRangeIndices(start, end) {
  const range = [];
  for (let i = start; i <= end; i++) {
    range.push(i);
  }
  return range;
}
function getStorageItem(storage, key) {
  const item = storage.getItem(key);
  return item ? JSON.parse(item) : null;
}
function setStorageItem(storage, key, value) {
  storage.setItem(key, JSON.stringify(value));
}
async function fetchEtag(url) {
  try {
    const response = await fetch(url, { method: "HEAD" });
    return response.headers.get("etag");
  } catch (error) {
    return null;
  }
}
function getEmojibaseSupportedLocale(locale) {
  return EMOJIBASE_LOCALES.includes(locale) ? locale : EMOJIBASE_DEFAULT_LOCALE;
}
async function fetchEmojibaseData(locale) {
  const [{ emojis, emojisEtag }, { messages, messagesEtag }] = await Promise.all([
    fetch(EMOJIBASE_EMOJIS_URL(locale)).then(async (response) => {
      return {
        emojis: await response.json(),
        emojisEtag: response.headers.get("etag")
      };
    }),
    fetch(EMOJIBASE_MESSAGES_URL(locale)).then(async (response) => {
      return {
        messages: await response.json(),
        messagesEtag: response.headers.get("etag")
      };
    })
  ]);
  return {
    emojis,
    messages,
    emojisEtag,
    messagesEtag
  };
}
async function fetchEmojibaseEtags(locale) {
  const [emojisEtag, messagesEtag] = await Promise.all([
    fetchEtag(EMOJIBASE_EMOJIS_URL(locale)),
    fetchEtag(EMOJIBASE_MESSAGES_URL(locale))
  ]);
  return {
    emojisEtag,
    messagesEtag
  };
}
async function fetchEmojiData(locale) {
  const { emojis, emojisEtag, messages, messagesEtag } = await fetchEmojibaseData(locale);
  const countryFlagsSubgroup = messages.subgroups.find(
    (subgroup) => subgroup.key === "subdivision-flag"
  );
  const filteredGroups = messages.groups.filter(
    (group) => group.key !== "component"
  );
  const filteredEmojis = emojis.filter((emoji) => {
    return "group" in emoji;
  });
  const categories = filteredGroups.map((group) => ({
    key: group.order,
    name: capitalize.capitalize(group.message)
  }));
  const skinTones = messages.skinTones.map((skinTone) => ({
    key: skinTone.key,
    name: capitalize.capitalize(skinTone.message)
  }));
  const compactEmojis = filteredEmojis.map((emoji) => {
    const compactEmoji = {
      emoji: emoji.emoji,
      category: emoji.group,
      version: emoji.version,
      name: capitalize.capitalize(emoji.label),
      tags: emoji.tags
    };
    if (countryFlagsSubgroup && emoji.subgroup === countryFlagsSubgroup.order) {
      compactEmoji.countryFlag = true;
    }
    return compactEmoji;
  });
  const emojiData = {
    emojis: compactEmojis,
    categories,
    skinTones
  };
  setStorageItem(
    localStorage,
    CACHE_EMOJI_DATA_KEY(locale),
    emojiData
  );
  setStorageItem(
    localStorage,
    CACHE_EMOJI_METADATA_KEY(locale),
    {
      emojisEtag,
      messagesEtag
    }
  );
  return emojiData;
}
function detectEmojiSupport(canvasContext, emoji) {
  canvasContext.clearRect(
    0,
    0,
    EMOJI_DETECTION_CANVAS_WIDTH * 2,
    EMOJI_DETECTION_CANVAS_HEIGHT
  );
  canvasContext.fillStyle = "#f00";
  canvasContext.fillText(emoji, 0, 22);
  canvasContext.fillStyle = "#00f";
  canvasContext.fillText(emoji, EMOJI_DETECTION_CANVAS_WIDTH, 22);
  const pixels = canvasContext.getImageData(
    0,
    0,
    EMOJI_DETECTION_CANVAS_WIDTH,
    EMOJI_DETECTION_CANVAS_HEIGHT
  ).data;
  const pixelCount = pixels.length;
  let i = 0;
  for (; i < pixelCount && !pixels[i + 3]; i += 4)
    ;
  if (i >= pixelCount) {
    return false;
  }
  const x = EMOJI_DETECTION_CANVAS_WIDTH + i / 4 % EMOJI_DETECTION_CANVAS_WIDTH;
  const y = Math.floor(i / 4 / EMOJI_DETECTION_CANVAS_WIDTH);
  const pixel = canvasContext.getImageData(x, y, 1, 1).data;
  if (pixels[i] !== pixel[0] || pixels[i + 2] !== pixel[2]) {
    return false;
  }
  if (canvasContext.measureText(emoji).width >= EMOJI_DETECTION_CANVAS_WIDTH) {
    return false;
  }
  return true;
}
function getEmojiFontFamily() {
  try {
    const element = document.createElement("span");
    element.style.display = "none";
    element.dataset.emoji = "";
    document.body.appendChild(element);
    const computedFontFamily = window.getComputedStyle(element).fontFamily;
    document.body.removeChild(element);
    return computedFontFamily;
  } catch {
    return constants.EMOJI_FONT_FAMILY;
  }
}
function getEmojiSessionMetadata(emojis) {
  const versions = /* @__PURE__ */ new Map();
  for (const emoji of emojis) {
    if (!versions.has(emoji.version)) {
      versions.set(emoji.version, emoji.emoji);
    }
  }
  const descendingVersions = [...versions.keys()].sort((a, b) => b - a);
  const canvasContext = document.createElement("canvas").getContext("2d", { willReadFrequently: true });
  if (!canvasContext) {
    return { emojiVersion: descendingVersions[0], countryFlags: true };
  }
  canvasContext.font = `${Math.floor(
    EMOJI_DETECTION_CANVAS_HEIGHT / 2
  )}px ${getEmojiFontFamily()}`;
  canvasContext.textBaseline = "top";
  canvasContext.canvas.width = EMOJI_DETECTION_CANVAS_WIDTH * 2;
  canvasContext.canvas.height = EMOJI_DETECTION_CANVAS_HEIGHT;
  const supportsCountryFlags = detectEmojiSupport(
    canvasContext,
    EMOJI_DETECTION_COUNTRY_FLAG
  );
  for (const version of descendingVersions) {
    const emoji = versions.get(version);
    const isSupported = detectEmojiSupport(canvasContext, emoji);
    if (isSupported) {
      return {
        emojiVersion: version,
        countryFlags: supportsCountryFlags
      };
    }
  }
  return {
    emojiVersion: descendingVersions[0],
    countryFlags: supportsCountryFlags
  };
}
async function getEmojiData(locale) {
  const emojibaseLocale = getEmojibaseSupportedLocale(locale);
  const sessionMetadata = getStorageItem(
    sessionStorage,
    CACHE_EMOJI_SESSION_METADATA_KEY
  );
  const cachedData = getStorageItem(
    localStorage,
    CACHE_EMOJI_DATA_KEY(emojibaseLocale)
  );
  let data;
  if (cachedData) {
    if (sessionMetadata) {
      data = cachedData;
    } else {
      const { emojisEtag, messagesEtag } = await fetchEmojibaseEtags(emojibaseLocale);
      const cachedMetadata = getStorageItem(
        localStorage,
        CACHE_EMOJI_METADATA_KEY(emojibaseLocale)
      );
      if (cachedMetadata && emojisEtag === cachedMetadata.emojisEtag && messagesEtag === cachedMetadata.messagesEtag) {
        data = cachedData;
      } else {
        data = await fetchEmojiData(emojibaseLocale);
      }
    }
  } else {
    data = await fetchEmojiData(emojibaseLocale);
  }
  const newSessionMetadata = sessionMetadata ?? getEmojiSessionMetadata(data.emojis);
  setStorageItem(
    sessionStorage,
    CACHE_EMOJI_SESSION_METADATA_KEY,
    newSessionMetadata
  );
  const filteredEmojis = data.emojis.filter((emoji) => {
    const isSupportedVersion = emoji.version <= newSessionMetadata.emojiVersion;
    return emoji.countryFlag ? isSupportedVersion && newSessionMetadata.countryFlags : isSupportedVersion;
  });
  return {
    emojis: filteredEmojis,
    categories: data.categories,
    skinTones: data.skinTones
  };
}
function filterEmojis(emojis, search) {
  if (!search) {
    return emojis;
  }
  const searchText = search.toLowerCase().trim();
  return emojis.filter(
    (emoji) => emoji.name.toLowerCase().includes(searchText) || emoji.tags?.some((tag) => tag.toLowerCase().includes(searchText))
  );
}
function generateEmojiPickerData(emojis, categories, columns) {
  let currentIndex = 0;
  const rows = [];
  const indexedEmojis = emojis.map((emoji, index) => ({ ...emoji, index }));
  const categoriesRowCounts = [];
  const categoriesRowIndices = [];
  const categoriesNames = [];
  const categorizedEmojis = categories.map((category) => ({
    ...category,
    emojis: indexedEmojis.filter((emoji) => emoji.category === category.key)
  })).filter((category) => category.emojis.length > 0);
  for (const category of categorizedEmojis) {
    const categoryRows = chunk.chunk(category.emojis, columns);
    const nextIndex = currentIndex + categoryRows.length;
    rows.push(...categoryRows);
    categoriesNames.push(category.name);
    categoriesRowCounts.push(categoryRows.length);
    categoriesRowIndices.push(
      generateRangeIndices(currentIndex, nextIndex - 1)
    );
    currentIndex = nextIndex;
  }
  return {
    count: emojis.length,
    rows,
    categories: categoriesNames,
    categoriesRowCounts,
    categoriesRowIndices
  };
}

exports.filterEmojis = filterEmojis;
exports.generateEmojiPickerData = generateEmojiPickerData;
exports.getEmojiData = getEmojiData;
//# sourceMappingURL=utils.js.map
