'use client';
import { Slot } from '@radix-ui/react-slot';
import React__default, { forwardRef, useCallback, useEffect, useRef, useMemo, useState } from 'react';
import { GroupedVirtuoso } from 'react-virtuoso';
import { isKey } from '../../utils/is-key.mjs';
import { requestIdleCallback, cancelIdleCallback } from '../../utils/request-idle-callback.mjs';
import { useLayoutEffect } from '../../utils/use-layout-effect.mjs';
import { useTransition } from '../../utils/use-transition.mjs';
import { visuallyHidden } from '../../utils/visually-hidden.mjs';
import { Emoji } from '../internal/Emoji.mjs';
import { useEmojiPicker, EmojiPickerContext } from './contexts.mjs';
import { filterEmojis, generateEmojiPickerData, getEmojiData } from './utils.mjs';

const DEFAULT_COLUMNS = 10;
const DEFAULT_LOCALE = "en";
const LOADING_MINIMUM_TIMEOUT = 100;
const EMOJIPICKER_ROOT_NAME = "EmojiPickerRoot";
const EMOJIPICKER_CONTENT_NAME = "EmojiPickerContent";
const EMOJIPICKER_SEARCH_NAME = "EmojiPickerSearch";
function EmojiPickerRoot({
  columns = DEFAULT_COLUMNS,
  locale = DEFAULT_LOCALE,
  onEmojiSelect,
  children
}) {
  const emojiData = useRef();
  const search = useRef("");
  const [, startEmojisTransition] = useTransition();
  const [data, setData] = useState();
  const [error, setError] = useState();
  const [selectedColumnIndex, setSelectedColumnIndex] = useState(0);
  const [selectedRowIndex, setSelectedRowIndex] = useState(0);
  const [interaction, setInteraction] = useState("none");
  const selectCurrentEmoji = useCallback(() => {
    if (onEmojiSelect) {
      const emoji = data?.rows[selectedRowIndex]?.[selectedColumnIndex];
      if (emoji) {
        onEmojiSelect(emoji.emoji);
      }
    }
  }, [data?.rows, onEmojiSelect, selectedColumnIndex, selectedRowIndex]);
  const resetSelection = useCallback(() => {
    setSelectedColumnIndex(0);
    setSelectedRowIndex(0);
  }, []);
  const setPointerSelection = useCallback(
    (columnIndex, rowIndex) => {
      setInteraction("pointer");
      setSelectedColumnIndex(columnIndex);
      setSelectedRowIndex(rowIndex);
    },
    []
  );
  const moveSelection = useCallback(
    (direction, event) => {
      if (!data) {
        return;
      }
      event.preventDefault();
      if (interaction === "none") {
        setInteraction("keyboard");
        return;
      }
      setInteraction("keyboard");
      switch (direction) {
        case "left": {
          if (selectedColumnIndex === 0) {
            const previousRowIndex = selectedRowIndex - 1;
            const previousRow = data.rows[previousRowIndex];
            if (previousRow) {
              setSelectedRowIndex(previousRowIndex);
              setSelectedColumnIndex(previousRow.length - 1);
            }
          } else {
            setSelectedColumnIndex(selectedColumnIndex - 1);
          }
          break;
        }
        case "right": {
          const currentRow = data.rows[selectedRowIndex];
          if (selectedColumnIndex === currentRow.length - 1) {
            const nextRowIndex = selectedRowIndex + 1;
            const nextRow = data.rows[nextRowIndex];
            if (nextRow) {
              setSelectedRowIndex(nextRowIndex);
              setSelectedColumnIndex(0);
            }
          } else {
            setSelectedColumnIndex(selectedColumnIndex + 1);
          }
          break;
        }
        case "up": {
          const previousRow = data.rows[selectedRowIndex - 1];
          if (previousRow) {
            setSelectedRowIndex(selectedRowIndex - 1);
            if (!previousRow[selectedColumnIndex]) {
              setSelectedColumnIndex(previousRow.length - 1);
            }
          }
          break;
        }
        case "down": {
          const nextRow = data.rows[selectedRowIndex + 1];
          if (nextRow) {
            setSelectedRowIndex(selectedRowIndex + 1);
            if (!nextRow[selectedColumnIndex]) {
              setSelectedColumnIndex(nextRow.length - 1);
            }
          }
          break;
        }
      }
    },
    [data, interaction, selectedColumnIndex, selectedRowIndex]
  );
  const updateEmojis = useCallback(() => {
    if (!emojiData.current) {
      return;
    }
    startEmojisTransition(() => {
      setData(() => {
        if (!emojiData.current) {
          return;
        }
        const filteredEmojis = filterEmojis(
          emojiData.current.emojis,
          search.current
        );
        return generateEmojiPickerData(
          filteredEmojis,
          emojiData.current.categories,
          columns
        );
      });
      resetSelection();
    });
  }, [columns, resetSelection]);
  const handleSearch = useCallback(
    (value) => {
      search.current = value;
      updateEmojis();
    },
    [updateEmojis]
  );
  const initializeEmojiData = useCallback(
    async (locale2) => {
      try {
        emojiData.current = await getEmojiData(locale2);
        updateEmojis();
      } catch (error2) {
        setError(error2);
      }
    },
    [updateEmojis]
  );
  useEffect(() => {
    let idleCallbackId;
    const timeoutId = setTimeout(() => {
      idleCallbackId = requestIdleCallback(() => {
        initializeEmojiData(locale);
      });
    }, LOADING_MINIMUM_TIMEOUT);
    return () => {
      clearTimeout(timeoutId);
      cancelIdleCallback(idleCallbackId);
    };
  }, [locale]);
  useEffect(() => {
    if (interaction === "none") {
      resetSelection();
    }
  }, [interaction]);
  return /* @__PURE__ */ React__default.createElement(EmojiPickerContext.Provider, {
    value: {
      data,
      error,
      isLoading: !data && !error,
      columns,
      onSearch: handleSearch,
      onEmojiSelect,
      selectCurrentEmoji,
      selectedRowIndex,
      selectedColumnIndex,
      moveSelection,
      setPointerSelection,
      interaction,
      setInteraction
    }
  }, children);
}
const EmojiPickerSearch = forwardRef(
  ({ asChild, value, defaultValue, onChange, ...props }, forwardedRef) => {
    const Component = asChild ? Slot : "input";
    const {
      onSearch,
      selectCurrentEmoji,
      moveSelection,
      interaction,
      setInteraction
    } = useEmojiPicker();
    const handleChange = useCallback(
      (event) => {
        onChange?.(event);
        if (event.isDefaultPrevented()) {
          return;
        }
        const value2 = event.target.value;
        setInteraction(value2 ? "keyboard" : "none");
        onSearch(value2);
      },
      [onChange, onSearch, setInteraction]
    );
    const handleKeyDown = useCallback(
      (event) => {
        if (event.isDefaultPrevented()) {
          return;
        }
        if (isKey(event, "ArrowLeft")) {
          moveSelection("left", event);
        } else if (isKey(event, "ArrowRight")) {
          moveSelection("right", event);
        } else if (isKey(event, "ArrowUp")) {
          moveSelection("up", event);
        } else if (isKey(event, "ArrowDown")) {
          moveSelection("down", event);
        } else if (isKey(event, "Enter")) {
          if (interaction !== "none") {
            event.preventDefault();
            selectCurrentEmoji();
          }
        }
      },
      [interaction, moveSelection, selectCurrentEmoji]
    );
    useEffect(() => {
      onSearch(
        value ? String(value) : defaultValue ? String(defaultValue) : ""
      );
    }, []);
    return /* @__PURE__ */ React__default.createElement(Component, {
      type: "search",
      value,
      defaultValue,
      onChange: handleChange,
      onKeyDown: handleKeyDown,
      ...props,
      ref: forwardedRef
    });
  }
);
const defaultContentComponents = {
  CategoryHeader: ({ category, ...props }) => /* @__PURE__ */ React__default.createElement("div", {
    ...props
  }, category),
  Row: ({ children, attributes, ...props }) => /* @__PURE__ */ React__default.createElement("div", {
    ...props
  }, children),
  Emoji: ({ emoji, ...props }) => /* @__PURE__ */ React__default.createElement("button", {
    ...props
  }, /* @__PURE__ */ React__default.createElement(Emoji, {
    emoji
  })),
  Loading: (props) => /* @__PURE__ */ React__default.createElement("div", {
    ...props
  }),
  Empty: (props) => /* @__PURE__ */ React__default.createElement("div", {
    ...props
  }),
  Grid: (props) => /* @__PURE__ */ React__default.createElement("div", {
    ...props
  }),
  Error: ({ error, ...props }) => /* @__PURE__ */ React__default.createElement("div", {
    ...props
  })
};
const placeholderRowAttributes = {
  rowIndex: -1,
  categoryRowIndex: -1,
  categoryRowsCount: 0
};
const VirtuosoScroller = forwardRef(
  ({ children, ...props }, forwardedRef) => {
    return /* @__PURE__ */ React__default.createElement("div", {
      ...props,
      tabIndex: -1,
      "data-testid": void 0,
      ref: forwardedRef
    }, children);
  }
);
const VirtuosoTopList = forwardRef(
  ({ children, ...props }, forwardedRef) => {
    return /* @__PURE__ */ React__default.createElement("div", {
      ...props,
      "data-testid": void 0,
      ref: forwardedRef
    }, children);
  }
);
const EmojiPickerContent = forwardRef(
  ({ components, asChild, ...props }, forwardedRef) => {
    const Component = asChild ? Slot : "div";
    const virtuosoRef = useRef(null);
    const placeholderContainerRef = useRef(null);
    const rowScrollMarginTopRef = useRef(0);
    const rowScrollMarginBottomRef = useRef(0);
    const categoryHeaderHeightRef = useRef(0);
    const {
      data,
      error,
      isLoading,
      columns,
      onEmojiSelect,
      selectedColumnIndex,
      selectedRowIndex,
      setPointerSelection,
      interaction,
      setInteraction
    } = useEmojiPicker();
    const selectedEmoji = useMemo(
      () => data?.rows[selectedRowIndex]?.[selectedColumnIndex],
      [data?.rows, selectedColumnIndex, selectedRowIndex]
    );
    const { Loading, Empty, Error, CategoryHeader, Grid, Row, Emoji } = useMemo(
      () => ({ ...defaultContentComponents, ...components }),
      [components]
    );
    const VirtuosoList = useMemo(
      () => forwardRef(
        ({ children, ...props2 }, forwardedRef2) => {
          return /* @__PURE__ */ React__default.createElement("div", {
            role: "grid",
            "aria-colcount": columns,
            ...props2,
            "data-testid": void 0,
            ref: forwardedRef2
          }, children);
        }
      ),
      [columns]
    );
    const placeholderColumns = useMemo(
      () => Array(columns).fill("\u{1F32B}\uFE0F"),
      [columns]
    );
    const preventDefault = useCallback((event) => {
      event.preventDefault();
    }, []);
    const handleEmojiPointerLeave = useCallback(() => {
      if (interaction === "pointer") {
        setInteraction("none");
      }
    }, [interaction, setInteraction]);
    useLayoutEffect(() => {
      if (!placeholderContainerRef.current) {
        return;
      }
      const row = placeholderContainerRef.current.childNodes[0];
      const categoryHeader = placeholderContainerRef.current.childNodes[1];
      if (row instanceof HTMLElement) {
        const style = window.getComputedStyle(row);
        rowScrollMarginTopRef.current = parseFloat(style.scrollMarginTop);
        rowScrollMarginBottomRef.current = parseFloat(style.scrollMarginBottom);
      }
      if (categoryHeader instanceof HTMLElement) {
        categoryHeaderHeightRef.current = categoryHeader.offsetHeight;
      }
    }, []);
    const calculateViewLocation = useCallback(
      ({
        itemTop,
        itemBottom,
        viewportTop,
        viewportBottom,
        locationParams: { behavior, align, ...params }
      }) => {
        if (itemTop - (categoryHeaderHeightRef.current + rowScrollMarginTopRef.current) < viewportTop) {
          return {
            ...params,
            behavior,
            align: align ?? "start"
          };
        }
        if (itemBottom > viewportBottom) {
          return {
            ...params,
            behavior,
            align: align ?? "end",
            offset: rowScrollMarginBottomRef.current
          };
        }
        return null;
      },
      []
    );
    useEffect(() => {
      if (interaction === "keyboard") {
        virtuosoRef.current?.scrollIntoView({
          index: selectedRowIndex,
          behavior: "auto",
          calculateViewLocation
        });
      }
    }, [interaction, selectedRowIndex, calculateViewLocation]);
    return /* @__PURE__ */ React__default.createElement(Component, {
      ...props,
      ref: forwardedRef
    }, /* @__PURE__ */ React__default.createElement("div", {
      style: {
        visibility: "hidden",
        height: 0
      },
      ref: placeholderContainerRef
    }, /* @__PURE__ */ React__default.createElement(Row, {
      attributes: placeholderRowAttributes
    }, placeholderColumns.map((placeholder, index) => /* @__PURE__ */ React__default.createElement(Emoji, {
      emoji: placeholder,
      key: index
    }))), /* @__PURE__ */ React__default.createElement(CategoryHeader, {
      category: "Category"
    })), isLoading ? /* @__PURE__ */ React__default.createElement(Loading, null) : error ? /* @__PURE__ */ React__default.createElement(Error, {
      error
    }) : data.count === 0 ? /* @__PURE__ */ React__default.createElement(Empty, null) : /* @__PURE__ */ React__default.createElement(Grid, null, /* @__PURE__ */ React__default.createElement(GroupedVirtuoso, {
      ref: virtuosoRef,
      components: {
        Scroller: VirtuosoScroller,
        List: VirtuosoList,
        TopItemList: VirtuosoTopList
      },
      groupCounts: data.categoriesRowCounts,
      groupContent: (groupIndex) => {
        return /* @__PURE__ */ React__default.createElement(CategoryHeader, {
          category: data.categories[groupIndex]
        });
      },
      itemContent: (rowIndex, groupIndex) => {
        const categoryRowIndex = data.categoriesRowIndices[groupIndex].indexOf(rowIndex);
        const categoryRowsCount = data.categoriesRowCounts[groupIndex];
        return /* @__PURE__ */ React__default.createElement(Row, {
          attributes: {
            rowIndex,
            categoryRowIndex,
            categoryRowsCount
          }
        }, data.rows[rowIndex].map((emoji, columnIndex) => {
          const isSelected = interaction !== "none" && selectedColumnIndex === columnIndex && selectedRowIndex === rowIndex;
          return /* @__PURE__ */ React__default.createElement(Emoji, {
            key: emoji.emoji,
            role: "gridcell",
            "aria-colindex": columnIndex,
            "aria-selected": isSelected || void 0,
            "data-selected": isSelected || void 0,
            onMouseDown: preventDefault,
            tabIndex: -1,
            onPointerEnter: () => {
              setPointerSelection(columnIndex, rowIndex);
            },
            onPointerLeave: handleEmojiPointerLeave,
            onClick: (event) => {
              onEmojiSelect?.(emoji.emoji);
              event.stopPropagation();
            },
            emoji: emoji.emoji
          });
        }));
      }
    })), selectedEmoji && interaction !== "none" && /* @__PURE__ */ React__default.createElement("div", {
      "aria-live": "polite",
      style: visuallyHidden
    }, selectedEmoji.name));
  }
);
if (process.env.NODE_ENV !== "production") {
  EmojiPickerRoot.displayName = EMOJIPICKER_ROOT_NAME;
  EmojiPickerContent.displayName = EMOJIPICKER_CONTENT_NAME;
  EmojiPickerSearch.displayName = EMOJIPICKER_SEARCH_NAME;
}

export { EmojiPickerContent as Content, EmojiPickerRoot as Root, EmojiPickerSearch as Search };
//# sourceMappingURL=index.mjs.map
