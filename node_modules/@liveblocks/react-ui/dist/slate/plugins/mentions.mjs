import { Editor, Transforms, Range, Element } from 'slate';
import { getCharacterAfter, getCharacterBefore } from '../utils/get-character.mjs';
import { getMatchRange } from '../utils/get-match-range.mjs';
import { isEmptyString } from '../utils/is-empty-string.mjs';
import { isSelectionCollapsed } from '../utils/is-selection-collapsed.mjs';

const MENTION_CHARACTER = "@";
function getMentionDraftAtSelection(editor) {
  const { selection } = editor;
  if (!isSelectionCollapsed(selection)) {
    return;
  }
  const match = getMatchRange(editor, selection);
  if (!match) {
    return;
  }
  const matchText = Editor.string(editor, match);
  if (!matchText.startsWith(MENTION_CHARACTER)) {
    return;
  }
  return {
    range: match,
    text: matchText.substring(1)
  };
}
function isComposerBodyMention(node) {
  return Element.isElement(node) && node.type === "mention";
}
function insertMention(editor, userId) {
  const mention = {
    type: "mention",
    id: userId,
    children: [{ text: "" }]
  };
  Transforms.insertNodes(editor, mention);
  Transforms.move(editor);
  const afterCharacter = editor.selection ? getCharacterAfter(editor, editor.selection) : void 0;
  if (!afterCharacter || afterCharacter.void) {
    Transforms.insertText(editor, " ");
  } else if (isEmptyString(afterCharacter.text)) {
    Transforms.move(editor);
  }
}
function insertMentionCharacter(editor) {
  if (!editor.selection) {
    return;
  }
  const beforeCharacter = getCharacterBefore(editor, editor.selection, {
    filterVoids: true
  });
  const afterCharacter = getCharacterAfter(editor, editor.selection, {
    filterVoids: true
  });
  const shouldInsertSpaceBefore = beforeCharacter && !isEmptyString(beforeCharacter.text);
  const shouldInsertSpaceAfter = afterCharacter && !isEmptyString(afterCharacter.text);
  if (isSelectionCollapsed(editor.selection)) {
    const text = (shouldInsertSpaceBefore ? " " : "") + MENTION_CHARACTER + (shouldInsertSpaceAfter ? " " : "");
    editor.insertText(text);
    if (shouldInsertSpaceAfter) {
      Transforms.move(editor, {
        distance: 1,
        unit: "character",
        reverse: true
      });
    }
  } else {
    const beforeText = (shouldInsertSpaceBefore ? " " : "") + MENTION_CHARACTER;
    editor.insertText(beforeText, { at: Range.start(editor.selection) });
    if (shouldInsertSpaceAfter) {
      editor.insertText(" ", { at: Range.end(editor.selection) });
    }
    Transforms.collapse(editor, { edge: "end" });
  }
}
function withMentions(editor) {
  const { isInline, isVoid, markableVoid, deleteBackward } = editor;
  editor.isInline = (element) => {
    return isComposerBodyMention(element) || isInline(element);
  };
  editor.isVoid = (element) => {
    return isComposerBodyMention(element) || isVoid(element);
  };
  editor.markableVoid = (element) => {
    return isComposerBodyMention(element) || markableVoid(element);
  };
  editor.deleteBackward = (unit) => {
    const { selection } = editor;
    if (isSelectionCollapsed(selection)) {
      const [mention] = Editor.nodes(editor, {
        at: unit === "character" ? Editor.before(editor, selection, { unit: "character" }) : selection,
        match: isComposerBodyMention
      });
      deleteBackward(unit);
      if (mention) {
        Transforms.insertText(editor, MENTION_CHARACTER);
      }
    } else {
      deleteBackward(unit);
    }
  };
  return editor;
}

export { MENTION_CHARACTER, getMentionDraftAtSelection, insertMention, insertMentionCharacter, isComposerBodyMention, withMentions };
//# sourceMappingURL=mentions.mjs.map
