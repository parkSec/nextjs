'use strict';

var slate = require('slate');
var getCharacter = require('../utils/get-character.js');
var getMatchRange = require('../utils/get-match-range.js');
var isEmptyString = require('../utils/is-empty-string.js');
var isSelectionCollapsed = require('../utils/is-selection-collapsed.js');

const MENTION_CHARACTER = "@";
function getMentionDraftAtSelection(editor) {
  const { selection } = editor;
  if (!isSelectionCollapsed.isSelectionCollapsed(selection)) {
    return;
  }
  const match = getMatchRange.getMatchRange(editor, selection);
  if (!match) {
    return;
  }
  const matchText = slate.Editor.string(editor, match);
  if (!matchText.startsWith(MENTION_CHARACTER)) {
    return;
  }
  return {
    range: match,
    text: matchText.substring(1)
  };
}
function isComposerBodyMention(node) {
  return slate.Element.isElement(node) && node.type === "mention";
}
function insertMention(editor, userId) {
  const mention = {
    type: "mention",
    id: userId,
    children: [{ text: "" }]
  };
  slate.Transforms.insertNodes(editor, mention);
  slate.Transforms.move(editor);
  const afterCharacter = editor.selection ? getCharacter.getCharacterAfter(editor, editor.selection) : void 0;
  if (!afterCharacter || afterCharacter.void) {
    slate.Transforms.insertText(editor, " ");
  } else if (isEmptyString.isEmptyString(afterCharacter.text)) {
    slate.Transforms.move(editor);
  }
}
function insertMentionCharacter(editor) {
  if (!editor.selection) {
    return;
  }
  const beforeCharacter = getCharacter.getCharacterBefore(editor, editor.selection, {
    filterVoids: true
  });
  const afterCharacter = getCharacter.getCharacterAfter(editor, editor.selection, {
    filterVoids: true
  });
  const shouldInsertSpaceBefore = beforeCharacter && !isEmptyString.isEmptyString(beforeCharacter.text);
  const shouldInsertSpaceAfter = afterCharacter && !isEmptyString.isEmptyString(afterCharacter.text);
  if (isSelectionCollapsed.isSelectionCollapsed(editor.selection)) {
    const text = (shouldInsertSpaceBefore ? " " : "") + MENTION_CHARACTER + (shouldInsertSpaceAfter ? " " : "");
    editor.insertText(text);
    if (shouldInsertSpaceAfter) {
      slate.Transforms.move(editor, {
        distance: 1,
        unit: "character",
        reverse: true
      });
    }
  } else {
    const beforeText = (shouldInsertSpaceBefore ? " " : "") + MENTION_CHARACTER;
    editor.insertText(beforeText, { at: slate.Range.start(editor.selection) });
    if (shouldInsertSpaceAfter) {
      editor.insertText(" ", { at: slate.Range.end(editor.selection) });
    }
    slate.Transforms.collapse(editor, { edge: "end" });
  }
}
function withMentions(editor) {
  const { isInline, isVoid, markableVoid, deleteBackward } = editor;
  editor.isInline = (element) => {
    return isComposerBodyMention(element) || isInline(element);
  };
  editor.isVoid = (element) => {
    return isComposerBodyMention(element) || isVoid(element);
  };
  editor.markableVoid = (element) => {
    return isComposerBodyMention(element) || markableVoid(element);
  };
  editor.deleteBackward = (unit) => {
    const { selection } = editor;
    if (isSelectionCollapsed.isSelectionCollapsed(selection)) {
      const [mention] = slate.Editor.nodes(editor, {
        at: unit === "character" ? slate.Editor.before(editor, selection, { unit: "character" }) : selection,
        match: isComposerBodyMention
      });
      deleteBackward(unit);
      if (mention) {
        slate.Transforms.insertText(editor, MENTION_CHARACTER);
      }
    } else {
      deleteBackward(unit);
    }
  };
  return editor;
}

exports.MENTION_CHARACTER = MENTION_CHARACTER;
exports.getMentionDraftAtSelection = getMentionDraftAtSelection;
exports.insertMention = insertMention;
exports.insertMentionCharacter = insertMentionCharacter;
exports.isComposerBodyMention = isComposerBodyMention;
exports.withMentions = withMentions;
//# sourceMappingURL=mentions.js.map
