{"version":3,"file":"auto-links.js","sources":["../../../src/slate/plugins/auto-links.ts"],"sourcesContent":["import type { NodeEntry, Text } from \"slate\";\nimport { Editor, Element, Node, Path, Range, Transforms } from \"slate\";\n\nimport type { ComposerBodyAutoLink } from \"../../types\";\nimport { isPlainText, isText } from \"../utils/is-text\";\nimport { isComposerBodyCustomLink } from \"./custom-links\";\n\n/**\n * This implementation is inspired by Lexical's AutoLink plugin.\n * Additional modifications and features were added to adapt it to our specific needs.\n *\n * Original Lexical AutoLink plugin can be found at [Lexical's Github Repository](https://github.com/facebook/lexical/blob/main/packages/lexical-react/src/LexicalAutoLinkPlugin.ts)\n */\nexport function withAutoLinks(editor: Editor): Editor {\n  const { isInline, normalizeNode, deleteBackward } = editor;\n\n  editor.isInline = (element) => {\n    return element.type === \"auto-link\" ? true : isInline(element);\n  };\n\n  editor.normalizeNode = (entry) => {\n    const [node, path] = entry;\n\n    // Prevent auto links from being created inside custom links\n    if (isComposerBodyCustomLink(node)) {\n      return;\n    }\n\n    if (isText(node)) {\n      const parentNode = Node.parent(editor, path);\n\n      // Prevent auto links from being created inside custom links\n      if (isComposerBodyCustomLink(parentNode)) {\n        return;\n      } else if (isComposerBodyAutoLink(parentNode)) {\n        const parentPath = Path.parent(path);\n        handleLinkEdit(editor, [parentNode, parentPath]);\n\n        // Prevent rich text within auto links by removing all marks of inner text nodes\n        if (!isPlainText(node)) {\n          const marks = Object.keys(node).filter((key) => key !== \"text\");\n\n          Transforms.unsetNodes(editor, marks, { at: path });\n        }\n      } else {\n        handleLinkCreate(editor, [node, path]);\n        handleNeighbours(editor, [node, path]);\n      }\n    }\n\n    normalizeNode(entry);\n  };\n\n  editor.deleteBackward = (unit) => {\n    deleteBackward(unit);\n    const { selection } = editor;\n    if (!selection) return;\n\n    if (!Range.isCollapsed(selection)) return;\n\n    const [match] = Editor.nodes(editor, {\n      at: selection,\n      match: isComposerBodyAutoLink,\n      mode: \"lowest\",\n    });\n\n    if (!match) return;\n\n    Transforms.unwrapNodes(editor, {\n      match: isComposerBodyAutoLink,\n    });\n  };\n\n  return editor;\n}\n\nexport function isComposerBodyAutoLink(\n  node: Node\n): node is ComposerBodyAutoLink {\n  return Element.isElement(node) && node.type === \"auto-link\";\n}\n\n/**\n * 1. ((https?:\\/\\/(www\\.)?)|(www\\.))\n * - Matches 'http://' or 'https://' optionally followed by 'www.', or just 'www.'\n *\n * 2. [-a-zA-Z0-9@:%._+~#=]{1,256}\n * - Matches any character in the set [-a-zA-Z0-9@:%._+~#=] between 1 and 256 times, often found in the domain and subdomain part of the URL\n *\n * 3. \\.[a-zA-Z0-9()]{1,6}\n * - Matches a period followed by any character in the set [a-zA-Z0-9()] between 1 and 6 times, usually indicating the domain extension like .com, .org, etc.\n *\n * 4. \\b\n * - Represents a word boundary, ensuring that the characters following cannot be part of a different word\n *\n * 5. ([-a-zA-Z0-9().@:%_+~#?&//=]*)\n * - Matches any character in the set [-a-zA-Z0-9().@:%_+~#?&//=] between 0 and unlimited times, often found in the path, query parameters, or anchor part of the URL\n *\n * Matching URLs:\n * - http://www.example.com\n * - https://www.example.com\n * - www.example.com\n * - https://example.com/path?query=param#anchor\n *\n * Non-Matching URLs:\n * - http:/example.com (malformed scheme)\n * - example (missing scheme and domain extension)\n * - ftp://example.com (ftp scheme is not supported)\n * - example.com (missing scheme)\n */\nconst URL_REGEX =\n  /((https?:\\/\\/(www\\.)?)|(www\\.))[-a-zA-Z0-9@:%._+~#=]{1,256}\\.[a-zA-Z0-9()]{1,6}\\b([-a-zA-Z0-9().@:%_+~#?&//=]*)/;\n\nconst PUNCTUATION_OR_SPACE = /[.,;!?\\s()]/;\n\nconst PERIOD_OR_QUESTION_MARK_FOLLOWED_BY_ALPHANUMERIC = /^[.?][a-zA-Z0-9]+/;\n\nconst PARENTHESES = /[()]/;\n\n/**\n * Helper function to check if a character is a separator (punctuation or space)\n * @param char The character to check\n * @returns Whether the character is a separator or not\n */\nfunction isSeparator(char: string): boolean {\n  return PUNCTUATION_OR_SPACE.test(char);\n}\n\n/**\n * Helper function to check if a text content ends with a separator (punctuation or space)\n * @param textContent The text content to check\n * @returns Whether the text content ends with a separator or not\n */\nfunction endsWithSeparator(textContent: string): boolean {\n  return isSeparator(textContent[textContent.length - 1]);\n}\n\n/**\n * Helper function to check if a text content starts with a separator (punctuation or space)\n * @param textContent The text content to check\n * @returns Whether the text content starts with a separator or not\n */\nfunction startsWithSeparator(textContent: string): boolean {\n  return isSeparator(textContent[0]);\n}\n\n/**\n * Helper function to check if a text content ends with a period or question mark\n * @param textContent The text content to check\n * @returns Whether the text content ends with a period or not\n */\nfunction endsWithPeriodOrQuestionMark(textContent: string): boolean {\n  return (\n    textContent[textContent.length - 1] === \".\" ||\n    textContent[textContent.length - 1] === \"?\"\n  );\n}\n\n/**\n * Helper function to get the \"logical length\" of a URL, taking into account things like opening/closing parentheses\n * @param url The URL to check\n * @returns The \"logical length\" of the URL\n */\nfunction getUrlLogicalLength(url: string): number {\n  if (!PARENTHESES.test(url)) {\n    return url.length;\n  }\n\n  let logicalLength = 0;\n  let parenthesesCount = 0;\n\n  for (const character of url) {\n    if (character === \"(\") {\n      parenthesesCount++;\n    }\n\n    if (character === \")\") {\n      parenthesesCount--;\n\n      if (parenthesesCount < 0) {\n        break;\n      }\n    }\n\n    logicalLength++;\n  }\n\n  return logicalLength;\n}\n\n/**\n * Helper function to check if the previous node is valid (text node that ends with a separator or is empty)\n */\nfunction isPreviousNodeValid(editor: Editor, path: Path): boolean {\n  const entry = Editor.previous(editor, { at: path });\n  if (!entry) return true;\n\n  return (\n    isText(entry[0]) &&\n    (endsWithSeparator(entry[0].text) || entry[0].text === \"\")\n  );\n}\n\n/**\n * Helper function to check if the next node is valid (text node that starts with a separator or is empty)\n */\nfunction isNextNodeValid(editor: Editor, path: Path): boolean {\n  const entry = Editor.next(editor, { at: path });\n  if (!entry) return true;\n\n  return (\n    isText(entry[0]) &&\n    (startsWithSeparator(entry[0].text) || entry[0].text === \"\")\n  );\n}\n\n/**\n * Helper function to check if the content around a text node is valid.\n * @param editor\n * @param entry\n * @param start\n * @param end\n * @returns\n */\nfunction isContentAroundValid(\n  editor: Editor,\n  entry: NodeEntry<Text>,\n  start: number,\n  end: number\n): boolean {\n  const [node, path] = entry;\n  const text = node.text;\n\n  const contentBeforeIsValid =\n    start > 0\n      ? isSeparator(text[start - 1])\n      : isPreviousNodeValid(editor, path);\n\n  const contentAfterIsValid =\n    end < text.length ? isSeparator(text[end]) : isNextNodeValid(editor, path);\n\n  return contentBeforeIsValid && contentAfterIsValid;\n}\n\nconst handleLinkEdit = (\n  editor: Editor,\n  entry: NodeEntry<ComposerBodyAutoLink>\n) => {\n  const [node, path] = entry;\n\n  // Step 1: Ensure that the Link node only contains text nodes as children\n  const children = Node.children(editor, path);\n  for (const [child] of children) {\n    if (isText(child)) continue;\n    Transforms.unwrapNodes(editor, { at: path });\n    return;\n  }\n  // Attempt to match the text content (of the Link node) against the URL regex\n  const text = Node.string(node);\n  const match = URL_REGEX.exec(text);\n\n  // Step 2: Ensure that the text content of the Link node matches the URL regex and is identical to the match\n  if (!match || match[0] !== text) {\n    Transforms.unwrapNodes(editor, { at: path });\n    return;\n  }\n\n  // Step 3: Ensure that if the text content of the Link node ends with a period, we unwrap the Link node and wrap the text before the period in a new Link node\n  if (endsWithPeriodOrQuestionMark(text)) {\n    Transforms.unwrapNodes(editor, { at: path });\n\n    const textBeforePeriod = text.slice(0, text.length - 1);\n\n    // Remove the last character from the link text and wrap the remaining text in a new link node\n    Transforms.wrapNodes<ComposerBodyAutoLink>(\n      editor,\n      {\n        type: \"auto-link\",\n        url: textBeforePeriod,\n        children: [],\n      },\n      {\n        at: {\n          anchor: { path, offset: 0 },\n          focus: { path, offset: textBeforePeriod.length },\n        },\n        split: true,\n      }\n    );\n    return;\n  }\n\n  // Step 4: Allow some conditions to shorten the URL (e.g. supporting parentheses but only if they are balanced)\n  const logicalLength = getUrlLogicalLength(text);\n\n  if (logicalLength < text.length) {\n    Transforms.unwrapNodes(editor, { at: path });\n\n    const logicalText = text.slice(0, logicalLength);\n\n    // Keep the \"logical\" text and wrap it in a new link node\n    Transforms.wrapNodes<ComposerBodyAutoLink>(\n      editor,\n      {\n        type: \"auto-link\",\n        url: logicalText,\n        children: [],\n      },\n      {\n        at: {\n          anchor: { path, offset: 0 },\n          focus: { path, offset: logicalText.length },\n        },\n        split: true,\n      }\n    );\n    return;\n  }\n\n  // Step 5: Ensure that the text content of the Link node is surrounded by separators or the start/end of the text content\n  if (!isPreviousNodeValid(editor, path) || !isNextNodeValid(editor, path)) {\n    Transforms.unwrapNodes(editor, { at: path });\n    return;\n  }\n\n  // Step 6: Ensure that the url attribute of the Link node is identical to its text content\n  if (node.url !== text) {\n    Transforms.setNodes(editor, { url: match[0] }, { at: path });\n    return;\n  }\n};\n\nconst handleLinkCreate = (editor: Editor, entry: NodeEntry<Text>) => {\n  const [node, path] = entry;\n\n  // Step 1: Ensure that the text content of the node matches the URL regex\n  const match = URL_REGEX.exec(node.text);\n  if (!match) return;\n\n  const start = match.index;\n  const end = start + match[0].length;\n\n  // Step 2: Ensure that the content around the node is valid\n  if (!isContentAroundValid(editor, entry, start, end)) return;\n\n  Transforms.wrapNodes<ComposerBodyAutoLink>(\n    editor,\n    {\n      type: \"auto-link\",\n      url: match[0],\n      children: [],\n    },\n    {\n      at: {\n        anchor: { path, offset: start },\n        focus: { path, offset: end },\n      },\n      split: true,\n    }\n  );\n  return;\n};\n\nconst handleNeighbours = (editor: Editor, entry: NodeEntry<Text>) => {\n  const [node, path] = entry;\n  const text = node.text;\n\n  const previousSibling = Editor.previous(editor, { at: path });\n\n  if (previousSibling && isComposerBodyAutoLink(previousSibling[0])) {\n    if (PERIOD_OR_QUESTION_MARK_FOLLOWED_BY_ALPHANUMERIC.test(text)) {\n      Transforms.unwrapNodes(editor, { at: previousSibling[1] });\n      Transforms.mergeNodes(editor, { at: path });\n      return;\n    }\n\n    if (!startsWithSeparator(text)) {\n      Transforms.unwrapNodes(editor, { at: previousSibling[1] });\n      return;\n    }\n  }\n\n  const nextSibling = Editor.next(editor, { at: path });\n  if (\n    nextSibling &&\n    isComposerBodyAutoLink(nextSibling[0]) &&\n    !endsWithSeparator(text)\n  ) {\n    Transforms.unwrapNodes(editor, { at: nextSibling[1] });\n    return;\n  }\n};\n"],"names":["isComposerBodyCustomLink","isText","Node","Path","isPlainText","Transforms","Range","Editor","Element"],"mappings":"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"}