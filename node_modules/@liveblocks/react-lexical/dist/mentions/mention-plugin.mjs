import { useFloating, flip, offset, hide, shift, limitShift, size, autoUpdate } from '@floating-ui/react-dom';
import { useLexicalComposerContext } from '@lexical/react/LexicalComposerContext';
import { kInternal } from '@liveblocks/core';
import { useRoom } from '@liveblocks/react';
import { useMentionSuggestions } from '@liveblocks/react-ui';
import { $getSelection, $isRangeSelection, $isTextNode, $getNodeByKey, $isNodeSelection, $createTextNode, $createRangeSelection, $setSelection, $isElementNode, KEY_BACKSPACE_COMMAND, COMMAND_PRIORITY_LOW } from 'lexical';
import React__default, { useState, useEffect, useCallback, useLayoutEffect } from 'react';
import { createPortal } from 'react-dom';
import { Avatar } from './avatar.mjs';
import { $isMentionNode, MentionNode, $createMentionNode } from './mention-node.mjs';
import { SuggestionsContext, OnValueSelectCallbackContext, OnResetMatchCallbackContext, List, Item } from './suggestions.mjs';
import { User } from './user.mjs';

const MENTION_TRIGGER = "@";
const PUNCTUATIONS = `\\.,\\+\\*\\?\\$\\@\\|#{}\\(\\)\\^\\-\\[\\]\\\\/!%'"~=<>_:;`;
const VALID_CHARACTERS = "[^" + MENTION_TRIGGER + PUNCTUATIONS + "\\s]";
const VALID_JOINS = "(?:\\.[ |$]| |[" + PUNCTUATIONS + "]|)";
const LENGTH_LIMIT = 75;
const MentionRegex = new RegExp(
  "(^|\\s|\\()([" + MENTION_TRIGGER + "]((?:" + VALID_CHARACTERS + VALID_JOINS + "){0," + LENGTH_LIMIT + "}))$"
);
function $getAnchorNodeTextContent() {
  const selection = $getSelection();
  if (!$isRangeSelection(selection))
    return null;
  const anchor = selection.anchor;
  if (anchor.type !== "text")
    return null;
  const anchorNode = anchor.getNode();
  if (!anchorNode.isSimpleText())
    return null;
  const anchorOffset = anchor.offset;
  return anchorNode.getTextContent().slice(0, anchorOffset);
}
function getFullMatchOffset(documentText, entryText, offset2) {
  let triggerOffset = offset2;
  for (let i = triggerOffset; i <= entryText.length; i++) {
    if (documentText.substr(-i) === entryText.substr(0, i)) {
      triggerOffset = i;
    }
  }
  return triggerOffset;
}
function $isCurrentSelectionAtBoundary(offset2) {
  if (offset2 !== 0)
    return false;
  const selection = $getSelection();
  if (!$isRangeSelection(selection))
    return false;
  const anchor = selection.anchor.getNode();
  const prevSibling = anchor.getPreviousSibling();
  if (!$isTextNode(prevSibling))
    return false;
  if (!prevSibling.isTextEntity())
    return false;
  return true;
}
function $getRangeAtMatch(match) {
  const offsetWithWhitespaces = match.index + match[1].length;
  if ($isCurrentSelectionAtBoundary(offsetWithWhitespaces))
    return null;
  const selection = window.getSelection();
  if (selection === null)
    return null;
  if (!selection.isCollapsed)
    return null;
  const anchor = selection.anchorNode;
  if (anchor === null)
    return null;
  const endOffset = selection.anchorOffset;
  if (endOffset === null)
    return null;
  const range = document.createRange();
  try {
    range.setStart(anchor, offsetWithWhitespaces);
    range.setEnd(anchor, endOffset);
    return range;
  } catch (error) {
    return null;
  }
}
function MentionPlugin() {
  const [editor] = useLexicalComposerContext();
  const [match, setMatch] = useState(null);
  const matchingString = match?.[3];
  const suggestions = useMentionSuggestions(matchingString);
  const room = useRoom();
  useEffect(() => {
    function $handleMutation(mutations, {
      prevEditorState
    }) {
      for (const [key, mutation] of mutations) {
        if (mutation === "created") {
          editor.getEditorState().read(() => {
            const node = $getNodeByKey(key);
            if (node === null)
              return;
            if (!$isMentionNode(node))
              return;
            room[kInternal].createTextMention(node.getUserId(), node.getId()).catch((err) => {
              console.error(err);
            });
          });
        } else if (mutation === "destroyed") {
          prevEditorState.read(() => {
            const node = $getNodeByKey(key);
            if (node === null)
              return;
            if (!$isMentionNode(node))
              return;
            room[kInternal].deleteTextMention(node.getId()).catch((err) => {
              console.error(err);
            });
          });
        }
      }
    }
    return editor.registerMutationListener(
      MentionNode,
      (mutations, payload) => {
        if (payload.updateTags.has("collaboration") || payload.updateTags.has("history-merge")) {
          return;
        }
        $handleMutation(mutations, payload);
      }
    );
  }, [editor, room]);
  useEffect(() => {
    function $onStateRead() {
      const text = $getAnchorNodeTextContent();
      if (text === null) {
        setMatch(null);
        return;
      }
      const match2 = MentionRegex.exec(text);
      setMatch(match2);
    }
    return editor.registerUpdateListener(({ editorState: state }) => {
      state.read($onStateRead);
    });
  }, [editor]);
  useEffect(() => {
    function $handleBackspace(event) {
      const selection = $getSelection();
      if (selection === null)
        return false;
      if ($isNodeSelection(selection)) {
        const nodes = selection.getNodes();
        if (nodes.length !== 1)
          return false;
        const node = nodes[0];
        if (!$isMentionNode(node))
          return false;
        const text = $createTextNode("@");
        node.replace(text);
        const newSelection = $createRangeSelection();
        newSelection.setTextNodeRange(text, 1, text, 1);
        $setSelection(newSelection);
        event.preventDefault();
        return true;
      } else if ($isRangeSelection(selection)) {
        if (!selection.isCollapsed())
          return false;
        const anchor = selection.anchor.getNode();
        const prevSibling = anchor.getPreviousSibling();
        if (selection.anchor.offset === 0 && $isMentionNode(prevSibling)) {
          const text = $createTextNode("@");
          prevSibling.replace(text);
          const newSelection = $createRangeSelection();
          newSelection.setTextNodeRange(text, 1, text, 1);
          $setSelection(newSelection);
          event.preventDefault();
          return true;
        } else if ($isElementNode(anchor)) {
          const child = anchor.getChildAtIndex(selection.anchor.offset - 1);
          if (!$isMentionNode(child))
            return false;
          const text = $createTextNode("@");
          child.replace(text);
          const newSelection = $createRangeSelection();
          newSelection.setTextNodeRange(text, 1, text, 1);
          $setSelection(newSelection);
          event.preventDefault();
          return true;
        }
        return false;
      }
      return false;
    }
    return editor.registerCommand(
      KEY_BACKSPACE_COMMAND,
      $handleBackspace,
      COMMAND_PRIORITY_LOW
    );
  }, [editor]);
  const handleValueSelect = useCallback(
    (userId) => {
      function $onValueSelect() {
        if (match === null)
          return;
        setMatch(null);
        const selection = $getSelection();
        if (!$isRangeSelection(selection))
          return;
        if (!selection.isCollapsed())
          return;
        const anchor = selection.anchor;
        if (anchor.type !== "text")
          return;
        const anchorNode = anchor.getNode();
        if (!anchorNode.isSimpleText())
          return;
        const selectionOffset = anchor.offset;
        const text = anchorNode.getTextContent().slice(0, selectionOffset);
        const characterOffset = match[2].length;
        const queryOffset = getFullMatchOffset(text, match[2], characterOffset);
        const startOffset = selectionOffset - queryOffset;
        if (startOffset < 0)
          return;
        const mentionNode = $createMentionNode(userId);
        if (startOffset === 0) {
          const [node] = anchorNode.splitText(selectionOffset);
          node.replace(mentionNode);
        } else {
          const [, node] = anchorNode.splitText(startOffset, selectionOffset);
          node.replace(mentionNode);
        }
      }
      editor.update($onValueSelect);
    },
    [editor, match]
  );
  if (match === null || matchingString === void 0)
    return null;
  if (suggestions === void 0 || suggestions.length === 0)
    return null;
  const range = editor.getEditorState().read(() => $getRangeAtMatch(match));
  if (range === null)
    return null;
  return createPortal(
    /* @__PURE__ */ React__default.createElement(SuggestionsContext.Provider, {
      value: suggestions
    }, /* @__PURE__ */ React__default.createElement(OnValueSelectCallbackContext.Provider, {
      value: handleValueSelect
    }, /* @__PURE__ */ React__default.createElement(OnResetMatchCallbackContext.Provider, {
      value: () => setMatch(null)
    }, /* @__PURE__ */ React__default.createElement(SuggestionsPortal, {
      range,
      container: document.body,
      key: matchingString
    }, /* @__PURE__ */ React__default.createElement(List, {
      className: "lb-lexical-suggestions-list lb-lexical-mention-suggestions-list"
    }, suggestions.map((userId) => /* @__PURE__ */ React__default.createElement(Item, {
      key: userId,
      value: userId,
      className: "lb-lexical-suggestions-list-item lb-lexical-mention-suggestion"
    }, /* @__PURE__ */ React__default.createElement(Avatar, {
      userId,
      className: "lb-lexical-mention-suggestion-avatar"
    }), /* @__PURE__ */ React__default.createElement(User, {
      userId,
      className: "lb-lexical-mention-suggestion-user"
    })))))))),
    document.body
  );
}
const SUGGESTIONS_COLLISION_PADDING = 10;
function SuggestionsPortal({
  children,
  range,
  container
}) {
  const {
    refs: { setReference, setFloating },
    strategy,
    x,
    y
  } = useFloating({
    strategy: "fixed",
    placement: "top-start",
    middleware: [
      flip({ padding: SUGGESTIONS_COLLISION_PADDING, crossAxis: false }),
      offset(10),
      hide({ padding: SUGGESTIONS_COLLISION_PADDING }),
      shift({ padding: SUGGESTIONS_COLLISION_PADDING, limiter: limitShift() }),
      size({ padding: SUGGESTIONS_COLLISION_PADDING })
    ],
    whileElementsMounted: (...args) => {
      return autoUpdate(...args, {
        animationFrame: true
      });
    }
  });
  useLayoutEffect(() => {
    setReference({
      getBoundingClientRect: () => range.getBoundingClientRect()
    });
  }, [setReference, range]);
  return createPortal(
    /* @__PURE__ */ React__default.createElement("div", {
      ref: setFloating,
      style: {
        position: strategy,
        top: 0,
        left: 0,
        transform: `translate3d(${Math.round(x)}px, ${Math.round(y)}px, 0)`,
        minWidth: "max-content"
      },
      className: "lb-root lb-portal lb-elevation lb-lexical-suggestions lb-lexical-mention-suggestions"
    }, children),
    container
  );
}

export { MentionPlugin, SUGGESTIONS_COLLISION_PADDING };
//# sourceMappingURL=mention-plugin.mjs.map
