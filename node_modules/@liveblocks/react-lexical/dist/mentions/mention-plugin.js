'use strict';

var reactDom$1 = require('@floating-ui/react-dom');
var LexicalComposerContext = require('@lexical/react/LexicalComposerContext');
var core = require('@liveblocks/core');
var react = require('@liveblocks/react');
var reactUi = require('@liveblocks/react-ui');
var lexical = require('lexical');
var React = require('react');
var reactDom = require('react-dom');
var avatar = require('./avatar.js');
var mentionNode = require('./mention-node.js');
var suggestions = require('./suggestions.js');
var user = require('./user.js');

const MENTION_TRIGGER = "@";
const PUNCTUATIONS = `\\.,\\+\\*\\?\\$\\@\\|#{}\\(\\)\\^\\-\\[\\]\\\\/!%'"~=<>_:;`;
const VALID_CHARACTERS = "[^" + MENTION_TRIGGER + PUNCTUATIONS + "\\s]";
const VALID_JOINS = "(?:\\.[ |$]| |[" + PUNCTUATIONS + "]|)";
const LENGTH_LIMIT = 75;
const MentionRegex = new RegExp(
  "(^|\\s|\\()([" + MENTION_TRIGGER + "]((?:" + VALID_CHARACTERS + VALID_JOINS + "){0," + LENGTH_LIMIT + "}))$"
);
function $getAnchorNodeTextContent() {
  const selection = lexical.$getSelection();
  if (!lexical.$isRangeSelection(selection))
    return null;
  const anchor = selection.anchor;
  if (anchor.type !== "text")
    return null;
  const anchorNode = anchor.getNode();
  if (!anchorNode.isSimpleText())
    return null;
  const anchorOffset = anchor.offset;
  return anchorNode.getTextContent().slice(0, anchorOffset);
}
function getFullMatchOffset(documentText, entryText, offset2) {
  let triggerOffset = offset2;
  for (let i = triggerOffset; i <= entryText.length; i++) {
    if (documentText.substr(-i) === entryText.substr(0, i)) {
      triggerOffset = i;
    }
  }
  return triggerOffset;
}
function $isCurrentSelectionAtBoundary(offset2) {
  if (offset2 !== 0)
    return false;
  const selection = lexical.$getSelection();
  if (!lexical.$isRangeSelection(selection))
    return false;
  const anchor = selection.anchor.getNode();
  const prevSibling = anchor.getPreviousSibling();
  if (!lexical.$isTextNode(prevSibling))
    return false;
  if (!prevSibling.isTextEntity())
    return false;
  return true;
}
function $getRangeAtMatch(match) {
  const offsetWithWhitespaces = match.index + match[1].length;
  if ($isCurrentSelectionAtBoundary(offsetWithWhitespaces))
    return null;
  const selection = window.getSelection();
  if (selection === null)
    return null;
  if (!selection.isCollapsed)
    return null;
  const anchor = selection.anchorNode;
  if (anchor === null)
    return null;
  const endOffset = selection.anchorOffset;
  if (endOffset === null)
    return null;
  const range = document.createRange();
  try {
    range.setStart(anchor, offsetWithWhitespaces);
    range.setEnd(anchor, endOffset);
    return range;
  } catch (error) {
    return null;
  }
}
function MentionPlugin() {
  const [editor] = LexicalComposerContext.useLexicalComposerContext();
  const [match, setMatch] = React.useState(null);
  const matchingString = match?.[3];
  const suggestions$1 = reactUi.useMentionSuggestions(matchingString);
  const room = react.useRoom();
  React.useEffect(() => {
    function $handleMutation(mutations, {
      prevEditorState
    }) {
      for (const [key, mutation] of mutations) {
        if (mutation === "created") {
          editor.getEditorState().read(() => {
            const node = lexical.$getNodeByKey(key);
            if (node === null)
              return;
            if (!mentionNode.$isMentionNode(node))
              return;
            room[core.kInternal].createTextMention(node.getUserId(), node.getId()).catch((err) => {
              console.error(err);
            });
          });
        } else if (mutation === "destroyed") {
          prevEditorState.read(() => {
            const node = lexical.$getNodeByKey(key);
            if (node === null)
              return;
            if (!mentionNode.$isMentionNode(node))
              return;
            room[core.kInternal].deleteTextMention(node.getId()).catch((err) => {
              console.error(err);
            });
          });
        }
      }
    }
    return editor.registerMutationListener(
      mentionNode.MentionNode,
      (mutations, payload) => {
        if (payload.updateTags.has("collaboration") || payload.updateTags.has("history-merge")) {
          return;
        }
        $handleMutation(mutations, payload);
      }
    );
  }, [editor, room]);
  React.useEffect(() => {
    function $onStateRead() {
      const text = $getAnchorNodeTextContent();
      if (text === null) {
        setMatch(null);
        return;
      }
      const match2 = MentionRegex.exec(text);
      setMatch(match2);
    }
    return editor.registerUpdateListener(({ editorState: state }) => {
      state.read($onStateRead);
    });
  }, [editor]);
  React.useEffect(() => {
    function $handleBackspace(event) {
      const selection = lexical.$getSelection();
      if (selection === null)
        return false;
      if (lexical.$isNodeSelection(selection)) {
        const nodes = selection.getNodes();
        if (nodes.length !== 1)
          return false;
        const node = nodes[0];
        if (!mentionNode.$isMentionNode(node))
          return false;
        const text = lexical.$createTextNode("@");
        node.replace(text);
        const newSelection = lexical.$createRangeSelection();
        newSelection.setTextNodeRange(text, 1, text, 1);
        lexical.$setSelection(newSelection);
        event.preventDefault();
        return true;
      } else if (lexical.$isRangeSelection(selection)) {
        if (!selection.isCollapsed())
          return false;
        const anchor = selection.anchor.getNode();
        const prevSibling = anchor.getPreviousSibling();
        if (selection.anchor.offset === 0 && mentionNode.$isMentionNode(prevSibling)) {
          const text = lexical.$createTextNode("@");
          prevSibling.replace(text);
          const newSelection = lexical.$createRangeSelection();
          newSelection.setTextNodeRange(text, 1, text, 1);
          lexical.$setSelection(newSelection);
          event.preventDefault();
          return true;
        } else if (lexical.$isElementNode(anchor)) {
          const child = anchor.getChildAtIndex(selection.anchor.offset - 1);
          if (!mentionNode.$isMentionNode(child))
            return false;
          const text = lexical.$createTextNode("@");
          child.replace(text);
          const newSelection = lexical.$createRangeSelection();
          newSelection.setTextNodeRange(text, 1, text, 1);
          lexical.$setSelection(newSelection);
          event.preventDefault();
          return true;
        }
        return false;
      }
      return false;
    }
    return editor.registerCommand(
      lexical.KEY_BACKSPACE_COMMAND,
      $handleBackspace,
      lexical.COMMAND_PRIORITY_LOW
    );
  }, [editor]);
  const handleValueSelect = React.useCallback(
    (userId) => {
      function $onValueSelect() {
        if (match === null)
          return;
        setMatch(null);
        const selection = lexical.$getSelection();
        if (!lexical.$isRangeSelection(selection))
          return;
        if (!selection.isCollapsed())
          return;
        const anchor = selection.anchor;
        if (anchor.type !== "text")
          return;
        const anchorNode = anchor.getNode();
        if (!anchorNode.isSimpleText())
          return;
        const selectionOffset = anchor.offset;
        const text = anchorNode.getTextContent().slice(0, selectionOffset);
        const characterOffset = match[2].length;
        const queryOffset = getFullMatchOffset(text, match[2], characterOffset);
        const startOffset = selectionOffset - queryOffset;
        if (startOffset < 0)
          return;
        const mentionNode$1 = mentionNode.$createMentionNode(userId);
        if (startOffset === 0) {
          const [node] = anchorNode.splitText(selectionOffset);
          node.replace(mentionNode$1);
        } else {
          const [, node] = anchorNode.splitText(startOffset, selectionOffset);
          node.replace(mentionNode$1);
        }
      }
      editor.update($onValueSelect);
    },
    [editor, match]
  );
  if (match === null || matchingString === void 0)
    return null;
  if (suggestions$1 === void 0 || suggestions$1.length === 0)
    return null;
  const range = editor.getEditorState().read(() => $getRangeAtMatch(match));
  if (range === null)
    return null;
  return reactDom.createPortal(
    /* @__PURE__ */ React.createElement(suggestions.SuggestionsContext.Provider, {
      value: suggestions$1
    }, /* @__PURE__ */ React.createElement(suggestions.OnValueSelectCallbackContext.Provider, {
      value: handleValueSelect
    }, /* @__PURE__ */ React.createElement(suggestions.OnResetMatchCallbackContext.Provider, {
      value: () => setMatch(null)
    }, /* @__PURE__ */ React.createElement(SuggestionsPortal, {
      range,
      container: document.body,
      key: matchingString
    }, /* @__PURE__ */ React.createElement(suggestions.List, {
      className: "lb-lexical-suggestions-list lb-lexical-mention-suggestions-list"
    }, suggestions$1.map((userId) => /* @__PURE__ */ React.createElement(suggestions.Item, {
      key: userId,
      value: userId,
      className: "lb-lexical-suggestions-list-item lb-lexical-mention-suggestion"
    }, /* @__PURE__ */ React.createElement(avatar.Avatar, {
      userId,
      className: "lb-lexical-mention-suggestion-avatar"
    }), /* @__PURE__ */ React.createElement(user.User, {
      userId,
      className: "lb-lexical-mention-suggestion-user"
    })))))))),
    document.body
  );
}
const SUGGESTIONS_COLLISION_PADDING = 10;
function SuggestionsPortal({
  children,
  range,
  container
}) {
  const {
    refs: { setReference, setFloating },
    strategy,
    x,
    y
  } = reactDom$1.useFloating({
    strategy: "fixed",
    placement: "top-start",
    middleware: [
      reactDom$1.flip({ padding: SUGGESTIONS_COLLISION_PADDING, crossAxis: false }),
      reactDom$1.offset(10),
      reactDom$1.hide({ padding: SUGGESTIONS_COLLISION_PADDING }),
      reactDom$1.shift({ padding: SUGGESTIONS_COLLISION_PADDING, limiter: reactDom$1.limitShift() }),
      reactDom$1.size({ padding: SUGGESTIONS_COLLISION_PADDING })
    ],
    whileElementsMounted: (...args) => {
      return reactDom$1.autoUpdate(...args, {
        animationFrame: true
      });
    }
  });
  React.useLayoutEffect(() => {
    setReference({
      getBoundingClientRect: () => range.getBoundingClientRect()
    });
  }, [setReference, range]);
  return reactDom.createPortal(
    /* @__PURE__ */ React.createElement("div", {
      ref: setFloating,
      style: {
        position: strategy,
        top: 0,
        left: 0,
        transform: `translate3d(${Math.round(x)}px, ${Math.round(y)}px, 0)`,
        minWidth: "max-content"
      },
      className: "lb-root lb-portal lb-elevation lb-lexical-suggestions lb-lexical-mention-suggestions"
    }, children),
    container
  );
}

exports.MentionPlugin = MentionPlugin;
exports.SUGGESTIONS_COLLISION_PADDING = SUGGESTIONS_COLLISION_PADDING;
//# sourceMappingURL=mention-plugin.js.map
