'use strict';

var reactDom = require('@floating-ui/react-dom');
var LexicalCollaborationPlugin = require('@lexical/react/LexicalCollaborationPlugin');
var LexicalComposerContext = require('@lexical/react/LexicalComposerContext');
var core = require('@liveblocks/core');
var react = require('@liveblocks/react');
var yjs$1 = require('@liveblocks/yjs');
var React = require('react');
var index_js = require('use-sync-external-store/shim/index.js');
var yjs = require('yjs');
var commentPluginProvider = require('./comments/comment-plugin-provider.js');
var threadMarkNode = require('./comments/thread-mark-node.js');
var mentionNode = require('./mentions/mention-node.js');
var mentionPlugin = require('./mentions/mention-plugin.js');

const providersMap = /* @__PURE__ */ new Map();
function useProvider() {
  const room = react.useRoom();
  const subscribe = React.useCallback(
    (onStoreChange) => {
      return room[core.kInternal].onProviderUpdate.subscribe(onStoreChange);
    },
    [room]
  );
  const getSnapshot = React.useCallback(() => {
    return room[core.kInternal].getProvider();
  }, [room]);
  return index_js.useSyncExternalStore(subscribe, getSnapshot, getSnapshot);
}
function useEditorStatus() {
  const provider = useProvider();
  const subscribe = React.useCallback(
    (onStoreChange) => {
      if (provider === void 0)
        return () => {
        };
      provider.on("status", onStoreChange);
      return () => {
        provider.off("status", onStoreChange);
      };
    },
    [provider]
  );
  const getSnapshot = React.useCallback(() => {
    if (provider === void 0) {
      return "not-loaded";
    }
    return provider.getStatus();
  }, [provider]);
  return index_js.useSyncExternalStore(subscribe, getSnapshot, getSnapshot);
}
const LiveblocksPlugin = ({
  children
}) => {
  const client = react.useClient();
  const hasResolveMentionSuggestions = client[core.kInternal].resolveMentionSuggestions !== void 0;
  const [editor] = LexicalComposerContext.useLexicalComposerContext();
  const room = react.useRoom();
  const previousRoomIdRef = React.useRef(null);
  if (!editor.hasNodes([threadMarkNode.ThreadMarkNode, mentionNode.MentionNode])) {
    throw new Error(
      "LiveblocksPlugin requires Lexical configuration to be wrapped in the `liveblocksConfig(options)` function. For more information: https://liveblocks.io/docs/api-reference/liveblocks-react-lexical#liveblocksConfig"
    );
  }
  const [containerRef, setContainerRef] = React.useState(void 0);
  const {
    refs: { setReference, setFloating },
    strategy,
    x,
    y
  } = reactDom.useFloating({
    strategy: "fixed",
    placement: "bottom",
    whileElementsMounted: (...args) => {
      return reactDom.autoUpdate(...args, {
        animationFrame: true
      });
    }
  });
  React.useEffect(() => {
    if (process.env.NODE_ENV !== "production") {
      if (!editor.getEditorState().isEmpty()) {
        console.warn(
          "Warning: LiveblocksPlugin: editorState in initialConfig detected, but must be null."
        );
      }
    }
  }, []);
  React.useEffect(() => {
    room[core.kInternal].reportTextEditor("lexical", "root");
  }, [room]);
  const self = react.useSelf();
  const providerFactory = React.useCallback(
    (id, yjsDocMap) => {
      if (previousRoomIdRef.current !== null && previousRoomIdRef.current !== id) {
        const previousProvider = providersMap.get(id);
        if (previousProvider !== void 0) {
          previousProvider.destroy();
        }
      }
      let doc = yjsDocMap.get(id);
      if (doc === void 0) {
        doc = new yjs.Doc();
        const provider = new yjs$1.LiveblocksYjsProvider(room, doc);
        yjsDocMap.set(id, doc);
        providersMap.set(id, provider);
      }
      return core.nn(
        providersMap.get(id),
        "Internal error. Should never happen"
      );
    },
    [room]
  );
  const root = useRootElement();
  React.useLayoutEffect(() => {
    if (root === null)
      return;
    setReference({
      getBoundingClientRect: () => root.getBoundingClientRect()
    });
  }, [setReference, root]);
  const handleFloatingRef = React.useCallback(
    (node) => {
      setFloating(node);
      setContainerRef({ current: node });
    },
    [setFloating, setContainerRef]
  );
  return /* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement("div", {
    ref: handleFloatingRef,
    style: {
      position: strategy,
      top: 0,
      left: 0,
      transform: `translate3d(${Math.round(x)}px, ${Math.round(y)}px, 0)`,
      minWidth: "max-content"
    }
  }), self && /* @__PURE__ */ React.createElement(LexicalCollaborationPlugin.CollaborationPlugin, {
    key: room.id,
    id: room.id,
    providerFactory,
    username: self.info?.name ?? "",
    cursorColor: self.info?.color,
    cursorsContainerRef: containerRef,
    shouldBootstrap: true
  }), hasResolveMentionSuggestions && /* @__PURE__ */ React.createElement(mentionPlugin.MentionPlugin, null), /* @__PURE__ */ React.createElement(commentPluginProvider.CommentPluginProvider, null, children));
};
function useRootElement() {
  const [editor] = LexicalComposerContext.useLexicalComposerContext();
  const subscribe = React.useCallback(
    (onStoreChange) => {
      return editor.registerRootListener(onStoreChange);
    },
    [editor]
  );
  const getSnapshot = React.useCallback(() => {
    return editor.getRootElement();
  }, [editor]);
  return index_js.useSyncExternalStore(subscribe, getSnapshot, getSnapshot);
}

exports.LiveblocksPlugin = LiveblocksPlugin;
exports.useEditorStatus = useEditorStatus;
exports.useRootElement = useRootElement;
//# sourceMappingURL=liveblocks-plugin-provider.js.map
