import { useFloating, autoUpdate } from '@floating-ui/react-dom';
import { CollaborationPlugin } from '@lexical/react/LexicalCollaborationPlugin';
import { useLexicalComposerContext } from '@lexical/react/LexicalComposerContext';
import { kInternal, nn } from '@liveblocks/core';
import { useRoom, useClient, useSelf } from '@liveblocks/react';
import { LiveblocksYjsProvider } from '@liveblocks/yjs';
import React__default, { useCallback, useRef, useState, useEffect, useLayoutEffect } from 'react';
import { useSyncExternalStore } from 'use-sync-external-store/shim/index.js';
import { Doc } from 'yjs';
import { CommentPluginProvider } from './comments/comment-plugin-provider.mjs';
import { ThreadMarkNode } from './comments/thread-mark-node.mjs';
import { MentionNode } from './mentions/mention-node.mjs';
import { MentionPlugin } from './mentions/mention-plugin.mjs';

const providersMap = /* @__PURE__ */ new Map();
function useProvider() {
  const room = useRoom();
  const subscribe = useCallback(
    (onStoreChange) => {
      return room[kInternal].onProviderUpdate.subscribe(onStoreChange);
    },
    [room]
  );
  const getSnapshot = useCallback(() => {
    return room[kInternal].getProvider();
  }, [room]);
  return useSyncExternalStore(subscribe, getSnapshot, getSnapshot);
}
function useEditorStatus() {
  const provider = useProvider();
  const subscribe = useCallback(
    (onStoreChange) => {
      if (provider === void 0)
        return () => {
        };
      provider.on("status", onStoreChange);
      return () => {
        provider.off("status", onStoreChange);
      };
    },
    [provider]
  );
  const getSnapshot = useCallback(() => {
    if (provider === void 0) {
      return "not-loaded";
    }
    return provider.getStatus();
  }, [provider]);
  return useSyncExternalStore(subscribe, getSnapshot, getSnapshot);
}
const LiveblocksPlugin = ({
  children
}) => {
  const client = useClient();
  const hasResolveMentionSuggestions = client[kInternal].resolveMentionSuggestions !== void 0;
  const [editor] = useLexicalComposerContext();
  const room = useRoom();
  const previousRoomIdRef = useRef(null);
  if (!editor.hasNodes([ThreadMarkNode, MentionNode])) {
    throw new Error(
      "LiveblocksPlugin requires Lexical configuration to be wrapped in the `liveblocksConfig(options)` function. For more information: https://liveblocks.io/docs/api-reference/liveblocks-react-lexical#liveblocksConfig"
    );
  }
  const [containerRef, setContainerRef] = useState(void 0);
  const {
    refs: { setReference, setFloating },
    strategy,
    x,
    y
  } = useFloating({
    strategy: "fixed",
    placement: "bottom",
    whileElementsMounted: (...args) => {
      return autoUpdate(...args, {
        animationFrame: true
      });
    }
  });
  useEffect(() => {
    if (process.env.NODE_ENV !== "production") {
      if (!editor.getEditorState().isEmpty()) {
        console.warn(
          "Warning: LiveblocksPlugin: editorState in initialConfig detected, but must be null."
        );
      }
    }
  }, []);
  useEffect(() => {
    room[kInternal].reportTextEditor("lexical", "root");
  }, [room]);
  const self = useSelf();
  const providerFactory = useCallback(
    (id, yjsDocMap) => {
      if (previousRoomIdRef.current !== null && previousRoomIdRef.current !== id) {
        const previousProvider = providersMap.get(id);
        if (previousProvider !== void 0) {
          previousProvider.destroy();
        }
      }
      let doc = yjsDocMap.get(id);
      if (doc === void 0) {
        doc = new Doc();
        const provider = new LiveblocksYjsProvider(room, doc);
        yjsDocMap.set(id, doc);
        providersMap.set(id, provider);
      }
      return nn(
        providersMap.get(id),
        "Internal error. Should never happen"
      );
    },
    [room]
  );
  const root = useRootElement();
  useLayoutEffect(() => {
    if (root === null)
      return;
    setReference({
      getBoundingClientRect: () => root.getBoundingClientRect()
    });
  }, [setReference, root]);
  const handleFloatingRef = useCallback(
    (node) => {
      setFloating(node);
      setContainerRef({ current: node });
    },
    [setFloating, setContainerRef]
  );
  return /* @__PURE__ */ React__default.createElement(React__default.Fragment, null, /* @__PURE__ */ React__default.createElement("div", {
    ref: handleFloatingRef,
    style: {
      position: strategy,
      top: 0,
      left: 0,
      transform: `translate3d(${Math.round(x)}px, ${Math.round(y)}px, 0)`,
      minWidth: "max-content"
    }
  }), self && /* @__PURE__ */ React__default.createElement(CollaborationPlugin, {
    key: room.id,
    id: room.id,
    providerFactory,
    username: self.info?.name ?? "",
    cursorColor: self.info?.color,
    cursorsContainerRef: containerRef,
    shouldBootstrap: true
  }), hasResolveMentionSuggestions && /* @__PURE__ */ React__default.createElement(MentionPlugin, null), /* @__PURE__ */ React__default.createElement(CommentPluginProvider, null, children));
};
function useRootElement() {
  const [editor] = useLexicalComposerContext();
  const subscribe = useCallback(
    (onStoreChange) => {
      return editor.registerRootListener(onStoreChange);
    },
    [editor]
  );
  const getSnapshot = useCallback(() => {
    return editor.getRootElement();
  }, [editor]);
  return useSyncExternalStore(subscribe, getSnapshot, getSnapshot);
}

export { LiveblocksPlugin, useEditorStatus, useRootElement };
//# sourceMappingURL=liveblocks-plugin-provider.mjs.map
