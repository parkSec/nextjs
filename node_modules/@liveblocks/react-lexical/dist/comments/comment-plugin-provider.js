'use strict';

var LexicalComposerContext = require('@lexical/react/LexicalComposerContext');
var utils = require('@lexical/utils');
var core = require('@liveblocks/core');
var react = require('@liveblocks/react');
var lexical = require('lexical');
var React = require('react');
var withSelector_js = require('use-sync-external-store/shim/with-selector.js');
var getThreadMarkIds = require('./get-thread-mark-ids.js');
var threadMarkNode = require('./thread-mark-node.js');
var unwrapThreadMarkNode = require('./unwrap-thread-mark-node.js');

function _interopNamespaceDefault(e) {
  var n = Object.create(null);
  if (e) {
    Object.keys(e).forEach(function (k) {
      if (k !== 'default') {
        var d = Object.getOwnPropertyDescriptor(e, k);
        Object.defineProperty(n, k, d.get ? d : {
          enumerable: true,
          get: function () { return e[k]; }
        });
      }
    });
  }
  n.default = e;
  return Object.freeze(n);
}

var React__namespace = /*#__PURE__*/_interopNamespaceDefault(React);

const OnDeleteThreadCallback = React.createContext(null);
const ActiveThreadsContext = React.createContext(null);
const IsActiveThreadContext = React.createContext(null);
const ThreadToNodesContext = React.createContext(
  null
);
function CommentPluginProvider({ children }) {
  const [editor, context] = LexicalComposerContext.useLexicalComposerContext();
  const [threadToNodes, setThreadToNodes] = React.useState(
    /* @__PURE__ */ new Map()
  );
  const [activeThreads, setActiveThreads] = React.useState([]);
  const client = react.useClient();
  const room = react.useRoom();
  const isThreadActive = React.useCallback(
    (threadId) => {
      return activeThreads.includes(threadId);
    },
    [activeThreads]
  );
  const handleThreadDelete = React.useCallback(
    (threadId) => {
      editor.update(() => {
        const keys = threadToNodes.get(threadId);
        if (keys === void 0)
          return;
        for (const key of keys) {
          const node = lexical.$getNodeByKey(key);
          if (!threadMarkNode.$isThreadMarkNode(node))
            continue;
          node.deleteID(threadId);
          if (node.getIDs().length === 0) {
            unwrapThreadMarkNode(node);
          }
        }
      });
    },
    [editor, threadToNodes]
  );
  react.useCommentsErrorListener((error) => {
    if (error instanceof react.CreateThreadError) {
      handleThreadDelete(error.context.threadId);
    }
  });
  const store = react.getUmbrellaStoreForClient(client);
  const roomId = room.id;
  const threads = withSelector_js.useSyncExternalStoreWithSelector(
    store.subscribeThreads,
    store.getThreads,
    store.getThreads,
    React.useCallback(
      () => react.selectThreads(store.getThreads(), {
        roomId,
        orderBy: "age",
        query: {
          resolved: false
        }
      }).map((thread) => thread.id),
      [roomId, store]
    ),
    core.shallow
  );
  React.useEffect(() => {
    function getThreadMarkElements() {
      const activeElements = /* @__PURE__ */ new Set();
      for (const id of threads) {
        const keys = threadToNodes.get(id);
        if (keys === void 0)
          continue;
        for (const key of keys) {
          const element = editor.getElementByKey(key);
          if (element === null)
            continue;
          activeElements.add(element);
        }
      }
      return activeElements;
    }
    const elements = getThreadMarkElements();
    const theme = context.getTheme();
    const classNames = ["lb-root", "lb-lexical-thread-mark"];
    if (theme && theme.liveblocks && "threadMark" in theme.liveblocks) {
      classNames.push(theme.liveblocks.threadMark);
    }
    elements.forEach((element) => {
      utils.addClassNamesToElement(element, ...classNames);
    });
    return () => {
      elements.forEach((element) => {
        utils.removeClassNamesFromElement(element, ...classNames);
      });
    };
  }, [context, editor, threadToNodes, threads]);
  React.useEffect(() => {
    function onMutation(mutations) {
      const state = editor.getEditorState();
      setThreadToNodes((prev) => {
        const updatedMap = new Map(prev);
        state.read(() => {
          for (const [key, mutation] of mutations) {
            if (mutation === "destroyed") {
              for (const [, nodes] of updatedMap) {
                nodes.delete(key);
              }
            } else if (mutation === "created" || mutation === "updated") {
              const node = lexical.$getNodeByKey(key);
              if (!threadMarkNode.$isThreadMarkNode(node))
                continue;
              const threadIds = node.getIDs();
              for (const id of threadIds) {
                const keys = updatedMap.get(id) ?? /* @__PURE__ */ new Set();
                keys.add(key);
                updatedMap.set(id, keys);
              }
            }
          }
        });
        return updatedMap;
      });
    }
    return editor.registerMutationListener(threadMarkNode.ThreadMarkNode, onMutation);
  }, [editor]);
  React.useEffect(() => {
    function $getThreadIds(selection) {
      if (selection === null)
        return [];
      if (!lexical.$isRangeSelection(selection))
        return [];
      const anchor = selection.anchor.getNode();
      if (!lexical.$isTextNode(anchor))
        return [];
      return getThreadMarkIds(anchor, selection.anchor.offset) ?? [];
    }
    function $onStateRead() {
      const selection = lexical.$getSelection();
      const threadIds = $getThreadIds(selection).filter((id) => {
        return react.selectThreads(store.getThreads(), {
          roomId,
          orderBy: "age",
          query: {
            resolved: false
          }
        }).some((thread) => thread.id === id);
      });
      setActiveThreads(threadIds);
    }
    const unsubscribeCache = store.subscribeThreads(() => {
      editor.getEditorState().read($onStateRead);
    });
    const unregisterUpdateListener = editor.registerUpdateListener(
      ({ editorState: state }) => {
        state.read($onStateRead);
      }
    );
    return () => {
      unregisterUpdateListener();
      unsubscribeCache();
    };
  }, [editor, client, roomId, store]);
  React.useEffect(() => {
    function getActiveElements() {
      const activeElements2 = /* @__PURE__ */ new Set();
      for (const thread of activeThreads) {
        const keys = threadToNodes.get(thread);
        if (keys === void 0)
          continue;
        for (const key of keys) {
          const element = editor.getElementByKey(key);
          if (element === null)
            continue;
          activeElements2.add(element);
        }
      }
      return activeElements2;
    }
    const activeElements = getActiveElements();
    activeElements.forEach((element) => {
      element.setAttribute("data-state", "active");
    });
    return () => {
      activeElements.forEach((element) => {
        element.removeAttribute("data-state");
      });
    };
  }, [activeThreads, editor, threadToNodes]);
  React.useEffect(() => {
    return utils.registerNestedElementResolver(
      editor,
      threadMarkNode.ThreadMarkNode,
      (from) => {
        return threadMarkNode.$createThreadMarkNode(from.getIDs());
      },
      (from, to) => {
        const ids = from.getIDs();
        ids.forEach((id) => {
          to.addID(id);
        });
      }
    );
  }, [editor]);
  return /* @__PURE__ */ React__namespace.createElement(OnDeleteThreadCallback.Provider, {
    value: handleThreadDelete
  }, /* @__PURE__ */ React__namespace.createElement(ActiveThreadsContext.Provider, {
    value: activeThreads
  }, /* @__PURE__ */ React__namespace.createElement(IsActiveThreadContext.Provider, {
    value: isThreadActive
  }, /* @__PURE__ */ React__namespace.createElement(ThreadToNodesContext.Provider, {
    value: threadToNodes
  }, children))));
}
function useIsThreadActive(threadId) {
  const isActive = React__namespace.useContext(IsActiveThreadContext);
  if (isActive === null) {
    throw new Error(
      "useIsThreadActive must be used within LiveblocksPlugin. For more information: https://liveblocks.io/docs/api-reference/liveblocks-react-lexical#useIsThreadActive"
    );
  }
  return isActive(threadId);
}

exports.ActiveThreadsContext = ActiveThreadsContext;
exports.CommentPluginProvider = CommentPluginProvider;
exports.IsActiveThreadContext = IsActiveThreadContext;
exports.OnDeleteThreadCallback = OnDeleteThreadCallback;
exports.ThreadToNodesContext = ThreadToNodesContext;
exports.useIsThreadActive = useIsThreadActive;
//# sourceMappingURL=comment-plugin-provider.js.map
