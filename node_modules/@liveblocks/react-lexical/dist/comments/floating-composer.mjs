import { useFloating, offset, autoUpdate, flip, hide, shift, limitShift, size } from '@floating-ui/react-dom';
import { useLexicalComposerContext } from '@lexical/react/LexicalComposerContext';
import { useCreateThread } from '@liveblocks/react';
import { Composer } from '@liveblocks/react-ui';
import { createCommand, $getSelection, $isRangeSelection, COMMAND_PRIORITY_EDITOR, $setSelection } from 'lexical';
import React__default, { forwardRef, useState, useEffect, useCallback, useLayoutEffect } from 'react';
import { createPortal } from 'react-dom';
import { createDOMRange } from '../create-dom-range.mjs';
import { createRectsFromDOMRange } from '../create-rects-from-dom-range.mjs';
import $wrapSelectionInThreadMarkNode from './wrap-selection-in-thread-mark-node.mjs';

const OPEN_FLOATING_COMPOSER_COMMAND = createCommand("OPEN_FLOATING_COMPOSER_COMMAND");
const FloatingComposer = forwardRef(function FloatingComposer2(props, forwardedRef) {
  const [range, setRange] = useState(null);
  const [editor] = useLexicalComposerContext();
  useEffect(() => {
    return editor.registerCommand(
      OPEN_FLOATING_COMPOSER_COMMAND,
      () => {
        const selection = $getSelection();
        if (!$isRangeSelection(selection))
          return false;
        if (selection.isCollapsed())
          return false;
        const { anchor, focus } = selection;
        const range2 = createDOMRange(
          editor,
          anchor.getNode(),
          anchor.offset,
          focus.getNode(),
          focus.offset
        );
        setRange(range2);
        return true;
      },
      COMMAND_PRIORITY_EDITOR
    );
  }, [editor]);
  if (range === null)
    return null;
  return /* @__PURE__ */ React__default.createElement(FloatingComposerImpl, {
    ref: forwardedRef,
    ...props,
    range,
    onRangeChange: setRange
  });
});
const FloatingComposerImpl = forwardRef(function FloatingComposer3(props, forwardedRef) {
  const {
    range,
    onRangeChange,
    onKeyDown,
    onComposerSubmit,
    ...composerProps
  } = props;
  const [editor] = useLexicalComposerContext();
  const createThread = useCreateThread();
  const $onStateRead = useCallback(() => {
    const selection = $getSelection();
    if (!$isRangeSelection(selection) || selection.isCollapsed()) {
      return null;
    }
    const { anchor, focus } = selection;
    const range2 = createDOMRange(
      editor,
      anchor.getNode(),
      anchor.offset,
      focus.getNode(),
      focus.offset
    );
    return range2;
  }, [editor]);
  useEffect(() => {
    return editor.registerUpdateListener(({ editorState: state, tags }) => {
      if (!tags.has("collaboration")) {
        onRangeChange(null);
        return;
      }
      const range2 = state.read(() => $onStateRead());
      onRangeChange(range2);
    });
  }, [editor, range, onRangeChange, $onStateRead]);
  const onThreadCreate = useCallback(
    (threadId) => {
      editor.update(() => {
        const selection = $getSelection();
        if (!$isRangeSelection(selection))
          return;
        if (selection.isCollapsed())
          return;
        const isBackward = selection.isBackward();
        $wrapSelectionInThreadMarkNode(selection, isBackward, threadId);
        $setSelection(null);
      });
    },
    [editor]
  );
  const handleComposerSubmit = useCallback(
    (comment, event) => {
      onComposerSubmit?.(comment, event);
      if (event.defaultPrevented)
        return;
      event.preventDefault();
      const thread = createThread({
        body: comment.body,
        metadata: props.metadata ?? {}
      });
      onThreadCreate(thread.id);
    },
    [onThreadCreate, onComposerSubmit, props.metadata, createThread]
  );
  function handleKeyDown(event) {
    if (event.key === "Escape") {
      onRangeChange(null);
      editor.focus();
    }
    onKeyDown?.(event);
  }
  return /* @__PURE__ */ React__default.createElement(React__default.Fragment, null, /* @__PURE__ */ React__default.createElement(ActiveSelectionPortal, {
    range,
    container: document.body
  }), /* @__PURE__ */ React__default.createElement(FloatingComposerPortal, {
    range,
    container: document.body
  }, /* @__PURE__ */ React__default.createElement(Composer, {
    autoFocus: true,
    ...composerProps,
    onKeyDown: handleKeyDown,
    onComposerSubmit: handleComposerSubmit,
    ref: forwardedRef
  })));
});
function ActiveSelectionPortal({
  range,
  container
}) {
  const {
    refs: { setReference, setFloating },
    strategy,
    x,
    y
  } = useFloating({
    strategy: "fixed",
    placement: "bottom",
    middleware: [offset(-range.getBoundingClientRect().height)],
    whileElementsMounted: (...args) => {
      return autoUpdate(...args, {
        animationFrame: true
      });
    }
  });
  useLayoutEffect(() => {
    setReference({
      getBoundingClientRect: () => range.getBoundingClientRect()
    });
  }, [setReference, range]);
  const [editor] = useLexicalComposerContext();
  const rects = createRectsFromDOMRange(editor, range);
  return createPortal(
    /* @__PURE__ */ React__default.createElement(React__default.Fragment, null, /* @__PURE__ */ React__default.createElement("span", {
      ref: setFloating,
      style: {
        position: strategy,
        top: 0,
        left: 0,
        transform: `translate3d(${Math.round(x)}px, ${Math.round(y)}px, 0)`,
        minWidth: "max-content",
        width: range.getBoundingClientRect().width,
        height: range.getBoundingClientRect().height,
        pointerEvents: "none"
      },
      className: "lb-root lb-portal"
    }, rects.map((rect) => /* @__PURE__ */ React__default.createElement("span", {
      key: JSON.stringify(rect),
      style: {
        position: "absolute",
        top: rect.top - range.getBoundingClientRect().top,
        left: rect.left - range.getBoundingClientRect().left,
        width: rect.width,
        height: rect.height,
        backgroundColor: "var(--lb-selection, rgba(0, 0, 255, 0.2))",
        pointerEvents: "none"
      },
      className: "lb-lexical-active-selection"
    })))),
    container
  );
}
const FLOATING_COMPOSER_COLLISION_PADDING = 10;
function FloatingComposerPortal({
  container,
  range,
  children
}) {
  const {
    refs: { setReference, setFloating },
    strategy,
    x,
    y
  } = useFloating({
    strategy: "fixed",
    placement: "bottom",
    middleware: [
      flip({ padding: FLOATING_COMPOSER_COLLISION_PADDING, crossAxis: false }),
      offset(10),
      hide({ padding: FLOATING_COMPOSER_COLLISION_PADDING }),
      shift({
        padding: FLOATING_COMPOSER_COLLISION_PADDING,
        limiter: limitShift()
      }),
      size({ padding: FLOATING_COMPOSER_COLLISION_PADDING })
    ],
    whileElementsMounted: (...args) => {
      return autoUpdate(...args, {
        animationFrame: true
      });
    }
  });
  useLayoutEffect(() => {
    setReference({
      getBoundingClientRect: () => range.getBoundingClientRect()
    });
  }, [range, setReference]);
  return createPortal(
    /* @__PURE__ */ React__default.createElement("div", {
      ref: setFloating,
      style: {
        position: strategy,
        top: 0,
        left: 0,
        transform: `translate3d(${Math.round(x)}px, ${Math.round(y)}px, 0)`,
        minWidth: "max-content"
      },
      className: "lb-root lb-portal lb-elevation lb-lexical-floating lb-lexical-floating-composer"
    }, children),
    container
  );
}

export { FLOATING_COMPOSER_COLLISION_PADDING, FloatingComposer, OPEN_FLOATING_COMPOSER_COMMAND };
//# sourceMappingURL=floating-composer.mjs.map
