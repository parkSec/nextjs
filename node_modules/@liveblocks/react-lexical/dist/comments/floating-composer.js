'use strict';

var reactDom = require('@floating-ui/react-dom');
var LexicalComposerContext = require('@lexical/react/LexicalComposerContext');
var react = require('@liveblocks/react');
var reactUi = require('@liveblocks/react-ui');
var lexical = require('lexical');
var React = require('react');
var reactDom$1 = require('react-dom');
var createDomRange = require('../create-dom-range.js');
var createRectsFromDomRange = require('../create-rects-from-dom-range.js');
var wrapSelectionInThreadMarkNode = require('./wrap-selection-in-thread-mark-node.js');

const OPEN_FLOATING_COMPOSER_COMMAND = lexical.createCommand("OPEN_FLOATING_COMPOSER_COMMAND");
const FloatingComposer = React.forwardRef(function FloatingComposer2(props, forwardedRef) {
  const [range, setRange] = React.useState(null);
  const [editor] = LexicalComposerContext.useLexicalComposerContext();
  React.useEffect(() => {
    return editor.registerCommand(
      OPEN_FLOATING_COMPOSER_COMMAND,
      () => {
        const selection = lexical.$getSelection();
        if (!lexical.$isRangeSelection(selection))
          return false;
        if (selection.isCollapsed())
          return false;
        const { anchor, focus } = selection;
        const range2 = createDomRange.createDOMRange(
          editor,
          anchor.getNode(),
          anchor.offset,
          focus.getNode(),
          focus.offset
        );
        setRange(range2);
        return true;
      },
      lexical.COMMAND_PRIORITY_EDITOR
    );
  }, [editor]);
  if (range === null)
    return null;
  return /* @__PURE__ */ React.createElement(FloatingComposerImpl, {
    ref: forwardedRef,
    ...props,
    range,
    onRangeChange: setRange
  });
});
const FloatingComposerImpl = React.forwardRef(function FloatingComposer3(props, forwardedRef) {
  const {
    range,
    onRangeChange,
    onKeyDown,
    onComposerSubmit,
    ...composerProps
  } = props;
  const [editor] = LexicalComposerContext.useLexicalComposerContext();
  const createThread = react.useCreateThread();
  const $onStateRead = React.useCallback(() => {
    const selection = lexical.$getSelection();
    if (!lexical.$isRangeSelection(selection) || selection.isCollapsed()) {
      return null;
    }
    const { anchor, focus } = selection;
    const range2 = createDomRange.createDOMRange(
      editor,
      anchor.getNode(),
      anchor.offset,
      focus.getNode(),
      focus.offset
    );
    return range2;
  }, [editor]);
  React.useEffect(() => {
    return editor.registerUpdateListener(({ editorState: state, tags }) => {
      if (!tags.has("collaboration")) {
        onRangeChange(null);
        return;
      }
      const range2 = state.read(() => $onStateRead());
      onRangeChange(range2);
    });
  }, [editor, range, onRangeChange, $onStateRead]);
  const onThreadCreate = React.useCallback(
    (threadId) => {
      editor.update(() => {
        const selection = lexical.$getSelection();
        if (!lexical.$isRangeSelection(selection))
          return;
        if (selection.isCollapsed())
          return;
        const isBackward = selection.isBackward();
        wrapSelectionInThreadMarkNode(selection, isBackward, threadId);
        lexical.$setSelection(null);
      });
    },
    [editor]
  );
  const handleComposerSubmit = React.useCallback(
    (comment, event) => {
      onComposerSubmit?.(comment, event);
      if (event.defaultPrevented)
        return;
      event.preventDefault();
      const thread = createThread({
        body: comment.body,
        metadata: props.metadata ?? {}
      });
      onThreadCreate(thread.id);
    },
    [onThreadCreate, onComposerSubmit, props.metadata, createThread]
  );
  function handleKeyDown(event) {
    if (event.key === "Escape") {
      onRangeChange(null);
      editor.focus();
    }
    onKeyDown?.(event);
  }
  return /* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement(ActiveSelectionPortal, {
    range,
    container: document.body
  }), /* @__PURE__ */ React.createElement(FloatingComposerPortal, {
    range,
    container: document.body
  }, /* @__PURE__ */ React.createElement(reactUi.Composer, {
    autoFocus: true,
    ...composerProps,
    onKeyDown: handleKeyDown,
    onComposerSubmit: handleComposerSubmit,
    ref: forwardedRef
  })));
});
function ActiveSelectionPortal({
  range,
  container
}) {
  const {
    refs: { setReference, setFloating },
    strategy,
    x,
    y
  } = reactDom.useFloating({
    strategy: "fixed",
    placement: "bottom",
    middleware: [reactDom.offset(-range.getBoundingClientRect().height)],
    whileElementsMounted: (...args) => {
      return reactDom.autoUpdate(...args, {
        animationFrame: true
      });
    }
  });
  React.useLayoutEffect(() => {
    setReference({
      getBoundingClientRect: () => range.getBoundingClientRect()
    });
  }, [setReference, range]);
  const [editor] = LexicalComposerContext.useLexicalComposerContext();
  const rects = createRectsFromDomRange.createRectsFromDOMRange(editor, range);
  return reactDom$1.createPortal(
    /* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement("span", {
      ref: setFloating,
      style: {
        position: strategy,
        top: 0,
        left: 0,
        transform: `translate3d(${Math.round(x)}px, ${Math.round(y)}px, 0)`,
        minWidth: "max-content",
        width: range.getBoundingClientRect().width,
        height: range.getBoundingClientRect().height,
        pointerEvents: "none"
      },
      className: "lb-root lb-portal"
    }, rects.map((rect) => /* @__PURE__ */ React.createElement("span", {
      key: JSON.stringify(rect),
      style: {
        position: "absolute",
        top: rect.top - range.getBoundingClientRect().top,
        left: rect.left - range.getBoundingClientRect().left,
        width: rect.width,
        height: rect.height,
        backgroundColor: "var(--lb-selection, rgba(0, 0, 255, 0.2))",
        pointerEvents: "none"
      },
      className: "lb-lexical-active-selection"
    })))),
    container
  );
}
const FLOATING_COMPOSER_COLLISION_PADDING = 10;
function FloatingComposerPortal({
  container,
  range,
  children
}) {
  const {
    refs: { setReference, setFloating },
    strategy,
    x,
    y
  } = reactDom.useFloating({
    strategy: "fixed",
    placement: "bottom",
    middleware: [
      reactDom.flip({ padding: FLOATING_COMPOSER_COLLISION_PADDING, crossAxis: false }),
      reactDom.offset(10),
      reactDom.hide({ padding: FLOATING_COMPOSER_COLLISION_PADDING }),
      reactDom.shift({
        padding: FLOATING_COMPOSER_COLLISION_PADDING,
        limiter: reactDom.limitShift()
      }),
      reactDom.size({ padding: FLOATING_COMPOSER_COLLISION_PADDING })
    ],
    whileElementsMounted: (...args) => {
      return reactDom.autoUpdate(...args, {
        animationFrame: true
      });
    }
  });
  React.useLayoutEffect(() => {
    setReference({
      getBoundingClientRect: () => range.getBoundingClientRect()
    });
  }, [range, setReference]);
  return reactDom$1.createPortal(
    /* @__PURE__ */ React.createElement("div", {
      ref: setFloating,
      style: {
        position: strategy,
        top: 0,
        left: 0,
        transform: `translate3d(${Math.round(x)}px, ${Math.round(y)}px, 0)`,
        minWidth: "max-content"
      },
      className: "lb-root lb-portal lb-elevation lb-lexical-floating lb-lexical-floating-composer"
    }, children),
    container
  );
}

exports.FLOATING_COMPOSER_COLLISION_PADDING = FLOATING_COMPOSER_COLLISION_PADDING;
exports.FloatingComposer = FloatingComposer;
exports.OPEN_FLOATING_COMPOSER_COMMAND = OPEN_FLOATING_COMPOSER_COMMAND;
//# sourceMappingURL=floating-composer.js.map
