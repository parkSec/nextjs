import { $isElementNode, $isTextNode } from 'lexical';
import { $isThreadMarkNode, $createThreadMarkNode } from './thread-mark-node.mjs';

function $wrapSelectionInThreadMarkNode(selection, isBackward, id, createNode) {
  const nodes = selection.getNodes();
  const anchorOffset = selection.anchor.offset;
  const focusOffset = selection.focus.offset;
  const nodesLength = nodes.length;
  const startOffset = isBackward ? focusOffset : anchorOffset;
  const endOffset = isBackward ? anchorOffset : focusOffset;
  let currentNodeParent;
  let lastCreatedMarkNode;
  for (let i = 0; i < nodesLength; i++) {
    const node = nodes[i];
    if ($isElementNode(lastCreatedMarkNode) && lastCreatedMarkNode.isParentOf(node)) {
      continue;
    }
    const isFirstNode = i === 0;
    const isLastNode = i === nodesLength - 1;
    let targetNode = null;
    if ($isTextNode(node)) {
      const textContentSize = node.getTextContentSize();
      const startTextOffset = isFirstNode ? startOffset : 0;
      const endTextOffset = isLastNode ? endOffset : textContentSize;
      if (startTextOffset === 0 && endTextOffset === 0) {
        continue;
      }
      const splitNodes = node.splitText(startTextOffset, endTextOffset);
      targetNode = splitNodes.length > 1 && (splitNodes.length === 3 || isFirstNode && !isLastNode || endTextOffset === textContentSize) ? splitNodes[1] : splitNodes[0];
    } else if ($isThreadMarkNode(node)) {
      continue;
    } else if ($isElementNode(node) && node.isInline()) {
      targetNode = node;
    }
    if (targetNode !== null) {
      if (targetNode && targetNode.is(currentNodeParent)) {
        continue;
      }
      const parentNode = targetNode.getParent();
      if (parentNode === null || !parentNode.is(currentNodeParent)) {
        lastCreatedMarkNode = void 0;
      }
      currentNodeParent = parentNode;
      if (lastCreatedMarkNode === void 0) {
        const createMarkNode = createNode || $createThreadMarkNode;
        lastCreatedMarkNode = createMarkNode([id]);
        targetNode.insertBefore(lastCreatedMarkNode);
      }
      lastCreatedMarkNode.append(targetNode);
    } else {
      currentNodeParent = void 0;
      lastCreatedMarkNode = void 0;
    }
  }
  if ($isElementNode(lastCreatedMarkNode)) {
    isBackward ? lastCreatedMarkNode.selectStart() : lastCreatedMarkNode.selectEnd();
  }
}

export { $wrapSelectionInThreadMarkNode as default };
//# sourceMappingURL=wrap-selection-in-thread-mark-node.mjs.map
