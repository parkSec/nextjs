import { useFloating, flip, offset, hide, shift, limitShift, size, autoUpdate } from '@floating-ui/react-dom';
import { useLexicalComposerContext } from '@lexical/react/LexicalComposerContext';
import { Thread } from '@liveblocks/react-ui';
import { KEY_ESCAPE_COMMAND, COMMAND_PRIORITY_HIGH, $getSelection } from 'lexical';
import React__default, { useState, useCallback, useEffect, useLayoutEffect, useContext } from 'react';
import { createPortal } from 'react-dom';
import { useSyncExternalStore } from 'use-sync-external-store/shim/index.js';
import { classNames } from '../classnames.mjs';
import { compareNodes } from './anchored-threads.mjs';
import { ThreadToNodesContext, ActiveThreadsContext } from './comment-plugin-provider.mjs';

function FloatingThreads({
  threads,
  components,
  ...props
}) {
  const activeThreads = useActiveThreads();
  const Thread$1 = components?.Thread ?? Thread;
  const [editor] = useLexicalComposerContext();
  const nodes = useThreadToNodes();
  const [range, setRange] = useState(null);
  const handleUpdateRange = useCallback(() => {
    function getActiveRange() {
      function getActiveElements() {
        const activeElements2 = /* @__PURE__ */ new Set();
        for (const thread of activeThreads) {
          const keys = nodes.get(thread);
          if (keys === void 0)
            continue;
          for (const key of keys) {
            const element = editor.getElementByKey(key);
            if (element === null)
              continue;
            activeElements2.add(element);
          }
        }
        return activeElements2;
      }
      const activeElements = getActiveElements();
      const sortedElements = Array.from(activeElements).sort(compareNodes);
      if (sortedElements.length === 0)
        return null;
      const range3 = document.createRange();
      range3.setStartBefore(sortedElements[0]);
      range3.setEndAfter(sortedElements[sortedElements.length - 1]);
      return range3;
    }
    const active = (threads ?? []).filter(
      (thread) => activeThreads.includes(thread.id)
    );
    const range2 = getActiveRange();
    if (range2 === null) {
      setRange(null);
      return;
    }
    setRange({ range: range2, threads: active });
  }, [activeThreads, nodes, editor, threads]);
  useEffect(() => {
    handleUpdateRange();
  }, [handleUpdateRange]);
  useEffect(() => {
    return editor.registerUpdateListener(handleUpdateRange);
  }, [editor, handleUpdateRange]);
  const handleEscapeKeydown = useCallback(() => {
    if (range === null)
      return false;
    setRange(null);
    return true;
  }, [range]);
  useEffect(() => {
    return editor.registerCommand(
      KEY_ESCAPE_COMMAND,
      handleEscapeKeydown,
      COMMAND_PRIORITY_HIGH
    );
  }, [editor, handleEscapeKeydown]);
  const isCollapsed = useIsSelectionCollapsed();
  if (range === null || isCollapsed === null || !isCollapsed)
    return null;
  return /* @__PURE__ */ React__default.createElement(FloatingThreadPortal, {
    range: range.range,
    container: document.body,
    ...props
  }, range.threads.map((thread) => /* @__PURE__ */ React__default.createElement(ThreadWrapper, {
    key: thread.id,
    thread,
    Thread: Thread$1,
    onEscapeKeydown: handleEscapeKeydown,
    className: "lb-lexical-floating-threads-thread"
  })));
}
const FLOATING_THREAD_COLLISION_PADDING = 10;
function FloatingThreadPortal({
  container,
  range,
  children,
  className,
  style,
  ...props
}) {
  const {
    refs: { setReference, setFloating },
    strategy,
    x,
    y
  } = useFloating({
    strategy: "absolute",
    placement: "bottom",
    middleware: [
      flip({ padding: FLOATING_THREAD_COLLISION_PADDING, crossAxis: false }),
      offset(10),
      hide({ padding: FLOATING_THREAD_COLLISION_PADDING }),
      shift({
        padding: FLOATING_THREAD_COLLISION_PADDING,
        limiter: limitShift()
      }),
      size({
        padding: FLOATING_THREAD_COLLISION_PADDING,
        apply({ availableWidth, availableHeight, elements }) {
          elements.floating.style.setProperty(
            "--lb-lexical-floating-threads-available-width",
            `${availableWidth}px`
          );
          elements.floating.style.setProperty(
            "--lb-lexical-floating-threads-available-height",
            `${availableHeight}px`
          );
        }
      })
    ],
    whileElementsMounted: (...args) => {
      return autoUpdate(...args, {
        animationFrame: true
      });
    }
  });
  useLayoutEffect(() => {
    setReference({
      getBoundingClientRect: () => range.getBoundingClientRect()
    });
  }, [setReference, range]);
  return createPortal(
    /* @__PURE__ */ React__default.createElement("div", {
      ref: setFloating,
      ...props,
      style: {
        ...style,
        position: strategy,
        top: 0,
        left: 0,
        transform: `translate3d(${Math.round(x)}px, ${Math.round(y)}px, 0)`,
        minWidth: "max-content"
      },
      className: classNames(
        "lb-root lb-portal lb-elevation lb-lexical-floating lb-lexical-floating-threads",
        className
      )
    }, children),
    container
  );
}
function ThreadWrapper({
  thread,
  Thread,
  onEscapeKeydown,
  onKeyDown,
  ...threadProps
}) {
  const handleKeyDown = useCallback(
    (event) => {
      onKeyDown?.(event);
      if (event.key === "Escape") {
        onEscapeKeydown();
      }
    },
    [onEscapeKeydown, onKeyDown]
  );
  return /* @__PURE__ */ React__default.createElement(Thread, {
    thread,
    onKeyDown: handleKeyDown,
    ...threadProps
  });
}
function useThreadToNodes() {
  const threadToNodes = useContext(ThreadToNodesContext);
  if (threadToNodes === null) {
    throw new Error(
      "FloatingThreads component must be used within a LiveblocksPlugin component."
    );
  }
  return threadToNodes;
}
function useIsSelectionCollapsed() {
  const [editor] = useLexicalComposerContext();
  const subscribe = useCallback(
    (onStoreChange) => {
      return editor.registerUpdateListener(onStoreChange);
    },
    [editor]
  );
  const getSnapshot = useCallback(() => {
    return editor.getEditorState().read(() => {
      const selection = $getSelection();
      if (selection === null)
        return null;
      return selection.isCollapsed();
    });
  }, [editor]);
  return useSyncExternalStore(subscribe, getSnapshot, getSnapshot);
}
function useActiveThreads() {
  const activeThreads = useContext(ActiveThreadsContext);
  if (activeThreads === null) {
    throw new Error(
      "FloatingThreads component must be used within LiveblocksPlugin."
    );
  }
  return activeThreads;
}

export { FLOATING_THREAD_COLLISION_PADDING, FloatingThreads };
//# sourceMappingURL=floating-threads.mjs.map
