import { useLexicalComposerContext } from '@lexical/react/LexicalComposerContext';
import { Thread } from '@liveblocks/react-ui';
import { $getNodeByKey } from 'lexical';
import React__default, { useRef, useCallback, useMemo, useState, useLayoutEffect, useEffect, useContext } from 'react';
import { classNames } from '../classnames.mjs';
import { useRootElement } from '../liveblocks-plugin-provider.mjs';
import { ThreadToNodesContext, ActiveThreadsContext } from './comment-plugin-provider.mjs';
import { $isThreadMarkNode } from './thread-mark-node.mjs';

const DEFAULT_GAP = 20;
const DEFAULT_ACTIVE_THREAD_OFFSET = -12;
const GAP = `var(--lb-lexical-anchored-threads-gap, ${DEFAULT_GAP}px)`;
const ACTIVE_THREAD_OFFSET = `var(--lb-lexical-anchored-threads-active-thread-offset, ${DEFAULT_ACTIVE_THREAD_OFFSET}px)`;
function compareNodes(a, b) {
  const position = a.compareDocumentPosition(b);
  if (position & Node.DOCUMENT_POSITION_FOLLOWING)
    return -1;
  if (position & Node.DOCUMENT_POSITION_PRECEDING)
    return 1;
  return 0;
}
function AnchoredThreads({
  threads,
  components,
  className,
  style,
  ...props
}) {
  const [editor] = useLexicalComposerContext();
  const Thread$1 = components?.Thread ?? Thread;
  const containerRef = useRef(null);
  const activeThreads = useActiveThreads();
  const nodes = useThreadToNodes();
  const getOrderedThreads = useCallback(() => {
    return threads.filter((thread) => thread.resolved === false).map((thread) => {
      const keys = nodes.get(thread.id);
      if (keys === void 0 || keys.size === 0)
        return null;
      const elements2 = Array.from(keys.values()).map((key) => editor.getElementByKey(key)).filter(Boolean);
      if (elements2.length === 0)
        return null;
      const element = elements2.sort(compareNodes)[0];
      return {
        thread,
        element
      };
    }).filter(
      (entry) => entry !== null
    ).sort((a, b) => {
      return compareNodes(a.element, b.element);
    });
  }, [editor, threads, nodes]);
  const orderedThreads = useMemo(getOrderedThreads, [getOrderedThreads]);
  const [elements, setElements] = useState(/* @__PURE__ */ new Map());
  const [positions, setPositions] = useState(/* @__PURE__ */ new Map());
  const onItemAdd = useCallback((id, el) => {
    setElements((prev) => new Map(prev).set(id, el));
  }, []);
  const onItemRemove = useCallback((id) => {
    setElements((prev) => {
      const items = new Map(prev);
      items.delete(id);
      return items;
    });
  }, []);
  const handlePositionThreads = useCallback(() => {
    const container = containerRef.current;
    if (container === null)
      return;
    const orderedThreads2 = getOrderedThreads();
    function getAscendingThreads() {
      if (activeThreads.length === 0)
        return orderedThreads2;
      const active = orderedThreads2.filter(
        ({ thread }) => activeThreads.includes(thread.id)
      );
      const after = orderedThreads2.filter(({ thread, element }) => {
        if (activeThreads.includes(thread.id))
          return false;
        const isAfter = active.some(({ element: activeElement }) => {
          return compareNodes(activeElement, element) === -1;
        });
        return isAfter;
      });
      return active.concat(after);
    }
    const ascending = getAscendingThreads();
    const descending = orderedThreads2.filter(
      (entry) => !ascending.includes(entry)
    );
    const newPositions = /* @__PURE__ */ new Map();
    for (const { thread, element } of ascending) {
      const rect = element.getBoundingClientRect();
      let top = rect.top - container.getBoundingClientRect().top;
      for (const [id, position] of newPositions) {
        const el = elements.get(id);
        if (el === void 0)
          continue;
        if (top >= position && top <= position + el.getBoundingClientRect().height) {
          top = position + el.getBoundingClientRect().height;
        }
      }
      newPositions.set(thread.id, top);
    }
    for (const { thread, element } of descending.reverse()) {
      const rect = element.getBoundingClientRect();
      const el = elements.get(thread.id);
      if (el === void 0)
        continue;
      let top = rect.top - container.getBoundingClientRect().top;
      for (const [, position] of newPositions) {
        if (top >= position - el.getBoundingClientRect().height) {
          top = position - el.getBoundingClientRect().height;
        }
      }
      newPositions.set(thread.id, top);
    }
    setPositions(newPositions);
  }, [getOrderedThreads, activeThreads, elements]);
  useLayoutEffect(() => {
    handlePositionThreads();
  }, [handlePositionThreads]);
  useEffect(() => {
    return editor.registerUpdateListener(() => {
      handlePositionThreads();
    });
  }, [editor, handlePositionThreads]);
  useEffect(() => {
    const observer = new ResizeObserver(handlePositionThreads);
    for (const element of elements.values()) {
      observer.observe(element);
    }
    return () => observer.disconnect();
  }, [elements, handlePositionThreads]);
  const root = useRootElement();
  useEffect(() => {
    if (root === null)
      return;
    const observer = new ResizeObserver(handlePositionThreads);
    observer.observe(root);
    return () => observer.disconnect();
  }, [root, handlePositionThreads]);
  if (orderedThreads.length === 0)
    return null;
  return /* @__PURE__ */ React__default.createElement("div", {
    ...props,
    className: classNames(className, "lb-root lb-lexical-anchored-threads"),
    ref: containerRef,
    style: {
      position: "relative",
      ...style
    }
  }, orderedThreads.map(({ thread, element }) => {
    const rect = element.getBoundingClientRect();
    const offset = root !== null ? root.getBoundingClientRect().top : 0;
    let top = rect.top - offset;
    if (positions.has(thread.id)) {
      top = positions.get(thread.id);
    }
    const isActive = activeThreads.includes(thread.id);
    return /* @__PURE__ */ React__default.createElement(ThreadWrapper, {
      key: thread.id,
      Thread: Thread$1,
      thread,
      onItemAdd,
      onItemRemove,
      style: {
        position: "absolute",
        transform: `translate3d(${isActive ? ACTIVE_THREAD_OFFSET : 0}, ${top}px, 0)`,
        insetInlineStart: 0,
        inlineSize: "100%",
        paddingBlockEnd: GAP
      }
    });
  }));
}
function ThreadWrapper({
  onItemAdd,
  onItemRemove,
  thread,
  Thread,
  className,
  ...props
}) {
  const [editor] = useLexicalComposerContext();
  const nodes = useThreadToNodes();
  const activeThreads = useActiveThreads();
  const isActive = activeThreads.includes(thread.id);
  function handleThreadClick() {
    const keys = nodes.get(thread.id);
    if (keys === void 0 || keys.size === 0)
      return;
    if (activeThreads.includes(thread.id))
      return;
    editor.update(() => {
      const [key] = keys;
      const node = $getNodeByKey(key);
      if (!$isThreadMarkNode(node))
        return;
      node.selectStart();
    });
  }
  const handleRef = useCallback(
    (el) => {
      onItemAdd(thread.id, el);
      return () => onItemRemove(thread.id);
    },
    [thread.id, onItemAdd, onItemRemove]
  );
  return /* @__PURE__ */ React__default.createElement("div", {
    ref: handleRef,
    className: classNames(
      "lb-lexical-anchored-threads-thread-container",
      className
    ),
    ...props
  }, /* @__PURE__ */ React__default.createElement(Thread, {
    thread,
    "data-state": isActive ? "active" : "inactive",
    onClick: handleThreadClick,
    className: "lb-lexical-anchored-threads-thread",
    showComposer: isActive ? true : false
  }));
}
function useThreadToNodes() {
  const threadToNodes = useContext(ThreadToNodesContext);
  if (threadToNodes === null) {
    throw new Error(
      "AnchoredThreads component must be used within a LiveblocksPlugin component."
    );
  }
  return threadToNodes;
}
function useActiveThreads() {
  const activeThreads = useContext(ActiveThreadsContext);
  if (activeThreads === null) {
    throw new Error(
      "AnchoredThreads component must be used within LiveblocksPlugin."
    );
  }
  return activeThreads;
}

export { AnchoredThreads, compareNodes };
//# sourceMappingURL=anchored-threads.mjs.map
