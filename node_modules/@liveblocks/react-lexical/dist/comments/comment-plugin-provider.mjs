import { useLexicalComposerContext } from '@lexical/react/LexicalComposerContext';
import { addClassNamesToElement, removeClassNamesFromElement, registerNestedElementResolver } from '@lexical/utils';
import { shallow } from '@liveblocks/core';
import { useClient, useRoom, useCommentsErrorListener, CreateThreadError, getUmbrellaStoreForClient, selectThreads } from '@liveblocks/react';
import { $getNodeByKey, $isRangeSelection, $isTextNode, $getSelection } from 'lexical';
import * as React from 'react';
import { createContext, useState, useCallback, useEffect } from 'react';
import { useSyncExternalStoreWithSelector } from 'use-sync-external-store/shim/with-selector.js';
import $getThreadMarkIds from './get-thread-mark-ids.mjs';
import { $isThreadMarkNode, ThreadMarkNode, $createThreadMarkNode } from './thread-mark-node.mjs';
import $unwrapThreadMarkNode from './unwrap-thread-mark-node.mjs';

const OnDeleteThreadCallback = createContext(null);
const ActiveThreadsContext = createContext(null);
const IsActiveThreadContext = createContext(null);
const ThreadToNodesContext = createContext(
  null
);
function CommentPluginProvider({ children }) {
  const [editor, context] = useLexicalComposerContext();
  const [threadToNodes, setThreadToNodes] = useState(
    /* @__PURE__ */ new Map()
  );
  const [activeThreads, setActiveThreads] = useState([]);
  const client = useClient();
  const room = useRoom();
  const isThreadActive = useCallback(
    (threadId) => {
      return activeThreads.includes(threadId);
    },
    [activeThreads]
  );
  const handleThreadDelete = useCallback(
    (threadId) => {
      editor.update(() => {
        const keys = threadToNodes.get(threadId);
        if (keys === void 0)
          return;
        for (const key of keys) {
          const node = $getNodeByKey(key);
          if (!$isThreadMarkNode(node))
            continue;
          node.deleteID(threadId);
          if (node.getIDs().length === 0) {
            $unwrapThreadMarkNode(node);
          }
        }
      });
    },
    [editor, threadToNodes]
  );
  useCommentsErrorListener((error) => {
    if (error instanceof CreateThreadError) {
      handleThreadDelete(error.context.threadId);
    }
  });
  const store = getUmbrellaStoreForClient(client);
  const roomId = room.id;
  const threads = useSyncExternalStoreWithSelector(
    store.subscribeThreads,
    store.getThreads,
    store.getThreads,
    useCallback(
      () => selectThreads(store.getThreads(), {
        roomId,
        orderBy: "age",
        query: {
          resolved: false
        }
      }).map((thread) => thread.id),
      [roomId, store]
    ),
    shallow
  );
  useEffect(() => {
    function getThreadMarkElements() {
      const activeElements = /* @__PURE__ */ new Set();
      for (const id of threads) {
        const keys = threadToNodes.get(id);
        if (keys === void 0)
          continue;
        for (const key of keys) {
          const element = editor.getElementByKey(key);
          if (element === null)
            continue;
          activeElements.add(element);
        }
      }
      return activeElements;
    }
    const elements = getThreadMarkElements();
    const theme = context.getTheme();
    const classNames = ["lb-root", "lb-lexical-thread-mark"];
    if (theme && theme.liveblocks && "threadMark" in theme.liveblocks) {
      classNames.push(theme.liveblocks.threadMark);
    }
    elements.forEach((element) => {
      addClassNamesToElement(element, ...classNames);
    });
    return () => {
      elements.forEach((element) => {
        removeClassNamesFromElement(element, ...classNames);
      });
    };
  }, [context, editor, threadToNodes, threads]);
  useEffect(() => {
    function onMutation(mutations) {
      const state = editor.getEditorState();
      setThreadToNodes((prev) => {
        const updatedMap = new Map(prev);
        state.read(() => {
          for (const [key, mutation] of mutations) {
            if (mutation === "destroyed") {
              for (const [, nodes] of updatedMap) {
                nodes.delete(key);
              }
            } else if (mutation === "created" || mutation === "updated") {
              const node = $getNodeByKey(key);
              if (!$isThreadMarkNode(node))
                continue;
              const threadIds = node.getIDs();
              for (const id of threadIds) {
                const keys = updatedMap.get(id) ?? /* @__PURE__ */ new Set();
                keys.add(key);
                updatedMap.set(id, keys);
              }
            }
          }
        });
        return updatedMap;
      });
    }
    return editor.registerMutationListener(ThreadMarkNode, onMutation);
  }, [editor]);
  useEffect(() => {
    function $getThreadIds(selection) {
      if (selection === null)
        return [];
      if (!$isRangeSelection(selection))
        return [];
      const anchor = selection.anchor.getNode();
      if (!$isTextNode(anchor))
        return [];
      return $getThreadMarkIds(anchor, selection.anchor.offset) ?? [];
    }
    function $onStateRead() {
      const selection = $getSelection();
      const threadIds = $getThreadIds(selection).filter((id) => {
        return selectThreads(store.getThreads(), {
          roomId,
          orderBy: "age",
          query: {
            resolved: false
          }
        }).some((thread) => thread.id === id);
      });
      setActiveThreads(threadIds);
    }
    const unsubscribeCache = store.subscribeThreads(() => {
      editor.getEditorState().read($onStateRead);
    });
    const unregisterUpdateListener = editor.registerUpdateListener(
      ({ editorState: state }) => {
        state.read($onStateRead);
      }
    );
    return () => {
      unregisterUpdateListener();
      unsubscribeCache();
    };
  }, [editor, client, roomId, store]);
  useEffect(() => {
    function getActiveElements() {
      const activeElements2 = /* @__PURE__ */ new Set();
      for (const thread of activeThreads) {
        const keys = threadToNodes.get(thread);
        if (keys === void 0)
          continue;
        for (const key of keys) {
          const element = editor.getElementByKey(key);
          if (element === null)
            continue;
          activeElements2.add(element);
        }
      }
      return activeElements2;
    }
    const activeElements = getActiveElements();
    activeElements.forEach((element) => {
      element.setAttribute("data-state", "active");
    });
    return () => {
      activeElements.forEach((element) => {
        element.removeAttribute("data-state");
      });
    };
  }, [activeThreads, editor, threadToNodes]);
  useEffect(() => {
    return registerNestedElementResolver(
      editor,
      ThreadMarkNode,
      (from) => {
        return $createThreadMarkNode(from.getIDs());
      },
      (from, to) => {
        const ids = from.getIDs();
        ids.forEach((id) => {
          to.addID(id);
        });
      }
    );
  }, [editor]);
  return /* @__PURE__ */ React.createElement(OnDeleteThreadCallback.Provider, {
    value: handleThreadDelete
  }, /* @__PURE__ */ React.createElement(ActiveThreadsContext.Provider, {
    value: activeThreads
  }, /* @__PURE__ */ React.createElement(IsActiveThreadContext.Provider, {
    value: isThreadActive
  }, /* @__PURE__ */ React.createElement(ThreadToNodesContext.Provider, {
    value: threadToNodes
  }, children))));
}
function useIsThreadActive(threadId) {
  const isActive = React.useContext(IsActiveThreadContext);
  if (isActive === null) {
    throw new Error(
      "useIsThreadActive must be used within LiveblocksPlugin. For more information: https://liveblocks.io/docs/api-reference/liveblocks-react-lexical#useIsThreadActive"
    );
  }
  return isActive(threadId);
}

export { ActiveThreadsContext, CommentPluginProvider, IsActiveThreadContext, OnDeleteThreadCallback, ThreadToNodesContext, useIsThreadActive };
//# sourceMappingURL=comment-plugin-provider.mjs.map
