import { JsonObject, LsonObject, BaseUserMeta, LiveObject, User, Json, RoomNotificationSettings, Room, Status, BroadcastOptions, OthersEvent, LostConnectionEvent, History, BaseMetadata as BaseMetadata$1, ThreadData as ThreadData$1, Client as Client$1, ClientOptions, StorageStatus as StorageStatus$1, CommentData as CommentData$1 } from '@liveblocks/client';
import * as React$1 from 'react';
import React__default, { ReactNode, PropsWithChildren } from 'react';
import { BaseMetadata, CommentBody, Patchable, StorageStatus, QueryMetadata, AsyncResultWithDataField, DRI, Resolve, InboxNotificationData, ToImmutable, ThreadData, HistoryVersion, Client, LiveblocksError, RoomEventMessage, CommentData, PartialUnless, ThreadDataWithDeleteInfo, RoomNotificationSettings as RoomNotificationSettings$1, CommentUserReaction, ThreadDeleteInfo, InboxNotificationDeleteInfo, DistributiveOmit, AsyncResult, OpaqueClient, DU, DM, OpaqueRoom, DP, DS, DE } from '@liveblocks/core';

declare type Props = {
    fallback: ReactNode;
    children: (() => ReactNode | undefined) | ReactNode | undefined;
};
/**
 * Almost like a normal <Suspense> component, except that for server-side
 * renders, the fallback will be used.
 *
 * The child props will have to be provided in a function, i.e. change:
 *
 *   <Suspense fallback={<Loading />}>
 *     <MyRealComponent a={1} />
 *   </Suspense>
 *
 * To:
 *
 *   <ClientSideSuspense fallback={<Loading />}>
 *     <MyRealComponent a={1} />
 *   </ClientSideSuspense>
 *
 */
declare function ClientSideSuspense(props: Props): React$1.JSX.Element;

/**
 * @private Internal API, do not rely on it.
 */
declare class CreateThreadError<M extends BaseMetadata> extends Error {
    cause: Error;
    context: {
        roomId: string;
        threadId: string;
        commentId: string;
        body: CommentBody;
        metadata: M;
    };
    constructor(cause: Error, context: {
        roomId: string;
        threadId: string;
        commentId: string;
        body: CommentBody;
        metadata: M;
    });
}
declare class EditThreadMetadataError<M extends BaseMetadata> extends Error {
    cause: Error;
    context: {
        roomId: string;
        threadId: string;
        metadata: Patchable<M>;
    };
    constructor(cause: Error, context: {
        roomId: string;
        threadId: string;
        metadata: Patchable<M>;
    });
}
declare class CreateCommentError extends Error {
    cause: Error;
    context: {
        roomId: string;
        threadId: string;
        commentId: string;
        body: CommentBody;
    };
    constructor(cause: Error, context: {
        roomId: string;
        threadId: string;
        commentId: string;
        body: CommentBody;
    });
}
declare class EditCommentError extends Error {
    cause: Error;
    context: {
        roomId: string;
        threadId: string;
        commentId: string;
        body: CommentBody;
    };
    constructor(cause: Error, context: {
        roomId: string;
        threadId: string;
        commentId: string;
        body: CommentBody;
    });
}
declare class DeleteCommentError extends Error {
    cause: Error;
    context: {
        roomId: string;
        threadId: string;
        commentId: string;
    };
    constructor(cause: Error, context: {
        roomId: string;
        threadId: string;
        commentId: string;
    });
}
declare class MarkInboxNotificationAsReadError extends Error {
    cause: Error;
    context: {
        inboxNotificationId: string;
    };
    constructor(cause: Error, context: {
        inboxNotificationId: string;
    });
}
declare class UpdateNotificationSettingsError extends Error {
    cause: Error;
    context: {
        roomId: string;
    };
    constructor(cause: Error, context: {
        roomId: string;
    });
}
declare type CommentsError<M extends BaseMetadata> = CreateThreadError<M> | EditThreadMetadataError<M> | CreateCommentError | EditCommentError | DeleteCommentError | MarkInboxNotificationAsReadError | UpdateNotificationSettingsError;

declare type UseStorageStatusOptions = {
    /**
     * When setting smooth, the hook will not update immediately as status
     * changes. This is because in typical applications, these states can change
     * quickly between synchronizing and synchronized. If you use this hook to
     * build a "Saving changes..." style UI, prefer setting `smooth: true`.
     */
    smooth?: boolean;
};
declare type StorageStatusSuccess = Exclude<StorageStatus, "not-loaded" | "loading">;
declare type ThreadsQuery<M extends BaseMetadata> = {
    /**
     * Whether to only return threads marked as resolved or unresolved. If not provided,
     * all threads will be returned.
     */
    resolved?: boolean;
    /**
     * The metadata to filter the threads by. If provided, only threads with metadata that matches
     * the provided metadata will be returned. If not provided, all threads will be returned.
     */
    metadata?: Partial<QueryMetadata<M>>;
};
declare type UseUserThreadsOptions<M extends BaseMetadata> = {
    /**
     * The query (including metadata) to filter the threads by. If provided, only threads
     * that match the query will be returned. If not provided, all threads will be returned.
     */
    query?: ThreadsQuery<M>;
};
declare type UseThreadsOptions<M extends BaseMetadata> = {
    /**
     * The query (including metadata) to filter the threads by. If provided, only threads
     * that match the query will be returned. If not provided, all threads will be returned.
     */
    query?: ThreadsQuery<M>;
    /**
     * Whether to scroll to a comment on load based on the URL hash. Defaults to `true`.
     *
     * @example
     * Given the URL `https://example.com/my-room#cm_xxx`, the `cm_xxx` comment will be
     * scrolled to on load if it exists in the page.
     */
    scrollOnLoad?: boolean;
};
declare type UserAsyncResult<T> = AsyncResultWithDataField<T, "user">;
declare type UserAsyncSuccess<T> = Resolve<UserAsyncResult<T> & {
    readonly isLoading: false;
    readonly error?: undefined;
}>;
declare type RoomInfoAsyncResult = AsyncResultWithDataField<DRI, "info">;
declare type RoomInfoAsyncSuccess = Resolve<RoomInfoAsyncResult & {
    readonly isLoading: false;
    readonly error?: undefined;
}>;
declare type CreateThreadOptions<M extends BaseMetadata> = Resolve<{
    body: CommentBody;
} & PartialUnless<M, {
    metadata: M;
}>>;
declare type EditThreadMetadataOptions<M extends BaseMetadata> = {
    threadId: string;
    metadata: Patchable<M>;
};
declare type CreateCommentOptions = {
    threadId: string;
    body: CommentBody;
};
declare type EditCommentOptions = {
    threadId: string;
    commentId: string;
    body: CommentBody;
};
declare type DeleteCommentOptions = {
    threadId: string;
    commentId: string;
};
declare type CommentReactionOptions = {
    threadId: string;
    commentId: string;
    emoji: string;
};
declare type ThreadsStateLoading = {
    isLoading: true;
    threads?: never;
    error?: never;
};
declare type ThreadsStateResolved<M extends BaseMetadata> = {
    isLoading: false;
    threads: ThreadData<M>[];
    error?: Error;
};
declare type ThreadsStateSuccess<M extends BaseMetadata> = {
    isLoading: false;
    threads: ThreadData<M>[];
    error?: never;
};
declare type ThreadsState<M extends BaseMetadata> = ThreadsStateLoading | ThreadsStateResolved<M>;
declare type InboxNotificationsStateLoading = {
    isLoading: true;
    inboxNotifications?: never;
    error?: never;
};
declare type InboxNotificationsStateSuccess = {
    isLoading: false;
    inboxNotifications: InboxNotificationData[];
    error?: never;
};
declare type InboxNotificationsStateError = {
    isLoading: false;
    inboxNotifications?: never;
    error: Error;
};
declare type InboxNotificationsState = InboxNotificationsStateLoading | InboxNotificationsStateSuccess | InboxNotificationsStateError;
declare type UnreadInboxNotificationsCountStateLoading = {
    isLoading: true;
    count?: never;
    error?: never;
};
declare type UnreadInboxNotificationsCountStateSuccess = {
    isLoading: false;
    count: number;
    error?: never;
};
declare type UnreadInboxNotificationsCountStateError = {
    isLoading: false;
    count?: never;
    error: Error;
};
declare type UnreadInboxNotificationsCountState = UnreadInboxNotificationsCountStateLoading | UnreadInboxNotificationsCountStateSuccess | UnreadInboxNotificationsCountStateError;
declare type RoomNotificationSettingsStateLoading = {
    isLoading: true;
    settings?: never;
    error?: never;
};
declare type RoomNotificationSettingsStateError = {
    isLoading: false;
    settings?: never;
    error: Error;
};
declare type RoomNotificationSettingsStateSuccess = {
    isLoading: false;
    settings: RoomNotificationSettings;
    error?: never;
};
declare type RoomNotificationSettingsState = RoomNotificationSettingsStateLoading | RoomNotificationSettingsStateError | RoomNotificationSettingsStateSuccess;
declare type HistoryVersionDataStateLoading = {
    isLoading: true;
    data?: never;
    error?: never;
};
declare type HistoryVersionDataStateResolved = {
    isLoading: false;
    data: Uint8Array;
    error?: Error;
};
declare type HistoryVersionDataStateError = {
    isLoading: false;
    data?: never;
    error: Error;
};
declare type HistoryVersionDataState = HistoryVersionDataStateLoading | HistoryVersionDataStateResolved | HistoryVersionDataStateError;
declare type HistoryVersionsStateLoading = {
    isLoading: true;
    versions?: never;
    error?: never;
};
declare type HistoryVersionsStateResolved = {
    isLoading: false;
    versions: HistoryVersion[];
    error?: Error;
};
declare type HistoryVersionsStateError = {
    isLoading: false;
    versions?: never;
    error: Error;
};
declare type HistoryVersionsState = HistoryVersionsStateLoading | HistoryVersionsStateResolved | HistoryVersionsStateError;
declare type RoomProviderProps<P extends JsonObject, S extends LsonObject> = Resolve<{
    /**
     * The id of the room you want to connect to
     */
    id: string;
    children: React.ReactNode;
    /**
     * Whether or not the room should connect to Liveblocks servers
     * when the RoomProvider is rendered.
     *
     * By default equals to `typeof window !== "undefined"`,
     * meaning the RoomProvider tries to connect to Liveblocks servers
     * only on the client side.
     */
    autoConnect?: boolean;
    /**
     * If you're on React 17 or lower, pass in a reference to
     * `ReactDOM.unstable_batchedUpdates` or
     * `ReactNative.unstable_batchedUpdates` here.
     *
     * @example
     * import { unstable_batchedUpdates } from "react-dom";
     *
     * <RoomProvider ... unstable_batchedUpdates={unstable_batchedUpdates} />
     *
     * This will prevent you from running into the so-called "stale props"
     * and/or "zombie child" problem that React 17 and lower can suffer from.
     * Not necessary when you're on React v18 or later.
     */
    unstable_batchedUpdates?: (cb: () => void) => void;
} & PartialUnless<P, {
    /**
     * The initial Presence to use and announce when you enter the Room. The
     * Presence is available on all users in the Room (me & others).
     */
    initialPresence: P | ((roomId: string) => P);
}> & PartialUnless<S, {
    /**
     * The initial Storage to use when entering a new Room.
     */
    initialStorage: S | ((roomId: string) => S);
}>>;
/**
 * For any function type, returns a similar function type, but without the
 * first argument.
 */
declare type OmitFirstArg<F> = F extends (first: any, ...rest: infer A) => infer R ? (...args: A) => R : never;
declare type MutationContext<P extends JsonObject, S extends LsonObject, U extends BaseUserMeta> = {
    storage: LiveObject<S>;
    self: User<P, U>;
    others: readonly User<P, U>[];
    setMyPresence: (patch: Partial<P>, options?: {
        addToHistory: boolean;
    }) => void;
};
declare type ThreadSubscription = {
    status: "not-subscribed";
    unreadSince?: never;
} | {
    status: "subscribed";
    unreadSince: null;
} | {
    status: "subscribed";
    unreadSince: Date;
};
declare type SharedContextBundle<U extends BaseUserMeta> = {
    classic: {
        /**
         * Obtains a reference to the current Liveblocks client.
         */
        useClient(): Client<U>;
        /**
         * Returns user info from a given user ID.
         *
         * @example
         * const { user, error, isLoading } = useUser("user-id");
         */
        useUser(userId: string): UserAsyncResult<U["info"]>;
        /**
         * Returns room info from a given room ID.
         *
         * @example
         * const { info, error, isLoading } = useRoomInfo("room-id");
         */
        useRoomInfo(roomId: string): RoomInfoAsyncResult;
        /**
         * Returns whether the hook is called within a RoomProvider context.
         *
         * @example
         * const isInsideRoom = useIsInsideRoom();
         */
        useIsInsideRoom(): boolean;
    };
    suspense: {
        /**
         * Obtains a reference to the current Liveblocks client.
         */
        useClient(): Client<U>;
        /**
         * Returns user info from a given user ID.
         *
         * @example
         * const { user } = useUser("user-id");
         */
        useUser(userId: string): UserAsyncSuccess<U["info"]>;
        /**
         * Returns room info from a given room ID.
         *
         * @example
         * const { info } = useRoomInfo("room-id");
         */
        useRoomInfo(roomId: string): RoomInfoAsyncSuccess;
        /**
         * Returns whether the hook is called within a RoomProvider context.
         *
         * @example
         * const isInsideRoom = useIsInsideRoom();
         */
        useIsInsideRoom(): boolean;
    };
};
/**
 * Properties that are the same in RoomContext and RoomContext["suspense"].
 */
declare type RoomContextBundleCommon<P extends JsonObject, S extends LsonObject, U extends BaseUserMeta, E extends Json, M extends BaseMetadata> = {
    /**
     * You normally don't need to directly interact with the RoomContext, but
     * it can be necessary if you're building an advanced app where you need to
     * set up a context bridge between two React renderers.
     */
    RoomContext: React.Context<Room<P, S, U, E, M> | null>;
    /**
     * Makes a Room available in the component hierarchy below.
     * Joins the room when the component is mounted, and automatically leaves
     * the room when the component is unmounted.
     */
    RoomProvider(props: RoomProviderProps<P, S>): JSX.Element;
    /**
     * Returns the Room of the nearest RoomProvider above in the React component
     * tree.
     */
    useRoom(): Room<P, S, U, E, M>;
    /**
     * Returns the current connection status for the Room, and triggers
     * a re-render whenever it changes. Can be used to render a status badge.
     */
    useStatus(): Status;
    /**
     * @deprecated It's recommended to use `useMutation` for writing to Storage,
     * which will automatically batch all mutations.
     *
     * Returns a function that batches modifications made during the given function.
     * All the modifications are sent to other clients in a single message.
     * All the modifications are merged in a single history item (undo/redo).
     * All the subscribers are called only after the batch is over.
     */
    useBatch<T>(): (callback: () => T) => T;
    /**
     * Returns a callback that lets you broadcast custom events to other users in the room
     *
     * @example
     * const broadcast = useBroadcastEvent();
     *
     * broadcast({ type: "CUSTOM_EVENT", data: { x: 0, y: 0 } });
     */
    useBroadcastEvent(): (event: E, options?: BroadcastOptions) => void;
    /**
     * Get informed when users enter or leave the room, as an event.
     *
     * @example
     * useOthersListener({ type, user, others }) => {
     *   if (type === 'enter') {
     *     // `user` has joined the room
     *   } else if (type === 'leave') {
     *     // `user` has left the room
     *   }
     * })
     */
    useOthersListener(callback: (event: OthersEvent<P, U>) => void): void;
    /**
     * Get informed when reconnecting to the Liveblocks servers is taking
     * longer than usual. This typically is a sign of a client that has lost
     * internet connectivity.
     *
     * This isn't problematic (because the Liveblocks client is still trying to
     * reconnect), but it's typically a good idea to inform users about it if
     * the connection takes too long to recover.
     *
     * @example
     * useLostConnectionListener(event => {
     *   if (event === 'lost') {
     *     toast.warn('Reconnecting to the Liveblocks servers is taking longer than usual...')
     *   } else if (event === 'failed') {
     *     toast.warn('Reconnecting to the Liveblocks servers failed.')
     *   } else if (event === 'restored') {
     *     toast.clear();
     *   }
     * })
     */
    useLostConnectionListener(callback: (event: LostConnectionEvent) => void): void;
    /**
     * useErrorListener is a React hook that allows you to respond to potential room
     * connection errors.
     *
     * @example
     * useErrorListener(er => {
     *   console.error(er);
     * })
     */
    useErrorListener(callback: (err: LiveblocksError) => void): void;
    /**
     * useEventListener is a React hook that allows you to respond to events broadcast
     * by other users in the room.
     *
     * The `user` argument will indicate which `User` instance sent the message.
     * This will be equal to one of the others in the room, but it can be `null`
     * in case this event was broadcasted from the server.
     *
     * @example
     * useEventListener(({ event, user, connectionId }) => {
     * //                         ^^^^ Will be Client A
     *   if (event.type === "CUSTOM_EVENT") {
     *     // Do something
     *   }
     * });
     */
    useEventListener(callback: (data: RoomEventMessage<P, U, E>) => void): void;
    /**
     * Returns the room.history
     */
    useHistory(): History;
    /**
     * Returns a function that undoes the last operation executed by the current client.
     * It does not impact operations made by other clients.
     */
    useUndo(): () => void;
    /**
     * Returns a function that redoes the last operation executed by the current client.
     * It does not impact operations made by other clients.
     */
    useRedo(): () => void;
    /**
     * Returns whether there are any operations to undo.
     */
    useCanUndo(): boolean;
    /**
     * Returns whether there are any operations to redo.
     */
    useCanRedo(): boolean;
    /**
     * Returns the mutable (!) Storage root. This hook exists for
     * backward-compatible reasons.
     *
     * @example
     * const [root] = useStorageRoot();
     */
    useStorageRoot(): [root: LiveObject<S> | null];
    /**
     * Returns the presence of the current user of the current room, and a function to update it.
     * It is different from the setState function returned by the useState hook from React.
     * You don't need to pass the full presence object to update it.
     *
     * @example
     * const [myPresence, updateMyPresence] = useMyPresence();
     * updateMyPresence({ x: 0 });
     * updateMyPresence({ y: 0 });
     *
     * // At the next render, "myPresence" will be equal to "{ x: 0, y: 0 }"
     */
    useMyPresence(): [
        P,
        (patch: Partial<P>, options?: {
            addToHistory: boolean;
        }) => void
    ];
    /**
     * useUpdateMyPresence is similar to useMyPresence but it only returns the function to update the current user presence.
     * If you don't use the current user presence in your component, but you need to update it (e.g. live cursor), it's better to use useUpdateMyPresence to avoid unnecessary renders.
     *
     * @example
     * const updateMyPresence = useUpdateMyPresence();
     * updateMyPresence({ x: 0 });
     * updateMyPresence({ y: 0 });
     *
     * // At the next render, the presence of the current user will be equal to "{ x: 0, y: 0 }"
     */
    useUpdateMyPresence(): (patch: Partial<P>, options?: {
        addToHistory: boolean;
    }) => void;
    /**
     * Create a callback function that lets you mutate Liveblocks state.
     *
     * The first argument that gets passed into your callback will be
     * a "mutation context", which exposes the following:
     *
     *   - `storage` - The mutable Storage root.
     *                 You can mutate any Live structures with this, for example:
     *                 `storage.get('layers').get('layer1').set('fill', 'red')`
     *
     *   - `setMyPresence` - Call this with a new (partial) Presence value.
     *
     *   - `self` - A read-only version of the latest self, if you need it to
     *              compute the next state.
     *
     *   - `others` - A read-only version of the latest others list, if you
     *                need it to compute the next state.
     *
     * useMutation is like React's useCallback, except that the first argument
     * that gets passed into your callback will be a "mutation context".
     *
     * If you want get access to the immutable root somewhere in your mutation,
     * you can use `storage.ToImmutable()`.
     *
     * @example
     * const fillLayers = useMutation(
     *   ({ storage }, color: Color) => {
     *     ...
     *   },
     *   [],
     * );
     *
     * fillLayers('red');
     *
     * const deleteLayers = useMutation(
     *   ({ storage }) => {
     *     ...
     *   },
     *   [],
     * );
     *
     * deleteLayers();
     */
    useMutation<F extends (context: MutationContext<P, S, U>, ...args: any[]) => any>(callback: F, deps: readonly unknown[]): OmitFirstArg<F>;
    /**
     * Returns an array with information about all the users currently connected
     * in the room (except yourself).
     *
     * @example
     * const others = useOthers();
     *
     * // Example to map all cursors in JSX
     * return (
     *   <>
     *     {others.map((user) => {
     *        if (user.presence.cursor == null) {
     *          return null;
     *        }
     *        return <Cursor key={user.connectionId} cursor={user.presence.cursor} />
     *      })}
     *   </>
     * )
     */
    useOthers(): readonly User<P, U>[];
    /**
     * Extract arbitrary data based on all the users currently connected in the
     * room (except yourself).
     *
     * The selector function will get re-evaluated any time a user enters or
     * leaves the room, as well as whenever their presence data changes.
     *
     * The component that uses this hook will automatically re-render if your
     * selector function returns a different value from its previous run.
     *
     * By default `useOthers()` uses strict `===` to check for equality. Take
     * extra care when returning a computed object or list, for example when you
     * return the result of a .map() or .filter() call from the selector. In
     * those cases, you'll probably want to use a `shallow` comparison check.
     *
     * @example
     * const avatars = useOthers(users => users.map(u => u.info.avatar), shallow);
     * const cursors = useOthers(users => users.map(u => u.presence.cursor), shallow);
     * const someoneIsTyping = useOthers(users => users.some(u => u.presence.isTyping));
     *
     */
    useOthers<T>(selector: (others: readonly User<P, U>[]) => T, isEqual?: (prev: T, curr: T) => boolean): T;
    /**
     * Returns an array of connection IDs. This matches the values you'll get by
     * using the `useOthers()` hook.
     *
     * Roughly equivalent to:
     *   useOthers((others) => others.map(other => other.connectionId), shallow)
     *
     * This is useful in particular to implement efficiently rendering components
     * for each user in the room, e.g. cursors.
     *
     * @example
     * const ids = useOthersConnectionIds();
     * // [2, 4, 7]
     */
    useOthersConnectionIds(): readonly number[];
    /**
     * Related to useOthers(), but optimized for selecting only "subsets" of
     * others. This is useful for performance reasons in particular, because
     * selecting only a subset of users also means limiting the number of
     * re-renders that will be triggered.
     *
     * @example
     * const avatars = useOthersMapped(user => user.info.avatar);
     * //    ^^^^^^^
     * //    { connectionId: number; data: string }[]
     *
     * The selector function you pass to useOthersMapped() is called an "item
     * selector", and operates on a single user at a time. If you provide an
     * (optional) "item comparison" function, it will be used to compare each
     * item pairwise.
     *
     * For example, to select multiple properties:
     *
     * @example
     * const avatarsAndCursors = useOthersMapped(
     *   user => [u.info.avatar, u.presence.cursor],
     *   shallow,  // 👈
     * );
     */
    useOthersMapped<T>(itemSelector: (other: User<P, U>) => T, itemIsEqual?: (prev: T, curr: T) => boolean): ReadonlyArray<readonly [connectionId: number, data: T]>;
    /**
     * Given a connection ID (as obtained by using `useOthersConnectionIds`), you
     * can call this selector deep down in your component stack to only have the
     * component re-render if properties for this particular user change.
     *
     * @example
     * // Returns only the selected values re-renders whenever that selection changes)
     * const { x, y } = useOther(2, user => user.presence.cursor);
     */
    useOther<T>(connectionId: number, selector: (other: User<P, U>) => T, isEqual?: (prev: T, curr: T) => boolean): T;
    /**
     * Returns a function that creates a thread with an initial comment, and optionally some metadata.
     *
     * @example
     * const createThread = useCreateThread();
     * createThread({ body: {}, metadata: {} });
     */
    useCreateThread(): (options: CreateThreadOptions<M>) => ThreadData<M>;
    /**
     * Returns a function that deletes a thread and its associated comments.
     * Only the thread creator can delete a thread, it will throw otherwise.
     *
     * @example
     * const deleteThread = useDeleteThread();
     * deleteThread("th_xxx");
     */
    useDeleteThread(): (threadId: string) => void;
    /**
     * Returns a function that edits a thread's metadata.
     * To delete an existing metadata property, set its value to `null`.
     *
     * @example
     * const editThreadMetadata = useEditThreadMetadata();
     * editThreadMetadata({ threadId: "th_xxx", metadata: {} })
     */
    useEditThreadMetadata(): (options: EditThreadMetadataOptions<M>) => void;
    /**
     * Returns a function that marks a thread as resolved.
     *
     * @example
     * const markThreadAsResolved = useMarkThreadAsResolved();
     * markThreadAsResolved("th_xxx");
     */
    useMarkThreadAsResolved(): (threadId: string) => void;
    /**
     * Returns a function that marks a thread as unresolved.
     *
     * @example
     * const markThreadAsUnresolved = useMarkThreadAsUnresolved();
     * markThreadAsUnresolved("th_xxx");
     */
    useMarkThreadAsUnresolved(): (threadId: string) => void;
    /**
     * Returns a function that adds a comment to a thread.
     *
     * @example
     * const createComment = useCreateComment();
     * createComment({ threadId: "th_xxx", body: {} });
     */
    useCreateComment(): (options: CreateCommentOptions) => CommentData;
    /**
     * Returns a function that edits a comment's body.
     *
     * @example
     * const editComment = useEditComment()
     * editComment({ threadId: "th_xxx", commentId: "cm_xxx", body: {} })
     */
    useEditComment(): (options: EditCommentOptions) => void;
    /**
     * Returns a function that deletes a comment.
     * If it is the last non-deleted comment, the thread also gets deleted.
     *
     * @example
     * const deleteComment = useDeleteComment();
     * deleteComment({ threadId: "th_xxx", commentId: "cm_xxx" })
     */
    useDeleteComment(): (options: DeleteCommentOptions) => void;
    /**
     * Returns a function that adds a reaction from a comment.
     *
     * @example
     * const addReaction = useAddReaction();
     * addReaction({ threadId: "th_xxx", commentId: "cm_xxx", emoji: "👍" })
     */
    useAddReaction(): (options: CommentReactionOptions) => void;
    /**
     * Returns a function that removes a reaction on a comment.
     *
     * @example
     * const removeReaction = useRemoveReaction();
     * removeReaction({ threadId: "th_xxx", commentId: "cm_xxx", emoji: "👍" })
     */
    useRemoveReaction(): (options: CommentReactionOptions) => void;
    /**
     * Returns a function that updates the user's notification settings
     * for the current room.
     *
     * @example
     * const updateRoomNotificationSettings = useUpdateRoomNotificationSettings();
     * updateRoomNotificationSettings({ threads: "all" });
     */
    useUpdateRoomNotificationSettings(): (settings: Partial<RoomNotificationSettings>) => void;
    /**
     * Returns a function that marks a thread as read.
     *
     * @example
     * const markThreadAsRead = useMarkThreadAsRead();
     * markThreadAsRead("th_xxx");
     */
    useMarkThreadAsRead(): (threadId: string) => void;
    /**
     * Returns the subscription status of a thread.
     *
     * @example
     * const { status, unreadSince } = useThreadSubscription("th_xxx");
     */
    useThreadSubscription(threadId: string): ThreadSubscription;
};
/**
 * @private
 *
 * Private methods and variables used in the core internals, but as a user
 * of Liveblocks, NEVER USE ANY OF THESE DIRECTLY, because bad things
 * will probably happen if you do.
 */
declare type PrivateRoomContextApi = {
    useCommentsErrorListener<M extends BaseMetadata>(callback: (err: CommentsError<M>) => void): void;
};
declare type RoomContextBundle<P extends JsonObject, S extends LsonObject, U extends BaseUserMeta, E extends Json, M extends BaseMetadata> = Resolve<RoomContextBundleCommon<P, S, U, E, M> & SharedContextBundle<U>["classic"] & {
    /**
     * Returns the current storage status for the Room, and triggers
     * a re-render whenever it changes. Can be used to render a "Saving..."
     * indicator.
     */
    useStorageStatus(options?: UseStorageStatusOptions): StorageStatus;
    /**
     * Extract arbitrary data from the Liveblocks Storage state, using an
     * arbitrary selector function.
     *
     * The selector function will get re-evaluated any time something changes in
     * Storage. The value returned by your selector function will also be the
     * value returned by the hook.
     *
     * The `root` value that gets passed to your selector function is
     * a immutable/readonly version of your Liveblocks storage root.
     *
     * The component that uses this hook will automatically re-render if the
     * returned value changes.
     *
     * By default `useStorage()` uses strict `===` to check for equality. Take
     * extra care when returning a computed object or list, for example when you
     * return the result of a .map() or .filter() call from the selector. In
     * those cases, you'll probably want to use a `shallow` comparison check.
     */
    useStorage<T>(selector: (root: ToImmutable<S>) => T, isEqual?: (prev: T | null, curr: T | null) => boolean): T | null;
    /**
     * Gets the current user once it is connected to the room.
     *
     * @example
     * const me = useSelf();
     * if (me !== null) {
     *   const { x, y } = me.presence.cursor;
     * }
     */
    useSelf(): User<P, U> | null;
    /**
     * Extract arbitrary data based on the current user.
     *
     * The selector function will get re-evaluated any time your presence data
     * changes.
     *
     * The component that uses this hook will automatically re-render if your
     * selector function returns a different value from its previous run.
     *
     * By default `useSelf()` uses strict `===` to check for equality. Take extra
     * care when returning a computed object or list, for example when you return
     * the result of a .map() or .filter() call from the selector. In those
     * cases, you'll probably want to use a `shallow` comparison check.
     *
     * Will return `null` while Liveblocks isn't connected to a room yet.
     *
     * @example
     * const cursor = useSelf(me => me.presence.cursor);
     * if (cursor !== null) {
     *   const { x, y } = cursor;
     * }
     *
     */
    useSelf<T>(selector: (me: User<P, U>) => T, isEqual?: (prev: T, curr: T) => boolean): T | null;
    /**
     * Returns the threads within the current room.
     *
     * @example
     * const { threads, error, isLoading } = useThreads();
     */
    useThreads(options?: UseThreadsOptions<M>): ThreadsState<M>;
    /**
     * Returns the user's notification settings for the current room
     * and a function to update them.
     *
     * @example
     * const [{ settings }, updateSettings] = useRoomNotificationSettings();
     */
    useRoomNotificationSettings(): [
        RoomNotificationSettingsState,
        (settings: Partial<RoomNotificationSettings>) => void
    ];
    /**
     * (Private beta)  Returns a history of versions of the current room.
     *
     * @example
     * const { versions, error, isLoading } = useHistoryVersions();
     */
    useHistoryVersions(): HistoryVersionsState;
    /**
     * (Private beta) Returns the data of a specific version of the current room.
     *
     * @example
     * const { data, error, isLoading } = useHistoryVersionData(version.id);
     */
    useHistoryVersionData(id: string): HistoryVersionDataState;
    suspense: Resolve<RoomContextBundleCommon<P, S, U, E, M> & SharedContextBundle<U>["suspense"] & {
        /**
         * Returns the current storage status for the Room, and triggers
         * a re-render whenever it changes. Can be used to render a "Saving..."
         * indicator.
         */
        useStorageStatus(options?: UseStorageStatusOptions): StorageStatusSuccess;
        /**
         * Extract arbitrary data from the Liveblocks Storage state, using an
         * arbitrary selector function.
         *
         * The selector function will get re-evaluated any time something changes in
         * Storage. The value returned by your selector function will also be the
         * value returned by the hook.
         *
         * The `root` value that gets passed to your selector function is
         * a immutable/readonly version of your Liveblocks storage root.
         *
         * The component that uses this hook will automatically re-render if the
         * returned value changes.
         *
         * By default `useStorage()` uses strict `===` to check for equality. Take
         * extra care when returning a computed object or list, for example when you
         * return the result of a .map() or .filter() call from the selector. In
         * those cases, you'll probably want to use a `shallow` comparison check.
         */
        useStorage<T>(selector: (root: ToImmutable<S>) => T, isEqual?: (prev: T, curr: T) => boolean): T;
        /**
         * Gets the current user once it is connected to the room.
         *
         * @example
         * const me = useSelf();
         * const { x, y } = me.presence.cursor;
         */
        useSelf(): User<P, U>;
        /**
         * Extract arbitrary data based on the current user.
         *
         * The selector function will get re-evaluated any time your presence data
         * changes.
         *
         * The component that uses this hook will automatically re-render if your
         * selector function returns a different value from its previous run.
         *
         * By default `useSelf()` uses strict `===` to check for equality. Take extra
         * care when returning a computed object or list, for example when you return
         * the result of a .map() or .filter() call from the selector. In those
         * cases, you'll probably want to use a `shallow` comparison check.
         *
         * @example
         * const cursor = useSelf(me => me.presence.cursor);
         * const { x, y } = cursor;
         *
         */
        useSelf<T>(selector: (me: User<P, U>) => T, isEqual?: (prev: T, curr: T) => boolean): T;
        /**
         * Returns the threads within the current room.
         *
         * @example
         * const { threads } = useThreads();
         */
        useThreads(options?: UseThreadsOptions<M>): ThreadsStateSuccess<M>;
        /**
         * (Private beta) Returns a history of versions of the current room.
         *
         * @example
         * const { versions } = useHistoryVersions();
         */
        useHistoryVersions(): HistoryVersionsStateResolved;
        /**
         * Returns the user's notification settings for the current room
         * and a function to update them.
         *
         * @example
         * const [{ settings }, updateSettings] = useRoomNotificationSettings();
         */
        useRoomNotificationSettings(): [
            RoomNotificationSettingsStateSuccess,
            (settings: Partial<RoomNotificationSettings>) => void
        ];
    }>;
} & PrivateRoomContextApi>;
/**
 * Properties that are the same in LiveblocksContext and LiveblocksContext["suspense"].
 */
declare type LiveblocksContextBundleCommon<M extends BaseMetadata> = {
    /**
     * Makes Liveblocks features outside of rooms (e.g. Notifications) available
     * in the component hierarchy below.
     */
    LiveblocksProvider(props: PropsWithChildren): JSX.Element;
    /**
     * Returns a function that marks an inbox notification as read for the current user.
     *
     * @example
     * const markInboxNotificationAsRead = useMarkInboxNotificationAsRead();
     * markInboxNotificationAsRead("in_xxx");
     */
    useMarkInboxNotificationAsRead(): (inboxNotificationId: string) => void;
    /**
     * Returns a function that marks all of the current user's inbox notifications as read.
     *
     * @example
     * const markAllInboxNotificationsAsRead = useMarkAllInboxNotificationsAsRead();
     * markAllInboxNotificationsAsRead();
     */
    useMarkAllInboxNotificationsAsRead(): () => void;
    /**
     * Returns a function that deletes an inbox notification for the current user.
     *
     * @example
     * const deleteInboxNotification = useDeleteInboxNotification();
     * deleteInboxNotification("in_xxx");
     */
    useDeleteInboxNotification(): (inboxNotificationId: string) => void;
    /**
     * Returns a function that deletes all of the current user's inbox notifications.
     *
     * @example
     * const deleteAllInboxNotifications = useDeleteAllInboxNotifications();
     * deleteAllInboxNotifications();
     */
    useDeleteAllInboxNotifications(): () => void;
    /**
     * Returns the thread associated with a `"thread"` inbox notification.
     *
     * It can **only** be called with IDs of `"thread"` inbox notifications,
     * so we recommend only using it when customizing the rendering or in other
     * situations where you can guarantee the kind of the notification.
     *
     * When `useInboxNotifications` returns `"thread"` inbox notifications,
     * it also receives the associated threads and caches them behind the scenes.
     * When you call `useInboxNotificationThread`, it simply returns the cached thread
     * for the inbox notification ID you passed to it, without any fetching or waterfalls.
     *
     * @example
     * const thread = useInboxNotificationThread("in_xxx");
     */
    useInboxNotificationThread(inboxNotificationId: string): ThreadData<M>;
};
declare type LiveblocksContextBundle<U extends BaseUserMeta, M extends BaseMetadata> = Resolve<LiveblocksContextBundleCommon<M> & SharedContextBundle<U>["classic"] & {
    /**
     * Returns the inbox notifications for the current user.
     *
     * @example
     * const { inboxNotifications, error, isLoading } = useInboxNotifications();
     */
    useInboxNotifications(): InboxNotificationsState;
    /**
     * Returns the number of unread inbox notifications for the current user.
     *
     * @example
     * const { count, error, isLoading } = useUnreadInboxNotificationsCount();
     */
    useUnreadInboxNotificationsCount(): UnreadInboxNotificationsCountState;
    /**
     * @experimental
     *
     * This hook is experimental and could be removed or changed at any time!
     * Do not use unless explicitly recommended by the Liveblocks team.
     */
    useUserThreads_experimental(options?: UseUserThreadsOptions<M>): ThreadsState<M>;
    suspense: Resolve<LiveblocksContextBundleCommon<M> & SharedContextBundle<U>["suspense"] & {
        /**
         * Returns the inbox notifications for the current user.
         *
         * @example
         * const { inboxNotifications } = useInboxNotifications();
         */
        useInboxNotifications(): InboxNotificationsStateSuccess;
        /**
         * Returns the number of unread inbox notifications for the current user.
         *
         * @example
         * const { count } = useUnreadInboxNotificationsCount();
         */
        useUnreadInboxNotificationsCount(): UnreadInboxNotificationsCountStateSuccess;
        /**
         * @experimental
         *
         * This hook is experimental and could be removed or changed at any time!
         * Do not use unless explicitly recommended by the Liveblocks team.
         */
        useUserThreads_experimental(options?: UseUserThreadsOptions<M>): ThreadsStateSuccess<M>;
    }>;
}>;

declare type OptimisticUpdate<M extends BaseMetadata> = CreateThreadOptimisticUpdate<M> | DeleteThreadOptimisticUpdate | EditThreadMetadataOptimisticUpdate<M> | MarkThreadAsResolvedOptimisticUpdate | MarkThreadAsUnresolvedOptimisticUpdate | CreateCommentOptimisticUpdate | EditCommentOptimisticUpdate | DeleteCommentOptimisticUpdate | AddReactionOptimisticUpdate | RemoveReactionOptimisticUpdate | MarkInboxNotificationAsReadOptimisticUpdate | MarkAllInboxNotificationsAsReadOptimisticUpdate | DeleteInboxNotificationOptimisticUpdate | DeleteAllInboxNotificationsOptimisticUpdate | UpdateNotificationSettingsOptimisticUpdate;
declare type CreateThreadOptimisticUpdate<M extends BaseMetadata> = {
    type: "create-thread";
    id: string;
    roomId: string;
    thread: ThreadData<M>;
};
declare type DeleteThreadOptimisticUpdate = {
    type: "delete-thread";
    id: string;
    roomId: string;
    threadId: string;
    deletedAt: Date;
};
declare type EditThreadMetadataOptimisticUpdate<M extends BaseMetadata> = {
    type: "edit-thread-metadata";
    id: string;
    threadId: string;
    metadata: Resolve<Patchable<M>>;
    updatedAt: Date;
};
declare type MarkThreadAsResolvedOptimisticUpdate = {
    type: "mark-thread-as-resolved";
    id: string;
    threadId: string;
    updatedAt: Date;
};
declare type MarkThreadAsUnresolvedOptimisticUpdate = {
    type: "mark-thread-as-unresolved";
    id: string;
    threadId: string;
    updatedAt: Date;
};
declare type CreateCommentOptimisticUpdate = {
    type: "create-comment";
    id: string;
    comment: CommentData;
};
declare type EditCommentOptimisticUpdate = {
    type: "edit-comment";
    id: string;
    comment: CommentData;
};
declare type DeleteCommentOptimisticUpdate = {
    type: "delete-comment";
    id: string;
    roomId: string;
    threadId: string;
    deletedAt: Date;
    commentId: string;
};
declare type AddReactionOptimisticUpdate = {
    type: "add-reaction";
    id: string;
    threadId: string;
    commentId: string;
    reaction: CommentUserReaction;
};
declare type RemoveReactionOptimisticUpdate = {
    type: "remove-reaction";
    id: string;
    threadId: string;
    commentId: string;
    emoji: string;
    userId: string;
    removedAt: Date;
};
declare type MarkInboxNotificationAsReadOptimisticUpdate = {
    type: "mark-inbox-notification-as-read";
    id: string;
    inboxNotificationId: string;
    readAt: Date;
};
declare type MarkAllInboxNotificationsAsReadOptimisticUpdate = {
    type: "mark-all-inbox-notifications-as-read";
    id: string;
    readAt: Date;
};
declare type DeleteInboxNotificationOptimisticUpdate = {
    type: "delete-inbox-notification";
    id: string;
    inboxNotificationId: string;
    deletedAt: Date;
};
declare type DeleteAllInboxNotificationsOptimisticUpdate = {
    type: "delete-all-inbox-notifications";
    id: string;
    deletedAt: Date;
};
declare type UpdateNotificationSettingsOptimisticUpdate = {
    type: "update-notification-settings";
    id: string;
    roomId: string;
    settings: Partial<RoomNotificationSettings$1>;
};
declare type QueryState = AsyncResult<undefined>;
/**
 * Externally observable state of the store, which will have:
 * - Optimistic updates applied
 * - All deleted threads removed from the threads list
 */
declare type UmbrellaStoreState<M extends BaseMetadata> = {
    /**
     * Keep track of loading and error status of all the queries made by the client.
     * e.g. 'room-abc-{"color":"red"}'  - ok
     * e.g. 'room-abc-{}'               - loading
     */
    queries: Record<string, QueryState>;
    /**
     * All threads in a sorted array, optimistic updates applied, without deleted
     * threads.
     */
    threads: ThreadData<M>[];
    /**
     * All threads in a map, keyed by thread ID, with all optimistic updates
     * applied. Deleted threads are still in this mapping, and will have
     * a deletedAt field if so.
     */
    threadsById: Record<string, ThreadDataWithDeleteInfo<M>>;
    /**
     * All inbox notifications in a sorted array, optimistic updates applied.
     */
    inboxNotifications: InboxNotificationData[];
    /**
     * Inbox notifications by ID.
     * e.g. `in_${string}`
     */
    inboxNotificationsById: Record<string, InboxNotificationData>;
    /**
     * Notification settings by room ID.
     * e.g. { 'room-abc': { threads: "all" },
     *        'room-def': { threads: "replies_and_mentions" },
     *        'room-xyz': { threads: "none" },
     *      }
     */
    notificationSettingsByRoomId: Record<string, RoomNotificationSettings$1>;
    /**
     * Versions by roomId
     * e.g. { 'room-abc': {versions: "all versions"}}
     */
    versionsByRoomId: Record<string, HistoryVersion[]>;
};
declare class UmbrellaStore<M extends BaseMetadata> {
    private _store;
    private _prevState;
    private _stateCached;
    constructor();
    private get;
    getThreads(): UmbrellaStoreState<M>;
    getInboxNotifications(): UmbrellaStoreState<M>;
    getNotificationSettings(): UmbrellaStoreState<M>;
    getVersions(): UmbrellaStoreState<M>;
    /**
     * @private Only used by the E2E test suite.
     */
    _hasOptimisticUpdates(): boolean;
    private subscribe;
    /**
     * @private Only used by the E2E test suite.
     */
    _subscribeOptimisticUpdates(callback: () => void): () => void;
    subscribeThreads(callback: () => void): () => void;
    subscribeInboxNotifications(callback: () => void): () => void;
    subscribeNotificationSettings(callback: () => void): () => void;
    subscribeVersions(callback: () => void): () => void;
    private updateThreadsCache;
    private updateInboxNotificationsCache;
    private setNotificationSettings;
    private setVersions;
    private setQueryState;
    private updateOptimisticUpdatesCache;
    /**
     * Updates an existing inbox notification with a new value, replacing the
     * corresponding optimistic update.
     *
     * This will not update anything if the inbox notification ID isn't found in
     * the cache.
     */
    updateInboxNotification(inboxNotificationId: string, optimisticUpdateId: string, callback: (notification: Readonly<InboxNotificationData>) => Readonly<InboxNotificationData>): void;
    /**
     * Updates *all* inbox notifications by running a mapper function over all of
     * them, replacing the corresponding optimistic update.
     */
    updateAllInboxNotifications(optimisticUpdateId: string, mapFn: (notification: Readonly<InboxNotificationData>) => Readonly<InboxNotificationData>): void;
    /**
     * Deletes an existing inbox notification, replacing the corresponding
     * optimistic update.
     */
    deleteInboxNotification(inboxNotificationId: string, optimisticUpdateId: string): void;
    /**
     * Deletes *all* inbox notifications, replacing the corresponding optimistic
     * update.
     */
    deleteAllInboxNotifications(optimisticUpdateId: string): void;
    /**
     * Creates an new thread, replacing the corresponding optimistic update.
     */
    createThread(optimisticUpdateId: string, thread: Readonly<ThreadDataWithDeleteInfo<M>>): void;
    /**
     * Updates an existing thread with a new value, replacing the corresponding
     * optimistic update.
     *
     * This will not update anything if:
     * - The thread ID isn't found in the cache; or
     * - The thread ID was already deleted from the cache; or
     * - The thread ID in the cache was updated more recently than the optimistic
     *   update's timestamp (if given)
     */
    private updateThread;
    patchThread(threadId: string, optimisticUpdateId: string | null, patch: {
        metadata?: M;
        resolved?: boolean;
    }, updatedAt: Date): void;
    addReaction(threadId: string, optimisticUpdateId: string | null, commentId: string, reaction: CommentUserReaction, createdAt: Date): void;
    removeReaction(threadId: string, optimisticUpdateId: string | null, commentId: string, emoji: string, userId: string, removedAt: Date): void;
    /**
     * Soft-deletes an existing thread by setting its `deletedAt` value,
     * replacing the corresponding optimistic update.
     *
     * This will not update anything if:
     * - The thread ID isn't found in the cache; or
     * - The thread ID was already deleted from the cache
     */
    deleteThread(threadId: string, optimisticUpdateId: string | null): void;
    /**
     * Creates an existing comment and ensures the associated notification is
     * updated correctly, replacing the corresponding optimistic update.
     */
    createComment(newComment: CommentData, optimisticUpdateId: string): void;
    editComment(threadId: string, optimisticUpdateId: string, editedComment: CommentData): void;
    deleteComment(threadId: string, optimisticUpdateId: string, commentId: string, deletedAt: Date): void;
    updateThreadAndNotification(thread: ThreadData<M>, inboxNotification?: InboxNotificationData): void;
    updateThreadsAndNotifications(threads: ThreadData<M>[], inboxNotifications: InboxNotificationData[], deletedThreads: ThreadDeleteInfo[], deletedInboxNotifications: InboxNotificationDeleteInfo[], queryKey?: string): void;
    /**
     * Updates existing notification setting for a room with a new value,
     * replacing the corresponding optimistic update.
     */
    updateRoomInboxNotificationSettings2(roomId: string, optimisticUpdateId: string, settings: Readonly<RoomNotificationSettings$1>): void;
    updateRoomInboxNotificationSettings(roomId: string, settings: RoomNotificationSettings$1, queryKey: string): void;
    updateRoomVersions(roomId: string, versions: HistoryVersion[], queryKey?: string): void;
    addOptimisticUpdate(optimisticUpdate: DistributiveOmit<OptimisticUpdate<M>, "id">): string;
    removeOptimisticUpdate(optimisticUpdateId: string): void;
    setQueryLoading(queryKey: string): void;
    private setQueryOK;
    setQueryError(queryKey: string, error: Error): void;
}

/**
 * Raw access to the React context where the LiveblocksProvider stores the
 * current client. Exposed for advanced use cases only.
 *
 * @private This is a private/advanced API. Do not rely on it.
 */
declare const ClientContext: React__default.Context<OpaqueClient | null>;
/**
 * @private Do not rely on this internal API.
 */
declare function selectThreads<M extends BaseMetadata$1>(state: UmbrellaStoreState<M>, options: {
    roomId: string | null;
    query?: ThreadsQuery<M>;
    orderBy: "age" | "last-update";
}): ThreadData$1<M>[];
/**
 * Gets or creates a unique Umbrella store for each unique client instance.
 *
 * @private
 */
declare function getUmbrellaStoreForClient<M extends BaseMetadata$1>(client: OpaqueClient): UmbrellaStore<M>;
/**
 * Obtains a reference to the current Liveblocks client.
 */
declare function useClient<U extends BaseUserMeta>(): Client$1<U, BaseMetadata$1>;
/**
 * Sets up a client for connecting to Liveblocks, and is the recommended way to do
 * this for React apps. You must define either `authEndpoint` or `publicApiKey`.
 * Resolver functions should be placed inside here, and a number of other options
 * are available, which correspond with those passed to `createClient`.
 * Unlike `RoomProvider`, `LiveblocksProvider` doesn’t call Liveblocks servers when mounted,
 * and it should be placed higher in your app’s component tree.
 */
declare function LiveblocksProvider<U extends BaseUserMeta = DU>(props: PropsWithChildren<ClientOptions<U>>): React__default.JSX.Element;
/**
 * Creates a LiveblocksProvider and a set of typed hooks. Note that any
 * LiveblocksProvider created in this way takes no props, because it uses
 * settings from the given client instead.
 */
declare function createLiveblocksContext<U extends BaseUserMeta = DU, M extends BaseMetadata$1 = DM>(client: OpaqueClient): LiveblocksContextBundle<U, M>;
/**
 * Returns the inbox notifications for the current user.
 *
 * @example
 * const { inboxNotifications, error, isLoading } = useInboxNotifications();
 */
declare function useInboxNotifications(): InboxNotificationsState;
/**
 * Returns the inbox notifications for the current user.
 *
 * @example
 * const { inboxNotifications } = useInboxNotifications();
 */
declare function useInboxNotificationsSuspense(): InboxNotificationsStateSuccess;
/**
 * Returns a function that marks all of the current user's inbox notifications as read.
 *
 * @example
 * const markAllInboxNotificationsAsRead = useMarkAllInboxNotificationsAsRead();
 * markAllInboxNotificationsAsRead();
 */
declare function useMarkAllInboxNotificationsAsRead(): () => void;
/**
 * Returns a function that marks an inbox notification as read for the current user.
 *
 * @example
 * const markInboxNotificationAsRead = useMarkInboxNotificationAsRead();
 * markInboxNotificationAsRead("in_xxx");
 */
declare function useMarkInboxNotificationAsRead(): (inboxNotificationId: string) => void;
/**
 * Returns a function that deletes all of the current user's inbox notifications.
 *
 * @example
 * const deleteAllInboxNotifications = useDeleteAllInboxNotifications();
 * deleteAllInboxNotifications();
 */
declare function useDeleteAllInboxNotifications(): () => void;
/**
 * Returns a function that deletes an inbox notification for the current user.
 *
 * @example
 * const deleteInboxNotification = useDeleteInboxNotification();
 * deleteInboxNotification("in_xxx");
 */
declare function useDeleteInboxNotification(): (inboxNotificationId: string) => void;
/**
 * Returns the number of unread inbox notifications for the current user.
 *
 * @example
 * const { count, error, isLoading } = useUnreadInboxNotificationsCount();
 */
declare function useUnreadInboxNotificationsCount(): UnreadInboxNotificationsCountState;
/**
 * Returns the number of unread inbox notifications for the current user.
 *
 * @example
 * const { count } = useUnreadInboxNotificationsCount();
 */
declare function useUnreadInboxNotificationsCountSuspense(): UnreadInboxNotificationsCountStateSuccess;
/**
 * Returns room info from a given room ID.
 *
 * @example
 * const { info, error, isLoading } = useRoomInfo("room-id");
 */
declare function useRoomInfo(roomId: string): RoomInfoAsyncResult;
/**
 * Returns room info from a given room ID.
 *
 * @example
 * const { info } = useRoomInfo("room-id");
 */
declare function useRoomInfoSuspense(roomId: string): RoomInfoAsyncSuccess;
declare type TypedBundle$1 = LiveblocksContextBundle<DU, DM>;
/**
 * Returns the thread associated with a `"thread"` inbox notification.
 *
 * It can **only** be called with IDs of `"thread"` inbox notifications,
 * so we recommend only using it when customizing the rendering or in other
 * situations where you can guarantee the kind of the notification.
 *
 * When `useInboxNotifications` returns `"thread"` inbox notifications,
 * it also receives the associated threads and caches them behind the scenes.
 * When you call `useInboxNotificationThread`, it simply returns the cached thread
 * for the inbox notification ID you passed to it, without any fetching or waterfalls.
 *
 * @example
 * const thread = useInboxNotificationThread("in_xxx");
 */
declare const _useInboxNotificationThread: TypedBundle$1["useInboxNotificationThread"];
/**
 * Returns user info from a given user ID.
 *
 * @example
 * const { user, error, isLoading } = useUser("user-id");
 */
declare const _useUser: TypedBundle$1["useUser"];
/**
 * Returns user info from a given user ID.
 *
 * @example
 * const { user } = useUser("user-id");
 */
declare const _useUserSuspense: TypedBundle$1["suspense"]["useUser"];
/**
 * @experimental
 *
 * This hook is experimental and could be removed or changed at any time!
 * Do not use unless explicitly recommended by the Liveblocks team.
 *
 * WARNING:
 * Please note that this hook currently returns all threads by most recently
 * updated threads first. This is inconsistent with the default sort order of
 * the useThreads() hook, which returns them in chronological order (by
 * creation date). In the final version, we will make these hooks behave
 * consistently, so expect that in the final version, you'll have to explicitly
 * specify the sort order to be by most recently updated first somehow.
 * The final API for that is still TBD.
 */
declare const _useUserThreads_experimental: TypedBundle$1["useUserThreads_experimental"];
/**
 * @experimental
 *
 * This hook is experimental and could be removed or changed at any time!
 * Do not use unless explicitly recommended by the Liveblocks team.
 *
 * WARNING:
 * Please note that this hook currently returns all threads by most recently
 * updated threads first. This is inconsistent with the default sort order of
 * the useThreads() hook, which returns them in chronological order (by
 * creation date). In the final version, we will make these hooks behave
 * consistently, so expect that in the final version, you'll have to explicitly
 * specify the sort order to be by most recently updated first somehow.
 * The final API for that is still TBD.
 */
declare const _useUserThreadsSuspense_experimental: TypedBundle$1["suspense"]["useUserThreads_experimental"];

/**
 * Raw access to the React context where the RoomProvider stores the current
 * room. Exposed for advanced use cases only.
 *
 * @private This is a private/advanced API. Do not rely on it.
 */
declare const RoomContext: React$1.Context<OpaqueRoom | null>;

/**
 * Returns the current connection status for the Room, and triggers
 * a re-render whenever it changes. Can be used to render a status badge.
 */
declare function useStatus(): Status;
/**
 * Returns the current storage status for the Room, and triggers
 * a re-render whenever it changes. Can be used to render a "Saving..."
 * indicator.
 */
declare function useStorageStatus(options?: UseStorageStatusOptions): StorageStatus$1;
/**
 * @deprecated It's recommended to use `useMutation` for writing to Storage,
 * which will automatically batch all mutations.
 *
 * Returns a function that batches modifications made during the given function.
 * All the modifications are sent to other clients in a single message.
 * All the modifications are merged in a single history item (undo/redo).
 * All the subscribers are called only after the batch is over.
 */
declare function useBatch<T>(): (callback: () => T) => T;
/**
 * Get informed when reconnecting to the Liveblocks servers is taking
 * longer than usual. This typically is a sign of a client that has lost
 * internet connectivity.
 *
 * This isn't problematic (because the Liveblocks client is still trying to
 * reconnect), but it's typically a good idea to inform users about it if
 * the connection takes too long to recover.
 *
 * @example
 * useLostConnectionListener(event => {
 *   if (event === 'lost') {
 *     toast.warn('Reconnecting to the Liveblocks servers is taking longer than usual...')
 *   } else if (event === 'failed') {
 *     toast.warn('Reconnecting to the Liveblocks servers failed.')
 *   } else if (event === 'restored') {
 *     toast.clear();
 *   }
 * })
 */
declare function useLostConnectionListener(callback: (event: LostConnectionEvent) => void): void;
/**
 * useErrorListener is a React hook that allows you to respond to potential room
 * connection errors.
 *
 * @example
 * useErrorListener(er => {
 *   console.error(er);
 * })
 */
declare function useErrorListener(callback: (err: LiveblocksError) => void): void;
/**
 * Returns the room.history
 */
declare function useHistory(): History;
/**
 * Returns a function that undoes the last operation executed by the current
 * client. It does not impact operations made by other clients.
 */
declare function useUndo(): () => void;
/**
 * Returns a function that redoes the last operation executed by the current
 * client. It does not impact operations made by other clients.
 */
declare function useRedo(): () => void;
/**
 * Returns whether there are any operations to undo.
 */
declare function useCanUndo(): boolean;
/**
 * Returns whether there are any operations to redo.
 */
declare function useCanRedo(): boolean;
/**
 * Returns an array of connection IDs. This matches the values you'll get by
 * using the `useOthers()` hook.
 *
 * Roughly equivalent to:
 *   useOthers((others) => others.map(other => other.connectionId), shallow)
 *
 * This is useful in particular to implement efficiently rendering components
 * for each user in the room, e.g. cursors.
 *
 * @example
 * const ids = useOthersConnectionIds();
 * // [2, 4, 7]
 */
declare function useOthersConnectionIds(): readonly number[];
/**
 * @private Internal API, do not rely on it.
 */
declare function useCommentsErrorListener<M extends BaseMetadata$1>(callback: (error: CommentsError<M>) => void): void;
/**
 * Returns a function that adds a comment to a thread.
 *
 * @example
 * const createComment = useCreateComment();
 * createComment({ threadId: "th_xxx", body: {} });
 */
declare function useCreateComment(): (options: CreateCommentOptions) => CommentData$1;
/**
 * Returns a function that edits a comment's body.
 *
 * @example
 * const editComment = useEditComment()
 * editComment({ threadId: "th_xxx", commentId: "cm_xxx", body: {} })
 */
declare function useEditComment(): (options: EditCommentOptions) => void;
/**
 * Returns a function that deletes a comment.
 * If it is the last non-deleted comment, the thread also gets deleted.
 *
 * @example
 * const deleteComment = useDeleteComment();
 * deleteComment({ threadId: "th_xxx", commentId: "cm_xxx" })
 */
declare function useDeleteComment(): ({ threadId, commentId }: DeleteCommentOptions) => void;
/**
 * Returns a function that removes a reaction on a comment.
 *
 * @example
 * const removeReaction = useRemoveReaction();
 * removeReaction({ threadId: "th_xxx", commentId: "cm_xxx", emoji: "👍" })
 */
declare function useRemoveReaction(): ({ threadId, commentId, emoji }: CommentReactionOptions) => void;
/**
 * Returns a function that marks a thread as read.
 *
 * @example
 * const markThreadAsRead = useMarkThreadAsRead();
 * markThreadAsRead("th_xxx");
 */
declare function useMarkThreadAsRead(): (threadId: string) => void;
/**
 * Returns a function that marks a thread as resolved.
 *
 * @example
 * const markThreadAsResolved = useMarkThreadAsResolved();
 * markThreadAsResolved("th_xxx");
 */
declare function useMarkThreadAsResolved(): (threadId: string) => void;
/**
 * Returns a function that marks a thread as unresolved.
 *
 * @example
 * const markThreadAsUnresolved = useMarkThreadAsUnresolved();
 * markThreadAsUnresolved("th_xxx");
 */
declare function useMarkThreadAsUnresolved(): (threadId: string) => void;
/**
 * Returns the subscription status of a thread.
 *
 * @example
 * const { status, unreadSince } = useThreadSubscription("th_xxx");
 */
declare function useThreadSubscription(threadId: string): ThreadSubscription;
/**
 * Returns the user's notification settings for the current room
 * and a function to update them.
 *
 * @example
 * const [{ settings }, updateSettings] = useRoomNotificationSettings();
 */
declare function useRoomNotificationSettings(): [
    RoomNotificationSettingsState,
    (settings: Partial<RoomNotificationSettings>) => void
];
/**
 * Returns the version data bianry for a given version
 *
 * @example
 * const {data} = useHistoryVersionData(versionId);
 */
declare function useHistoryVersionData(versionId: string): HistoryVersionDataState;
/**
 * Returns a function that updates the user's notification settings
 * for the current room.
 *
 * @example
 * const updateRoomNotificationSettings = useUpdateRoomNotificationSettings();
 * updateRoomNotificationSettings({ threads: "all" });
 */
declare function useUpdateRoomNotificationSettings(): (settings: Partial<RoomNotificationSettings>) => void;
/**
 * Returns an array of connection IDs. This matches the values you'll get by
 * using the `useOthers()` hook.
 *
 * Roughly equivalent to:
 *   useOthers((others) => others.map(other => other.connectionId), shallow)
 *
 * This is useful in particular to implement efficiently rendering components
 * for each user in the room, e.g. cursors.
 *
 * @example
 * const ids = useOthersConnectionIds();
 * // [2, 4, 7]
 */
declare function useOthersConnectionIdsSuspense(): readonly number[];
/**
 * Returns the current storage status for the Room, and triggers
 * a re-render whenever it changes. Can be used to render a "Saving..."
 * indicator.
 */
declare function useStorageStatusSuspense(options?: UseStorageStatusOptions): StorageStatusSuccess;
/**
 * Creates a RoomProvider and a set of typed hooks to use in your app. Note
 * that any RoomProvider created in this way does not need to be nested in
 * LiveblocksProvider, as it already has access to the client.
 */
declare function createRoomContext<P extends JsonObject = DP, S extends LsonObject = DS, U extends BaseUserMeta = DU, E extends Json = DE, M extends BaseMetadata$1 = DM>(client: OpaqueClient): RoomContextBundle<P, S, U, E, M>;
declare type TypedBundle = RoomContextBundle<DP, DS, DU, DE, DM>;
/**
 * Makes a Room available in the component hierarchy below.
 * Joins the room when the component is mounted, and automatically leaves
 * the room when the component is unmounted.
 */
declare const _RoomProvider: TypedBundle["RoomProvider"];
/**
 * Returns a callback that lets you broadcast custom events to other users in the room
 *
 * @example
 * const broadcast = useBroadcastEvent();
 *
 * broadcast({ type: "CUSTOM_EVENT", data: { x: 0, y: 0 } });
 */
declare const _useBroadcastEvent: TypedBundle["useBroadcastEvent"];
/**
 * Get informed when users enter or leave the room, as an event.
 *
 * @example
 * useOthersListener({ type, user, others }) => {
 *   if (type === 'enter') {
 *     // `user` has joined the room
 *   } else if (type === 'leave') {
 *     // `user` has left the room
 *   }
 * })
 */
declare const _useOthersListener: TypedBundle["useOthersListener"];
/**
 * Returns the Room of the nearest RoomProvider above in the React component
 * tree.
 */
declare const _useRoom: TypedBundle["useRoom"];
/**
 * Returns whether the hook is called within a RoomProvider context.
 *
 * @example
 * const isInsideRoom = useIsInsideRoom();
 */
declare const _useIsInsideRoom: TypedBundle["useIsInsideRoom"];
/**
 * Returns a function that adds a reaction from a comment.
 *
 * @example
 * const addReaction = useAddReaction();
 * addReaction({ threadId: "th_xxx", commentId: "cm_xxx", emoji: "👍" })
 */
declare const _useAddReaction: TypedBundle["useAddReaction"];
/**
 * Create a callback function that lets you mutate Liveblocks state.
 *
 * The first argument that gets passed into your callback will be
 * a "mutation context", which exposes the following:
 *
 *   - `storage` - The mutable Storage root.
 *                 You can mutate any Live structures with this, for example:
 *                 `storage.get('layers').get('layer1').set('fill', 'red')`
 *
 *   - `setMyPresence` - Call this with a new (partial) Presence value.
 *
 *   - `self` - A read-only version of the latest self, if you need it to
 *              compute the next state.
 *
 *   - `others` - A read-only version of the latest others list, if you
 *                need it to compute the next state.
 *
 * useMutation is like React's useCallback, except that the first argument
 * that gets passed into your callback will be a "mutation context".
 *
 * If you want get access to the immutable root somewhere in your mutation,
 * you can use `storage.ToImmutable()`.
 *
 * @example
 * const fillLayers = useMutation(
 *   ({ storage }, color: Color) => {
 *     ...
 *   },
 *   [],
 * );
 *
 * fillLayers('red');
 *
 * const deleteLayers = useMutation(
 *   ({ storage }) => {
 *     ...
 *   },
 *   [],
 * );
 *
 * deleteLayers();
 */
declare const _useMutation: TypedBundle["useMutation"];
/**
 * Returns a function that creates a thread with an initial comment, and optionally some metadata.
 *
 * @example
 * const createThread = useCreateThread();
 * createThread({ body: {}, metadata: {} });
 */
declare const _useCreateThread: TypedBundle["useCreateThread"];
/**
 * Returns a function that deletes a thread and its associated comments.
 * Only the thread creator can delete a thread, it will throw otherwise.
 *
 * @example
 * const deleteThread = useDeleteThread();
 * deleteThread("th_xxx");
 */
declare const _useDeleteThread: TypedBundle["useDeleteThread"];
/**
 * Returns a function that edits a thread's metadata.
 * To delete an existing metadata property, set its value to `null`.
 *
 * @example
 * const editThreadMetadata = useEditThreadMetadata();
 * editThreadMetadata({ threadId: "th_xxx", metadata: {} })
 */
declare const _useEditThreadMetadata: TypedBundle["useEditThreadMetadata"];
/**
 * useEventListener is a React hook that allows you to respond to events broadcast
 * by other users in the room.
 *
 * The `user` argument will indicate which `User` instance sent the message.
 * This will be equal to one of the others in the room, but it can be `null`
 * in case this event was broadcasted from the server.
 *
 * @example
 * useEventListener(({ event, user, connectionId }) => {
 * //                         ^^^^ Will be Client A
 *   if (event.type === "CUSTOM_EVENT") {
 *     // Do something
 *   }
 * });
 */
declare const _useEventListener: TypedBundle["useEventListener"];
/**
 * Returns the presence of the current user of the current room, and a function to update it.
 * It is different from the setState function returned by the useState hook from React.
 * You don't need to pass the full presence object to update it.
 *
 * @example
 * const [myPresence, updateMyPresence] = useMyPresence();
 * updateMyPresence({ x: 0 });
 * updateMyPresence({ y: 0 });
 *
 * // At the next render, "myPresence" will be equal to "{ x: 0, y: 0 }"
 */
declare const _useMyPresence: TypedBundle["useMyPresence"];
/**
 * Related to useOthers(), but optimized for selecting only "subsets" of
 * others. This is useful for performance reasons in particular, because
 * selecting only a subset of users also means limiting the number of
 * re-renders that will be triggered.
 *
 * @example
 * const avatars = useOthersMapped(user => user.info.avatar);
 * //    ^^^^^^^
 * //    { connectionId: number; data: string }[]
 *
 * The selector function you pass to useOthersMapped() is called an "item
 * selector", and operates on a single user at a time. If you provide an
 * (optional) "item comparison" function, it will be used to compare each
 * item pairwise.
 *
 * For example, to select multiple properties:
 *
 * @example
 * const avatarsAndCursors = useOthersMapped(
 *   user => [u.info.avatar, u.presence.cursor],
 *   shallow,  // 👈
 * );
 */
declare const _useOthersMapped: TypedBundle["useOthersMapped"];
/**
 * Related to useOthers(), but optimized for selecting only "subsets" of
 * others. This is useful for performance reasons in particular, because
 * selecting only a subset of users also means limiting the number of
 * re-renders that will be triggered.
 *
 * @example
 * const avatars = useOthersMapped(user => user.info.avatar);
 * //    ^^^^^^^
 * //    { connectionId: number; data: string }[]
 *
 * The selector function you pass to useOthersMapped() is called an "item
 * selector", and operates on a single user at a time. If you provide an
 * (optional) "item comparison" function, it will be used to compare each
 * item pairwise.
 *
 * For example, to select multiple properties:
 *
 * @example
 * const avatarsAndCursors = useOthersMapped(
 *   user => [u.info.avatar, u.presence.cursor],
 *   shallow,  // 👈
 * );
 */
declare const _useOthersMappedSuspense: TypedBundle["suspense"]["useOthersMapped"];
/**
 * Returns the threads within the current room.
 *
 * @example
 * const { threads, error, isLoading } = useThreads();
 */
declare const _useThreads: TypedBundle["useThreads"];
/**
 * Returns the threads within the current room.
 *
 * @example
 * const { threads } = useThreads();
 */
declare const _useThreadsSuspense: TypedBundle["suspense"]["useThreads"];
/**
 * (Private beta) Returns a history of versions of the current room.
 *
 * @example
 * const { versions, error, isLoading } = useHistoryVersions();
 */
declare const _useHistoryVersions: TypedBundle["useHistoryVersions"];
/**
 * (Private beta) Returns a history of versions of the current room.
 *
 * @example
 * const { versions } = useHistoryVersions();
 */
declare const _useHistoryVersionsSuspense: TypedBundle["suspense"]["useHistoryVersions"];
/**
 * Given a connection ID (as obtained by using `useOthersConnectionIds`), you
 * can call this selector deep down in your component stack to only have the
 * component re-render if properties for this particular user change.
 *
 * @example
 * // Returns only the selected values re-renders whenever that selection changes)
 * const { x, y } = useOther(2, user => user.presence.cursor);
 */
declare const _useOther: TypedBundle["useOther"];
/**
 * Returns an array with information about all the users currently connected in
 * the room (except yourself).
 *
 * @example
 * const others = useOthers();
 *
 * // Example to map all cursors in JSX
 * return (
 *   <>
 *     {others.map((user) => {
 *        if (user.presence.cursor == null) {
 *          return null;
 *        }
 *        return <Cursor key={user.connectionId} cursor={user.presence.cursor} />
 *      })}
 *   </>
 * )
 */
declare function _useOthers(): readonly User<DP, DU>[];
/**
 * Extract arbitrary data based on all the users currently connected in the
 * room (except yourself).
 *
 * The selector function will get re-evaluated any time a user enters or
 * leaves the room, as well as whenever their presence data changes.
 *
 * The component that uses this hook will automatically re-render if your
 * selector function returns a different value from its previous run.
 *
 * By default `useOthers()` uses strict `===` to check for equality. Take
 * extra care when returning a computed object or list, for example when you
 * return the result of a .map() or .filter() call from the selector. In
 * those cases, you'll probably want to use a `shallow` comparison check.
 *
 * @example
 * const avatars = useOthers(users => users.map(u => u.info.avatar), shallow);
 * const cursors = useOthers(users => users.map(u => u.presence.cursor), shallow);
 * const someoneIsTyping = useOthers(users => users.some(u => u.presence.isTyping));
 *
 */
declare function _useOthers<T>(selector: (others: readonly User<DP, DU>[]) => T, isEqual?: (prev: T, curr: T) => boolean): T;
/**
 * Given a connection ID (as obtained by using `useOthersConnectionIds`), you
 * can call this selector deep down in your component stack to only have the
 * component re-render if properties for this particular user change.
 *
 * @example
 * // Returns only the selected values re-renders whenever that selection changes)
 * const { x, y } = useOther(2, user => user.presence.cursor);
 */
declare const _useOtherSuspense: TypedBundle["suspense"]["useOther"];
/**
 * Returns an array with information about all the users currently connected in
 * the room (except yourself).
 *
 * @example
 * const others = useOthers();
 *
 * // Example to map all cursors in JSX
 * return (
 *   <>
 *     {others.map((user) => {
 *        if (user.presence.cursor == null) {
 *          return null;
 *        }
 *        return <Cursor key={user.connectionId} cursor={user.presence.cursor} />
 *      })}
 *   </>
 * )
 */
declare function _useOthersSuspense(): readonly User<DP, DU>[];
/**
 * Extract arbitrary data based on all the users currently connected in the
 * room (except yourself).
 *
 * The selector function will get re-evaluated any time a user enters or
 * leaves the room, as well as whenever their presence data changes.
 *
 * The component that uses this hook will automatically re-render if your
 * selector function returns a different value from its previous run.
 *
 * By default `useOthers()` uses strict `===` to check for equality. Take
 * extra care when returning a computed object or list, for example when you
 * return the result of a .map() or .filter() call from the selector. In
 * those cases, you'll probably want to use a `shallow` comparison check.
 *
 * @example
 * const avatars = useOthers(users => users.map(u => u.info.avatar), shallow);
 * const cursors = useOthers(users => users.map(u => u.presence.cursor), shallow);
 * const someoneIsTyping = useOthers(users => users.some(u => u.presence.isTyping));
 *
 */
declare function _useOthersSuspense<T>(selector: (others: readonly User<DP, DU>[]) => T, isEqual?: (prev: T, curr: T) => boolean): T;
/**
 * Extract arbitrary data from the Liveblocks Storage state, using an
 * arbitrary selector function.
 *
 * The selector function will get re-evaluated any time something changes in
 * Storage. The value returned by your selector function will also be the
 * value returned by the hook.
 *
 * The `root` value that gets passed to your selector function is
 * a immutable/readonly version of your Liveblocks storage root.
 *
 * The component that uses this hook will automatically re-render if the
 * returned value changes.
 *
 * By default `useStorage()` uses strict `===` to check for equality. Take
 * extra care when returning a computed object or list, for example when you
 * return the result of a .map() or .filter() call from the selector. In
 * those cases, you'll probably want to use a `shallow` comparison check.
 */
declare const _useStorage: TypedBundle["useStorage"];
/**
 * Extract arbitrary data from the Liveblocks Storage state, using an
 * arbitrary selector function.
 *
 * The selector function will get re-evaluated any time something changes in
 * Storage. The value returned by your selector function will also be the
 * value returned by the hook.
 *
 * The `root` value that gets passed to your selector function is
 * a immutable/readonly version of your Liveblocks storage root.
 *
 * The component that uses this hook will automatically re-render if the
 * returned value changes.
 *
 * By default `useStorage()` uses strict `===` to check for equality. Take
 * extra care when returning a computed object or list, for example when you
 * return the result of a .map() or .filter() call from the selector. In
 * those cases, you'll probably want to use a `shallow` comparison check.
 */
declare const _useStorageSuspense: TypedBundle["suspense"]["useStorage"];
/**
 * Gets the current user once it is connected to the room.
 *
 * @example
 * const me = useSelf();
 * if (me !== null) {
 *   const { x, y } = me.presence.cursor;
 * }
 */
declare function _useSelf(): User<DP, DU> | null;
/**
 * Extract arbitrary data based on the current user.
 *
 * The selector function will get re-evaluated any time your presence data
 * changes.
 *
 * The component that uses this hook will automatically re-render if your
 * selector function returns a different value from its previous run.
 *
 * By default `useSelf()` uses strict `===` to check for equality. Take extra
 * care when returning a computed object or list, for example when you return
 * the result of a .map() or .filter() call from the selector. In those
 * cases, you'll probably want to use a `shallow` comparison check.
 *
 * Will return `null` while Liveblocks isn't connected to a room yet.
 *
 * @example
 * const cursor = useSelf(me => me.presence.cursor);
 * if (cursor !== null) {
 *   const { x, y } = cursor;
 * }
 *
 */
declare function _useSelf<T>(selector: (me: User<DP, DU>) => T, isEqual?: (prev: T, curr: T) => boolean): T | null;
/**
 * Gets the current user once it is connected to the room.
 *
 * @example
 * const me = useSelf();
 * const { x, y } = me.presence.cursor;
 */
declare function _useSelfSuspense(): User<DP, DU>;
/**
 * Extract arbitrary data based on the current user.
 *
 * The selector function will get re-evaluated any time your presence data
 * changes.
 *
 * The component that uses this hook will automatically re-render if your
 * selector function returns a different value from its previous run.
 *
 * By default `useSelf()` uses strict `===` to check for equality. Take extra
 * care when returning a computed object or list, for example when you return
 * the result of a .map() or .filter() call from the selector. In those
 * cases, you'll probably want to use a `shallow` comparison check.
 *
 * @example
 * const cursor = useSelf(me => me.presence.cursor);
 * const { x, y } = cursor;
 *
 */
declare function _useSelfSuspense<T>(selector: (me: User<DP, DU>) => T, isEqual?: (prev: T, curr: T) => boolean): T;
/**
 * Returns the mutable (!) Storage root. This hook exists for
 * backward-compatible reasons.
 *
 * @example
 * const [root] = useStorageRoot();
 */
declare const _useStorageRoot: TypedBundle["useStorageRoot"];
/**
 * useUpdateMyPresence is similar to useMyPresence but it only returns the function to update the current user presence.
 * If you don't use the current user presence in your component, but you need to update it (e.g. live cursor), it's better to use useUpdateMyPresence to avoid unnecessary renders.
 *
 * @example
 * const updateMyPresence = useUpdateMyPresence();
 * updateMyPresence({ x: 0 });
 * updateMyPresence({ y: 0 });
 *
 * // At the next render, the presence of the current user will be equal to "{ x: 0, y: 0 }"
 */
declare const _useUpdateMyPresence: TypedBundle["useUpdateMyPresence"];

export { useOthersConnectionIds as $, _useIsInsideRoom as A, useLostConnectionListener as B, ClientSideSuspense as C, useMarkThreadAsRead as D, _useMutation as E, _useMyPresence as F, _useOthersListener as G, useRedo as H, useRemoveReaction as I, _useRoom as J, useRoomNotificationSettings as K, LiveblocksProvider as L, type MutationContext as M, useStatus as N, _useStorageRoot as O, useThreadSubscription as P, useUndo as Q, RoomContext as R, _useUpdateMyPresence as S, useUpdateRoomNotificationSettings as T, type UseStorageStatusOptions as U, useHistoryVersionData as V, useCommentsErrorListener as W, CreateThreadError as X, _useOther as Y, _useOthers as Z, _useInboxNotificationThread as _, type UseThreadsOptions as a, _useOthersMapped as a0, _useSelf as a1, _useStorage as a2, useStorageStatus as a3, _useThreads as a4, _useHistoryVersions as a5, useInboxNotifications as a6, _useUserThreads_experimental as a7, useRoomInfo as a8, useUnreadInboxNotificationsCount as a9, _useUser as aa, getUmbrellaStoreForClient as ab, selectThreads as ac, _useOtherSuspense as ad, _useOthersSuspense as ae, useOthersConnectionIdsSuspense as af, _useOthersMappedSuspense as ag, _useSelfSuspense as ah, _useStorageSuspense as ai, useStorageStatusSuspense as aj, _useThreadsSuspense as ak, _useHistoryVersionsSuspense as al, useInboxNotificationsSuspense as am, useRoomInfoSuspense as an, useUnreadInboxNotificationsCountSuspense as ao, _useUserSuspense as ap, _useUserThreadsSuspense_experimental as aq, ClientContext as b, createLiveblocksContext as c, useMarkAllInboxNotificationsAsRead as d, useMarkInboxNotificationAsRead as e, useDeleteAllInboxNotifications as f, useDeleteInboxNotification as g, createRoomContext as h, _RoomProvider as i, _useAddReaction as j, useBatch as k, _useBroadcastEvent as l, useCanRedo as m, useCanUndo as n, useCreateComment as o, _useCreateThread as p, useDeleteComment as q, _useDeleteThread as r, useEditComment as s, _useEditThreadMetadata as t, useClient as u, useMarkThreadAsResolved as v, useMarkThreadAsUnresolved as w, useErrorListener as x, _useEventListener as y, useHistory as z };
