// src/version.ts
var PKG_NAME = "@liveblocks/react";
var PKG_VERSION = "2.7.1";
var PKG_FORMAT = "esm";

// src/ClientSideSuspense.tsx
import * as React from "react";
function ClientSideSuspense(props) {
  const [mounted, setMounted] = React.useState(false);
  React.useEffect(() => {
    setMounted(true);
  }, []);
  return /* @__PURE__ */ React.createElement(React.Suspense, { fallback: props.fallback }, mounted ? typeof props.children === "function" ? props.children() : props.children : props.fallback);
}

// src/contexts.ts
import * as React2 from "react";
var RoomContext = React2.createContext(null);
function useRoomOrNull() {
  return React2.useContext(RoomContext);
}
function useIsInsideRoom() {
  const room = useRoomOrNull();
  return room !== null;
}

// src/liveblocks.tsx
import {
  assert,
  createClient,
  kInternal,
  makePoller,
  memoizeOnSuccess,
  raise,
  shallow as shallow3,
  stringify
} from "@liveblocks/core";
import React3, {
  createContext as createContext2,
  useCallback as useCallback2,
  useContext as useContext2,
  useEffect as useEffect3,
  useMemo
} from "react";
import { useSyncExternalStore } from "use-sync-external-store/shim/index.js";
import { useSyncExternalStoreWithSelector } from "use-sync-external-store/shim/with-selector.js";

// src/lib/compare.ts
function byFirstCreated(a, b) {
  return a.createdAt.getTime() - b.createdAt.getTime();
}
function isMoreRecentlyUpdated(a, b) {
  return byMostRecentlyUpdated(a, b) < 0;
}
function byMostRecentlyUpdated(a, b) {
  return (b.updatedAt ?? b.createdAt).getTime() - (a.updatedAt ?? a.createdAt).getTime();
}

// src/lib/guards.ts
import { isPlainObject } from "@liveblocks/core";
function isStartsWith(blob) {
  return isPlainObject(blob) && isString(blob.startsWith);
}
function isString(value) {
  return typeof value === "string";
}

// src/lib/querying.ts
function makeThreadsFilter(query) {
  return (thread) => matchesQuery(thread, query) && matchesMetadata(thread, query);
}
function matchesQuery(thread, q) {
  return q.resolved === void 0 || thread.resolved === q.resolved;
}
function matchesMetadata(thread, q) {
  const metadata = thread.metadata;
  return q.metadata === void 0 || Object.entries(q.metadata).every(
    ([key, op]) => (
      // Boolean logic: op? => value matches the operator
      op === void 0 || matchesOperator(metadata[key], op)
    )
  );
}
function matchesOperator(value, op) {
  if (isStartsWith(op)) {
    return isString(value) && value.startsWith(op.startsWith);
  } else {
    return value === op;
  }
}

// src/lib/retry-error.ts
import { wait } from "@liveblocks/core";
var MAX_ERROR_RETRY_COUNT = 5;
var ERROR_RETRY_INTERVAL = 5e3;
function retryError(action, retryCount) {
  if (retryCount >= MAX_ERROR_RETRY_COUNT) return;
  const timeout = Math.pow(2, retryCount) * ERROR_RETRY_INTERVAL;
  setTimeout(() => {
    void action();
  }, timeout);
}
async function autoRetry(promiseFn, maxTries, backoff) {
  const fallbackBackoff = backoff.length > 0 ? backoff[backoff.length - 1] : 0;
  let attempt = 0;
  while (true) {
    attempt++;
    const promise = promiseFn();
    try {
      return await promise;
    } catch (err) {
      if (attempt >= maxTries) {
        throw new Error(`Failed after ${maxTries} attempts: ${String(err)}`);
      }
    }
    const delay = backoff[attempt - 1] ?? fallbackBackoff;
    await wait(delay);
  }
}

// src/lib/shallow2.ts
import { isPlainObject as isPlainObject2, shallow } from "@liveblocks/core";
function shallow2(a, b) {
  if (!isPlainObject2(a) || !isPlainObject2(b)) {
    return shallow(a, b);
  }
  const keysA = Object.keys(a);
  if (keysA.length !== Object.keys(b).length) {
    return false;
  }
  return keysA.every(
    (key) => Object.prototype.hasOwnProperty.call(b, key) && shallow(a[key], b[key])
  );
}

// src/lib/use-initial.ts
import { useCallback, useReducer } from "react";

// src/lib/use-latest.ts
import { useEffect as useEffect2, useRef } from "react";
function useLatest(value) {
  const ref = useRef(value);
  useEffect2(() => {
    ref.current = value;
  }, [value]);
  return ref;
}

// src/lib/use-initial.ts
var noop = (state) => state;
function useInitial(value) {
  return useReducer(noop, value)[0];
}
function useInitialUnlessFunction(latestValue) {
  const frozenValue = useInitial(latestValue);
  if (typeof frozenValue === "function") {
    const ref = useLatest(latestValue);
    return useCallback((...args) => ref.current(...args), [
      ref
    ]);
  } else {
    return frozenValue;
  }
}

// src/lib/use-polyfill.ts
var use = (
  // React.use ||
  (promise) => {
    if (promise.status === "pending") {
      throw promise;
    } else if (promise.status === "fulfilled") {
      return promise.value;
    } else if (promise.status === "rejected") {
      throw promise.reason;
    } else {
      promise.status = "pending";
      promise.then(
        (v) => {
          promise.status = "fulfilled";
          promise.value = v;
        },
        (e) => {
          promise.status = "rejected";
          promise.reason = e;
        }
      );
      throw promise;
    }
  }
);

// src/umbrella-store.ts
import {
  compactObject,
  console as console2,
  createStore,
  mapValues,
  nanoid
} from "@liveblocks/core";
var UmbrellaStore = class {
  constructor() {
    this._prevState = null;
    this._stateCached = null;
    this._store = createStore({
      rawThreadsById: {},
      queries: {},
      optimisticUpdates: [],
      inboxNotificationsById: {},
      notificationSettingsByRoomId: {},
      versionsByRoomId: {}
    });
    this.getThreads = this.getThreads.bind(this);
    this.getInboxNotifications = this.getInboxNotifications.bind(this);
    this.getNotificationSettings = this.getNotificationSettings.bind(this);
    this.getVersions = this.getVersions.bind(this);
    this.subscribeThreads = this.subscribeThreads.bind(this);
    this.subscribeInboxNotifications = this.subscribeInboxNotifications.bind(this);
    this.subscribeNotificationSettings = this.subscribeNotificationSettings.bind(this);
    this.subscribeVersions = this.subscribeVersions.bind(this);
    this._hasOptimisticUpdates = this._hasOptimisticUpdates.bind(this);
    this._subscribeOptimisticUpdates = this._subscribeOptimisticUpdates.bind(this);
  }
  get() {
    const rawState = this._store.get();
    if (this._prevState !== rawState || this._stateCached === null) {
      this._prevState = rawState;
      this._stateCached = applyOptimisticUpdates(rawState);
    }
    return this._stateCached;
  }
  getThreads() {
    return this.get();
  }
  getInboxNotifications() {
    return this.get();
  }
  getNotificationSettings() {
    return this.get();
  }
  getVersions() {
    return this.get();
  }
  /**
   * @private Only used by the E2E test suite.
   */
  _hasOptimisticUpdates() {
    return this._store.get().optimisticUpdates.length > 0;
  }
  subscribe(callback) {
    return this._store.subscribe(callback);
  }
  /**
   * @private Only used by the E2E test suite.
   */
  _subscribeOptimisticUpdates(callback) {
    return this.subscribe(callback);
  }
  subscribeThreads(callback) {
    return this.subscribe(callback);
  }
  subscribeInboxNotifications(callback) {
    return this.subscribe(callback);
  }
  subscribeNotificationSettings(callback) {
    return this.subscribe(callback);
  }
  subscribeVersions(callback) {
    return this.subscribe(callback);
  }
  // Direct low-level cache mutations ------------------------------------------------- {{{
  updateThreadsCache(mapFn) {
    this._store.set((state) => {
      const threads = mapFn(state.rawThreadsById);
      return threads !== state.rawThreadsById ? { ...state, rawThreadsById: threads } : state;
    });
  }
  updateInboxNotificationsCache(mapFn) {
    this._store.set((state) => {
      const inboxNotifications = mapFn(state.inboxNotificationsById);
      return inboxNotifications !== state.inboxNotificationsById ? { ...state, inboxNotificationsById: inboxNotifications } : state;
    });
  }
  setNotificationSettings(roomId, settings) {
    this._store.set((state) => ({
      ...state,
      notificationSettingsByRoomId: {
        ...state.notificationSettingsByRoomId,
        [roomId]: settings
      }
    }));
  }
  setVersions(roomId, versions) {
    this._store.set((state) => ({
      ...state,
      versionsByRoomId: {
        ...state.versionsByRoomId,
        [roomId]: versions
      }
    }));
  }
  setQueryState(queryKey, queryState) {
    this._store.set((state) => ({
      ...state,
      queries: {
        ...state.queries,
        [queryKey]: queryState
      }
    }));
  }
  updateOptimisticUpdatesCache(mapFn) {
    this._store.set((state) => ({
      ...state,
      optimisticUpdates: mapFn(state.optimisticUpdates)
    }));
  }
  // ---------------------------------------------------------------------------------- }}}
  /** @internal - Only call this method from unit tests. */
  force_set(callback) {
    return this._store.set(callback);
  }
  /**
   * Updates an existing inbox notification with a new value, replacing the
   * corresponding optimistic update.
   *
   * This will not update anything if the inbox notification ID isn't found in
   * the cache.
   */
  updateInboxNotification(inboxNotificationId, optimisticUpdateId, callback) {
    this._store.batch(() => {
      this.removeOptimisticUpdate(optimisticUpdateId);
      this.updateInboxNotificationsCache((cache) => {
        const existing = cache[inboxNotificationId];
        if (!existing) {
          return cache;
        }
        const inboxNotifications = {
          ...cache,
          [inboxNotificationId]: callback(existing)
        };
        return inboxNotifications;
      });
    });
  }
  /**
   * Updates *all* inbox notifications by running a mapper function over all of
   * them, replacing the corresponding optimistic update.
   */
  updateAllInboxNotifications(optimisticUpdateId, mapFn) {
    this._store.batch(() => {
      this.removeOptimisticUpdate(optimisticUpdateId);
      this.updateInboxNotificationsCache((cache) => mapValues(cache, mapFn));
    });
  }
  /**
   * Deletes an existing inbox notification, replacing the corresponding
   * optimistic update.
   */
  deleteInboxNotification(inboxNotificationId, optimisticUpdateId) {
    this._store.batch(() => {
      this.removeOptimisticUpdate(optimisticUpdateId);
      this.updateInboxNotificationsCache((cache) => {
        const { [inboxNotificationId]: removed, ...newCache } = cache;
        return removed === void 0 ? cache : newCache;
      });
    });
  }
  /**
   * Deletes *all* inbox notifications, replacing the corresponding optimistic
   * update.
   */
  deleteAllInboxNotifications(optimisticUpdateId) {
    this._store.batch(() => {
      this.removeOptimisticUpdate(optimisticUpdateId);
      this.updateInboxNotificationsCache(() => ({}));
    });
  }
  /**
   * Creates an new thread, replacing the corresponding optimistic update.
   */
  createThread(optimisticUpdateId, thread) {
    this._store.batch(() => {
      this.removeOptimisticUpdate(optimisticUpdateId);
      this.updateThreadsCache((cache) => ({ ...cache, [thread.id]: thread }));
    });
  }
  /**
   * Updates an existing thread with a new value, replacing the corresponding
   * optimistic update.
   *
   * This will not update anything if:
   * - The thread ID isn't found in the cache; or
   * - The thread ID was already deleted from the cache; or
   * - The thread ID in the cache was updated more recently than the optimistic
   *   update's timestamp (if given)
   */
  updateThread(threadId, optimisticUpdateId, callback, updatedAt) {
    this._store.batch(() => {
      if (optimisticUpdateId !== null) {
        this.removeOptimisticUpdate(optimisticUpdateId);
      }
      this.updateThreadsCache((cache) => {
        const existing = cache[threadId];
        if (!existing) {
          return cache;
        }
        if (existing.deletedAt !== void 0) {
          return cache;
        }
        if (!!updatedAt && !!existing.updatedAt && existing.updatedAt > updatedAt) {
          return cache;
        }
        return { ...cache, [threadId]: callback(existing) };
      });
    });
  }
  patchThread(threadId, optimisticUpdateId, patch, updatedAt) {
    return this.updateThread(
      threadId,
      optimisticUpdateId,
      (thread) => ({ ...thread, ...compactObject(patch) }),
      updatedAt
    );
  }
  addReaction(threadId, optimisticUpdateId, commentId, reaction, createdAt) {
    this.updateThread(
      threadId,
      optimisticUpdateId,
      (thread) => applyAddReaction(thread, commentId, reaction),
      createdAt
    );
  }
  removeReaction(threadId, optimisticUpdateId, commentId, emoji, userId, removedAt) {
    this.updateThread(
      threadId,
      optimisticUpdateId,
      (thread) => applyRemoveReaction(thread, commentId, emoji, userId, removedAt),
      removedAt
    );
  }
  /**
   * Soft-deletes an existing thread by setting its `deletedAt` value,
   * replacing the corresponding optimistic update.
   *
   * This will not update anything if:
   * - The thread ID isn't found in the cache; or
   * - The thread ID was already deleted from the cache
   */
  deleteThread(threadId, optimisticUpdateId) {
    return this.updateThread(
      threadId,
      optimisticUpdateId,
      // A deletion is actually an update of the deletedAt property internally
      (thread) => ({ ...thread, updatedAt: /* @__PURE__ */ new Date(), deletedAt: /* @__PURE__ */ new Date() })
    );
  }
  /**
   * Creates an existing comment and ensures the associated notification is
   * updated correctly, replacing the corresponding optimistic update.
   */
  createComment(newComment, optimisticUpdateId) {
    this._store.batch(() => {
      this.removeOptimisticUpdate(optimisticUpdateId);
      const existingThread = this._store.get().rawThreadsById[newComment.threadId];
      if (!existingThread) {
        return;
      }
      this.updateThreadsCache((cache) => ({
        ...cache,
        [newComment.threadId]: applyUpsertComment(existingThread, newComment)
      }));
      this.updateInboxNotificationsCache((cache) => {
        const existingNotification = Object.values(cache).find(
          (notification) => notification.kind === "thread" && notification.threadId === newComment.threadId
        );
        if (!existingNotification) {
          return cache;
        }
        return {
          ...cache,
          [existingNotification.id]: {
            ...existingNotification,
            notifiedAt: newComment.createdAt,
            readAt: newComment.createdAt
          }
        };
      });
    });
  }
  editComment(threadId, optimisticUpdateId, editedComment) {
    return this.updateThread(
      threadId,
      optimisticUpdateId,
      (thread) => applyUpsertComment(thread, editedComment)
    );
  }
  deleteComment(threadId, optimisticUpdateId, commentId, deletedAt) {
    return this.updateThread(
      threadId,
      optimisticUpdateId,
      (thread) => applyDeleteComment(thread, commentId, deletedAt),
      deletedAt
    );
  }
  updateThreadAndNotification(thread, inboxNotification) {
    this._store.batch(() => {
      this.updateThreadsCache((cache) => {
        const existingThread = cache[thread.id];
        return existingThread === void 0 || isMoreRecentlyUpdated(thread, existingThread) ? { ...cache, [thread.id]: thread } : cache;
      });
      if (inboxNotification !== void 0) {
        this.updateInboxNotificationsCache((cache) => ({
          ...cache,
          [inboxNotification.id]: inboxNotification
        }));
      }
    });
  }
  updateThreadsAndNotifications(threads, inboxNotifications, deletedThreads, deletedInboxNotifications, queryKey) {
    this._store.batch(() => {
      this.updateThreadsCache(
        (cache) => applyThreadUpdates(cache, {
          newThreads: threads,
          deletedThreads
        })
      );
      this.updateInboxNotificationsCache(
        (cache) => applyNotificationsUpdates(cache, {
          newInboxNotifications: inboxNotifications,
          deletedNotifications: deletedInboxNotifications
        })
      );
      if (queryKey !== void 0) {
        this.setQueryOK(queryKey);
      }
    });
  }
  /**
   * Updates existing notification setting for a room with a new value,
   * replacing the corresponding optimistic update.
   */
  updateRoomInboxNotificationSettings2(roomId, optimisticUpdateId, settings) {
    this._store.batch(() => {
      this.removeOptimisticUpdate(optimisticUpdateId);
      this.setNotificationSettings(roomId, settings);
    });
  }
  updateRoomInboxNotificationSettings(roomId, settings, queryKey) {
    this._store.batch(() => {
      this.setQueryOK(queryKey);
      this.setNotificationSettings(roomId, settings);
    });
  }
  updateRoomVersions(roomId, versions, queryKey) {
    this._store.batch(() => {
      this.setVersions(roomId, versions);
      if (queryKey !== void 0) {
        this.setQueryOK(queryKey);
      }
    });
  }
  addOptimisticUpdate(optimisticUpdate) {
    const id = nanoid();
    const newUpdate = { ...optimisticUpdate, id };
    this.updateOptimisticUpdatesCache((cache) => [...cache, newUpdate]);
    return id;
  }
  removeOptimisticUpdate(optimisticUpdateId) {
    this.updateOptimisticUpdatesCache(
      (cache) => cache.filter((ou) => ou.id !== optimisticUpdateId)
    );
  }
  //
  // Query State APIs
  //
  setQueryLoading(queryKey) {
    this.setQueryState(queryKey, { isLoading: true });
  }
  setQueryOK(queryKey) {
    this.setQueryState(queryKey, { isLoading: false, data: void 0 });
  }
  setQueryError(queryKey, error) {
    this.setQueryState(queryKey, { isLoading: false, error });
  }
};
function applyOptimisticUpdates(state) {
  const output = {
    threads: { ...state.rawThreadsById },
    inboxNotifications: { ...state.inboxNotificationsById },
    notificationSettings: { ...state.notificationSettingsByRoomId }
  };
  for (const optimisticUpdate of state.optimisticUpdates) {
    switch (optimisticUpdate.type) {
      case "create-thread": {
        output.threads[optimisticUpdate.thread.id] = optimisticUpdate.thread;
        break;
      }
      case "edit-thread-metadata": {
        const thread = output.threads[optimisticUpdate.threadId];
        if (thread === void 0) {
          break;
        }
        if (thread.deletedAt !== void 0) {
          break;
        }
        if (thread.updatedAt !== void 0 && thread.updatedAt > optimisticUpdate.updatedAt) {
          break;
        }
        output.threads[thread.id] = {
          ...thread,
          updatedAt: optimisticUpdate.updatedAt,
          metadata: {
            ...thread.metadata,
            ...optimisticUpdate.metadata
          }
        };
        break;
      }
      case "mark-thread-as-resolved": {
        const thread = output.threads[optimisticUpdate.threadId];
        if (thread === void 0) {
          break;
        }
        if (thread.deletedAt !== void 0) {
          break;
        }
        output.threads[thread.id] = {
          ...thread,
          resolved: true
        };
        break;
      }
      case "mark-thread-as-unresolved": {
        const thread = output.threads[optimisticUpdate.threadId];
        if (thread === void 0) {
          break;
        }
        if (thread.deletedAt !== void 0) {
          break;
        }
        output.threads[thread.id] = {
          ...thread,
          resolved: false
        };
        break;
      }
      case "create-comment": {
        const thread = output.threads[optimisticUpdate.comment.threadId];
        if (thread === void 0) {
          break;
        }
        output.threads[thread.id] = applyUpsertComment(
          thread,
          optimisticUpdate.comment
        );
        const inboxNotification = Object.values(output.inboxNotifications).find(
          (notification) => notification.kind === "thread" && notification.threadId === thread.id
        );
        if (inboxNotification === void 0) {
          break;
        }
        output.inboxNotifications[inboxNotification.id] = {
          ...inboxNotification,
          notifiedAt: optimisticUpdate.comment.createdAt,
          readAt: optimisticUpdate.comment.createdAt
        };
        break;
      }
      case "edit-comment": {
        const thread = output.threads[optimisticUpdate.comment.threadId];
        if (thread === void 0) {
          break;
        }
        output.threads[thread.id] = applyUpsertComment(
          thread,
          optimisticUpdate.comment
        );
        break;
      }
      case "delete-comment": {
        const thread = output.threads[optimisticUpdate.threadId];
        if (thread === void 0) {
          break;
        }
        output.threads[thread.id] = applyDeleteComment(
          thread,
          optimisticUpdate.commentId,
          optimisticUpdate.deletedAt
        );
        break;
      }
      case "delete-thread": {
        const thread = output.threads[optimisticUpdate.threadId];
        if (thread === void 0) {
          break;
        }
        output.threads[optimisticUpdate.threadId] = {
          ...output.threads[optimisticUpdate.threadId],
          deletedAt: optimisticUpdate.deletedAt,
          updatedAt: optimisticUpdate.deletedAt,
          comments: []
        };
        break;
      }
      case "add-reaction": {
        const thread = output.threads[optimisticUpdate.threadId];
        if (thread === void 0) {
          break;
        }
        output.threads[thread.id] = applyAddReaction(
          thread,
          optimisticUpdate.commentId,
          optimisticUpdate.reaction
        );
        break;
      }
      case "remove-reaction": {
        const thread = output.threads[optimisticUpdate.threadId];
        if (thread === void 0) {
          break;
        }
        output.threads[thread.id] = applyRemoveReaction(
          thread,
          optimisticUpdate.commentId,
          optimisticUpdate.emoji,
          optimisticUpdate.userId,
          optimisticUpdate.removedAt
        );
        break;
      }
      case "mark-inbox-notification-as-read": {
        output.inboxNotifications[optimisticUpdate.inboxNotificationId] = {
          ...state.inboxNotificationsById[optimisticUpdate.inboxNotificationId],
          readAt: optimisticUpdate.readAt
        };
        break;
      }
      case "mark-all-inbox-notifications-as-read": {
        for (const id in output.inboxNotifications) {
          output.inboxNotifications[id] = {
            ...output.inboxNotifications[id],
            readAt: optimisticUpdate.readAt
          };
        }
        break;
      }
      case "delete-inbox-notification": {
        const {
          [optimisticUpdate.inboxNotificationId]: _,
          ...inboxNotifications
        } = output.inboxNotifications;
        output.inboxNotifications = inboxNotifications;
        break;
      }
      case "delete-all-inbox-notifications": {
        output.inboxNotifications = {};
        break;
      }
      case "update-notification-settings": {
        output.notificationSettings[optimisticUpdate.roomId] = {
          ...output.notificationSettings[optimisticUpdate.roomId],
          ...optimisticUpdate.settings
        };
      }
    }
  }
  const cleanedThreads = (
    // Don't expose any soft-deleted threads
    Object.values(output.threads).filter(
      (thread) => !thread.deletedAt
    )
  );
  const cleanedNotifications = (
    // Sort so that the most recent notifications are first
    Object.values(output.inboxNotifications).sort(
      (a, b) => b.notifiedAt.getTime() - a.notifiedAt.getTime()
    )
  );
  return {
    inboxNotifications: cleanedNotifications,
    inboxNotificationsById: output.inboxNotifications,
    notificationSettingsByRoomId: output.notificationSettings,
    queries: state.queries,
    threads: cleanedThreads,
    threadsById: output.threads,
    versionsByRoomId: state.versionsByRoomId
  };
}
function applyThreadUpdates(existingThreads, updates) {
  const updatedThreads = { ...existingThreads };
  updates.newThreads.forEach((thread) => {
    const existingThread = updatedThreads[thread.id];
    if (existingThread) {
      if (isMoreRecentlyUpdated(existingThread, thread)) {
        return;
      }
    }
    updatedThreads[thread.id] = thread;
  });
  updates.deletedThreads.forEach(({ id, deletedAt }) => {
    const existingThread = updatedThreads[id];
    if (existingThread === void 0) return;
    existingThread.deletedAt = deletedAt;
    existingThread.updatedAt = deletedAt;
    existingThread.comments = [];
  });
  return updatedThreads;
}
function applyNotificationsUpdates(existingInboxNotifications, updates) {
  const updatedInboxNotifications = { ...existingInboxNotifications };
  updates.newInboxNotifications.forEach((notification) => {
    const existingNotification = updatedInboxNotifications[notification.id];
    if (existingNotification) {
      const result = compareInboxNotifications(
        existingNotification,
        notification
      );
      if (result === 1) return;
    }
    updatedInboxNotifications[notification.id] = notification;
  });
  updates.deletedNotifications.forEach(
    ({ id }) => delete updatedInboxNotifications[id]
  );
  return updatedInboxNotifications;
}
function compareInboxNotifications(inboxNotificationA, inboxNotificationB) {
  if (inboxNotificationA.notifiedAt > inboxNotificationB.notifiedAt) {
    return 1;
  } else if (inboxNotificationA.notifiedAt < inboxNotificationB.notifiedAt) {
    return -1;
  }
  if (inboxNotificationA.readAt && inboxNotificationB.readAt) {
    return inboxNotificationA.readAt > inboxNotificationB.readAt ? 1 : inboxNotificationA.readAt < inboxNotificationB.readAt ? -1 : 0;
  } else if (inboxNotificationA.readAt || inboxNotificationB.readAt) {
    return inboxNotificationA.readAt ? 1 : -1;
  }
  return 0;
}
function applyUpsertComment(thread, comment) {
  if (thread.deletedAt !== void 0) {
    return thread;
  }
  if (comment.threadId !== thread.id) {
    console2.warn(
      `Comment ${comment.id} does not belong to thread ${thread.id}`
    );
    return thread;
  }
  const existingComment = thread.comments.find(
    (existingComment2) => existingComment2.id === comment.id
  );
  if (existingComment === void 0) {
    const updatedAt = new Date(
      Math.max(thread.updatedAt?.getTime() || 0, comment.createdAt.getTime())
    );
    const updatedThread = {
      ...thread,
      updatedAt,
      comments: [...thread.comments, comment]
    };
    return updatedThread;
  }
  if (existingComment.deletedAt !== void 0) {
    return thread;
  }
  if (existingComment.editedAt === void 0 || comment.editedAt === void 0 || existingComment.editedAt <= comment.editedAt) {
    const updatedComments = thread.comments.map(
      (existingComment2) => existingComment2.id === comment.id ? comment : existingComment2
    );
    const updatedThread = {
      ...thread,
      updatedAt: new Date(
        Math.max(
          thread.updatedAt?.getTime() || 0,
          comment.editedAt?.getTime() || comment.createdAt.getTime()
        )
      ),
      comments: updatedComments
    };
    return updatedThread;
  }
  return thread;
}
function applyDeleteComment(thread, commentId, deletedAt) {
  if (thread.deletedAt !== void 0) {
    return thread;
  }
  const existingComment = thread.comments.find(
    (comment) => comment.id === commentId
  );
  if (existingComment === void 0) {
    return thread;
  }
  if (existingComment.deletedAt !== void 0) {
    return thread;
  }
  const updatedComments = thread.comments.map(
    (comment) => comment.id === commentId ? {
      ...comment,
      deletedAt,
      body: void 0
    } : comment
  );
  if (!updatedComments.some((comment) => comment.deletedAt === void 0)) {
    return {
      ...thread,
      deletedAt,
      updatedAt: deletedAt,
      comments: []
    };
  }
  return {
    ...thread,
    updatedAt: deletedAt,
    comments: updatedComments
  };
}
function applyAddReaction(thread, commentId, reaction) {
  if (thread.deletedAt !== void 0) {
    return thread;
  }
  const existingComment = thread.comments.find(
    (comment) => comment.id === commentId
  );
  if (existingComment === void 0) {
    return thread;
  }
  if (existingComment.deletedAt !== void 0) {
    return thread;
  }
  const updatedComments = thread.comments.map(
    (comment) => comment.id === commentId ? {
      ...comment,
      reactions: upsertReaction(comment.reactions, reaction)
    } : comment
  );
  return {
    ...thread,
    updatedAt: new Date(
      Math.max(reaction.createdAt.getTime(), thread.updatedAt?.getTime() || 0)
    ),
    comments: updatedComments
  };
}
function applyRemoveReaction(thread, commentId, emoji, userId, removedAt) {
  if (thread.deletedAt !== void 0) {
    return thread;
  }
  const existingComment = thread.comments.find(
    (comment) => comment.id === commentId
  );
  if (existingComment === void 0) {
    return thread;
  }
  if (existingComment.deletedAt !== void 0) {
    return thread;
  }
  const updatedComments = thread.comments.map(
    (comment) => comment.id === commentId ? {
      ...comment,
      reactions: comment.reactions.map(
        (reaction) => reaction.emoji === emoji ? {
          ...reaction,
          users: reaction.users.filter((user) => user.id !== userId)
        } : reaction
      ).filter((reaction) => reaction.users.length > 0)
      // Remove reactions with no users left
    } : comment
  );
  return {
    ...thread,
    updatedAt: new Date(
      Math.max(removedAt.getTime(), thread.updatedAt?.getTime() || 0)
    ),
    comments: updatedComments
  };
}
function upsertReaction(reactions, reaction) {
  const existingReaction = reactions.find(
    (existingReaction2) => existingReaction2.emoji === reaction.emoji
  );
  if (existingReaction === void 0) {
    return [
      ...reactions,
      {
        emoji: reaction.emoji,
        createdAt: reaction.createdAt,
        users: [{ id: reaction.userId }]
      }
    ];
  }
  if (existingReaction.users.some((user) => user.id === reaction.userId) === false) {
    return reactions.map(
      (existingReaction2) => existingReaction2.emoji === reaction.emoji ? {
        ...existingReaction2,
        users: [...existingReaction2.users, { id: reaction.userId }]
      } : existingReaction2
    );
  }
  return reactions;
}

// src/liveblocks.tsx
var ClientContext = createContext2(null);
function missingUserError(userId) {
  return new Error(`resolveUsers didn't return anything for user '${userId}'`);
}
function missingRoomInfoError(roomId) {
  return new Error(
    `resolveRoomsInfo didn't return anything for room '${roomId}'`
  );
}
var _umbrellaStores = /* @__PURE__ */ new WeakMap();
var _extras = /* @__PURE__ */ new WeakMap();
var _bundles = /* @__PURE__ */ new WeakMap();
var POLLING_INTERVAL = 60 * 1e3;
var INBOX_NOTIFICATIONS_QUERY = "INBOX_NOTIFICATIONS";
var USER_THREADS_QUERY = "USER_THREADS";
function selectorFor_useInboxNotifications(state) {
  const query = state.queries[INBOX_NOTIFICATIONS_QUERY];
  if (query === void 0 || query.isLoading) {
    return {
      isLoading: true
    };
  }
  if (query.error !== void 0) {
    return {
      error: query.error,
      isLoading: false
    };
  }
  return {
    inboxNotifications: state.inboxNotifications,
    isLoading: false
  };
}
function selectUnreadInboxNotificationsCount(state) {
  let count = 0;
  for (const notification of state.inboxNotifications) {
    if (notification.readAt === null || notification.readAt < notification.notifiedAt) {
      count++;
    }
  }
  return count;
}
function selectorFor_useUnreadInboxNotificationsCount(state) {
  const query = state.queries[INBOX_NOTIFICATIONS_QUERY];
  if (query === void 0 || query.isLoading) {
    return {
      isLoading: true
    };
  }
  if (query.error !== void 0) {
    return {
      error: query.error,
      isLoading: false
    };
  }
  return {
    isLoading: false,
    count: selectUnreadInboxNotificationsCount(state)
  };
}
function selectorFor_useUser(state, userId) {
  if (state === void 0 || state?.isLoading) {
    return state ?? { isLoading: true };
  }
  if (state.error) {
    return state;
  }
  if (!state.data) {
    return {
      isLoading: false,
      error: missingUserError(userId)
    };
  }
  return {
    isLoading: false,
    user: state.data
  };
}
function selectorFor_useRoomInfo(state, roomId) {
  if (state === void 0 || state?.isLoading) {
    return state ?? { isLoading: true };
  }
  if (state.error) {
    return state;
  }
  if (!state.data) {
    return {
      isLoading: false,
      error: missingRoomInfoError(roomId)
    };
  }
  return {
    isLoading: false,
    info: state.data
  };
}
function selectThreads(state, options) {
  let threads = state.threads;
  if (options.roomId !== null) {
    threads = threads.filter((thread) => thread.roomId === options.roomId);
  }
  const query = options.query;
  if (query) {
    threads = threads.filter(makeThreadsFilter(query));
  }
  return threads.sort(
    options.orderBy === "last-update" ? byMostRecentlyUpdated : byFirstCreated
  );
}
function getOrCreateContextBundle(client) {
  let bundle = _bundles.get(client);
  if (!bundle) {
    bundle = makeLiveblocksContextBundle(client);
    _bundles.set(client, bundle);
  }
  return bundle;
}
function getUmbrellaStoreForClient(client) {
  let store = _umbrellaStores.get(client);
  if (!store) {
    store = new UmbrellaStore();
    _umbrellaStores.set(client, store);
  }
  return store;
}
function getExtrasForClient(client) {
  let extras = _extras.get(client);
  if (!extras) {
    extras = makeExtrasForClient(client);
    _extras.set(client, extras);
  }
  return extras;
}
function makeExtrasForClient(client) {
  const store = getUmbrellaStoreForClient(client);
  let lastRequestedAt;
  async function fetchInboxNotifications() {
    if (lastRequestedAt === void 0) {
      const result = await client.getInboxNotifications();
      store.updateThreadsAndNotifications(
        result.threads,
        result.inboxNotifications,
        [],
        [],
        INBOX_NOTIFICATIONS_QUERY
      );
      lastRequestedAt = result.requestedAt;
    } else {
      const result = await client.getInboxNotificationsSince({
        since: lastRequestedAt
      });
      store.updateThreadsAndNotifications(
        result.threads.updated,
        result.inboxNotifications.updated,
        result.threads.deleted,
        result.inboxNotifications.deleted,
        INBOX_NOTIFICATIONS_QUERY
      );
      if (lastRequestedAt < result.requestedAt) {
        lastRequestedAt = result.requestedAt;
      }
    }
  }
  let pollerSubscribers = 0;
  const poller = makePoller(async () => {
    try {
      await waitUntilInboxNotificationsLoaded();
      await fetchInboxNotifications();
    } catch (err) {
      console.warn(`Polling new inbox notifications failed: ${String(err)}`);
    }
  });
  const waitUntilInboxNotificationsLoaded = memoizeOnSuccess(async () => {
    store.setQueryLoading(INBOX_NOTIFICATIONS_QUERY);
    try {
      await autoRetry(
        () => fetchInboxNotifications(),
        5,
        [5e3, 5e3, 1e4, 15e3]
      );
    } catch (err) {
      store.setQueryError(INBOX_NOTIFICATIONS_QUERY, err);
      throw err;
    }
  });
  function loadInboxNotifications() {
    void waitUntilInboxNotificationsLoaded().catch(() => {
    });
  }
  function useEnableInboxNotificationsPolling() {
    useEffect3(() => {
      pollerSubscribers++;
      poller.start(POLLING_INTERVAL);
      return () => {
        if (pollerSubscribers <= 0) {
          console.warn(
            `Internal unexpected behavior. Cannot decrease subscriber count for query "${INBOX_NOTIFICATIONS_QUERY}"`
          );
          return;
        }
        pollerSubscribers--;
        if (pollerSubscribers <= 0) {
          poller.stop();
        }
      };
    }, []);
  }
  const userThreadsPoller = makePoller(refreshUserThreads);
  let isFetchingUserThreadsUpdates = false;
  async function refreshUserThreads() {
    const since = userThreadslastRequestedAt;
    if (since === void 0 || isFetchingUserThreadsUpdates) {
      return;
    }
    try {
      isFetchingUserThreadsUpdates = true;
      const updates = await client[kInternal].getThreadsSince({
        since
      });
      isFetchingUserThreadsUpdates = false;
      store.updateThreadsAndNotifications(
        updates.threads.updated,
        [],
        updates.threads.deleted,
        [],
        USER_THREADS_QUERY
      );
      userThreadslastRequestedAt = updates.requestedAt;
    } catch (err) {
      isFetchingUserThreadsUpdates = false;
      return;
    }
  }
  const userThreadsSubscribersByQuery = /* @__PURE__ */ new Map();
  const userThreadsRequestsByQuery = /* @__PURE__ */ new Map();
  function incrementUserThreadsQuerySubscribers(queryKey) {
    const subscribers = userThreadsSubscribersByQuery.get(queryKey) ?? 0;
    userThreadsSubscribersByQuery.set(queryKey, subscribers + 1);
    userThreadsPoller.start(POLLING_INTERVAL);
    return () => {
      const subscribers2 = userThreadsSubscribersByQuery.get(queryKey);
      if (subscribers2 === void 0 || subscribers2 <= 0) {
        console.warn(
          `Internal unexpected behavior. Cannot decrease subscriber count for query "${queryKey}"`
        );
        return;
      }
      userThreadsSubscribersByQuery.set(queryKey, subscribers2 - 1);
      let totalSubscribers = 0;
      for (const subscribers3 of userThreadsSubscribersByQuery.values()) {
        totalSubscribers += subscribers3;
      }
      if (totalSubscribers <= 0) {
        userThreadsPoller.stop();
      }
    };
  }
  let userThreadslastRequestedAt;
  async function getUserThreads(queryKey, options, { retryCount } = { retryCount: 0 }) {
    const existingRequest = userThreadsRequestsByQuery.get(queryKey);
    if (existingRequest !== void 0) return existingRequest;
    const request = client[kInternal].getThreads(options);
    userThreadsRequestsByQuery.set(queryKey, request);
    store.setQueryLoading(queryKey);
    try {
      const result = await request;
      store.updateThreadsAndNotifications(
        result.threads,
        result.inboxNotifications,
        [],
        [],
        queryKey
      );
      if (userThreadslastRequestedAt === void 0 || userThreadslastRequestedAt < result.requestedAt) {
        userThreadslastRequestedAt = result.requestedAt;
      }
      userThreadsPoller.start(POLLING_INTERVAL);
    } catch (err) {
      userThreadsRequestsByQuery.delete(queryKey);
      retryError(() => {
        void getUserThreads(queryKey, options, {
          retryCount: retryCount + 1
        });
      }, retryCount);
      store.setQueryError(queryKey, err);
    }
    return;
  }
  return {
    store,
    useEnableInboxNotificationsPolling,
    waitUntilInboxNotificationsLoaded,
    loadInboxNotifications,
    incrementUserThreadsQuerySubscribers,
    getUserThreads
  };
}
function makeLiveblocksContextBundle(client) {
  const useInboxNotificationThread2 = (inboxNotificationId) => useInboxNotificationThread_withClient(client, inboxNotificationId);
  const useMarkInboxNotificationAsRead2 = () => useMarkInboxNotificationAsRead_withClient(client);
  const useMarkAllInboxNotificationsAsRead2 = () => useMarkAllInboxNotificationsAsRead_withClient(client);
  const useDeleteInboxNotification2 = () => useDeleteInboxNotification_withClient(client);
  const useDeleteAllInboxNotifications2 = () => useDeleteAllInboxNotifications_withClient(client);
  function LiveblocksProvider2(props) {
    useEnsureNoLiveblocksProvider();
    return /* @__PURE__ */ React3.createElement(ClientContext.Provider, { value: client }, props.children);
  }
  const shared = createSharedContext(client);
  const bundle = {
    LiveblocksProvider: LiveblocksProvider2,
    useInboxNotifications: () => useInboxNotifications_withClient(client),
    useUnreadInboxNotificationsCount: () => useUnreadInboxNotificationsCount_withClient(client),
    useMarkInboxNotificationAsRead: useMarkInboxNotificationAsRead2,
    useMarkAllInboxNotificationsAsRead: useMarkAllInboxNotificationsAsRead2,
    useDeleteInboxNotification: useDeleteInboxNotification2,
    useDeleteAllInboxNotifications: useDeleteAllInboxNotifications2,
    useInboxNotificationThread: useInboxNotificationThread2,
    useUserThreads_experimental,
    ...shared.classic,
    suspense: {
      LiveblocksProvider: LiveblocksProvider2,
      useInboxNotifications: () => useInboxNotificationsSuspense_withClient(client),
      useUnreadInboxNotificationsCount: () => useUnreadInboxNotificationsCountSuspense_withClient(client),
      useMarkInboxNotificationAsRead: useMarkInboxNotificationAsRead2,
      useMarkAllInboxNotificationsAsRead: useMarkAllInboxNotificationsAsRead2,
      useDeleteInboxNotification: useDeleteInboxNotification2,
      useDeleteAllInboxNotifications: useDeleteAllInboxNotifications2,
      useInboxNotificationThread: useInboxNotificationThread2,
      useUserThreads_experimental: useUserThreadsSuspense_experimental,
      ...shared.suspense
    }
  };
  return bundle;
}
function useInboxNotifications_withClient(client) {
  const { loadInboxNotifications, store, useEnableInboxNotificationsPolling } = getExtrasForClient(client);
  useEffect3(() => {
    loadInboxNotifications();
  }, [loadInboxNotifications]);
  useEnableInboxNotificationsPolling();
  return useSyncExternalStoreWithSelector(
    store.subscribeInboxNotifications,
    store.getInboxNotifications,
    store.getInboxNotifications,
    selectorFor_useInboxNotifications,
    shallow3
  );
}
function useInboxNotificationsSuspense_withClient(client) {
  const { waitUntilInboxNotificationsLoaded } = getExtrasForClient(client);
  use(waitUntilInboxNotificationsLoaded());
  const result = useInboxNotifications_withClient(client);
  assert(!result.error, "Did not expect error");
  assert(!result.isLoading, "Did not expect loading");
  return result;
}
function useUnreadInboxNotificationsCount_withClient(client) {
  const { store, loadInboxNotifications, useEnableInboxNotificationsPolling } = getExtrasForClient(client);
  useEffect3(() => {
    loadInboxNotifications();
  }, [loadInboxNotifications]);
  useEnableInboxNotificationsPolling();
  return useSyncExternalStoreWithSelector(
    store.subscribeInboxNotifications,
    store.getInboxNotifications,
    store.getInboxNotifications,
    selectorFor_useUnreadInboxNotificationsCount,
    shallow3
  );
}
function useUnreadInboxNotificationsCountSuspense_withClient(client) {
  const { waitUntilInboxNotificationsLoaded } = getExtrasForClient(client);
  use(waitUntilInboxNotificationsLoaded());
  const result = useUnreadInboxNotificationsCount_withClient(client);
  assert(!result.isLoading, "Did not expect loading");
  assert(!result.error, "Did not expect error");
  return result;
}
function useMarkInboxNotificationAsRead_withClient(client) {
  return useCallback2(
    (inboxNotificationId) => {
      const { store } = getExtrasForClient(client);
      const readAt = /* @__PURE__ */ new Date();
      const optimisticUpdateId = store.addOptimisticUpdate({
        type: "mark-inbox-notification-as-read",
        inboxNotificationId,
        readAt
      });
      client.markInboxNotificationAsRead(inboxNotificationId).then(
        () => {
          store.updateInboxNotification(
            inboxNotificationId,
            optimisticUpdateId,
            (inboxNotification) => ({ ...inboxNotification, readAt })
          );
        },
        () => {
          store.removeOptimisticUpdate(optimisticUpdateId);
        }
      );
    },
    [client]
  );
}
function useMarkAllInboxNotificationsAsRead_withClient(client) {
  return useCallback2(() => {
    const { store } = getExtrasForClient(client);
    const readAt = /* @__PURE__ */ new Date();
    const optimisticUpdateId = store.addOptimisticUpdate({
      type: "mark-all-inbox-notifications-as-read",
      readAt
    });
    client.markAllInboxNotificationsAsRead().then(
      () => {
        store.updateAllInboxNotifications(
          optimisticUpdateId,
          (inboxNotification) => ({ ...inboxNotification, readAt })
        );
      },
      () => {
        store.removeOptimisticUpdate(optimisticUpdateId);
      }
    );
  }, [client]);
}
function useDeleteInboxNotification_withClient(client) {
  return useCallback2(
    (inboxNotificationId) => {
      const { store } = getExtrasForClient(client);
      const deletedAt = /* @__PURE__ */ new Date();
      const optimisticUpdateId = store.addOptimisticUpdate({
        type: "delete-inbox-notification",
        inboxNotificationId,
        deletedAt
      });
      client.deleteInboxNotification(inboxNotificationId).then(
        () => {
          store.deleteInboxNotification(
            inboxNotificationId,
            optimisticUpdateId
          );
        },
        () => {
          store.removeOptimisticUpdate(optimisticUpdateId);
        }
      );
    },
    [client]
  );
}
function useDeleteAllInboxNotifications_withClient(client) {
  return useCallback2(() => {
    const { store } = getExtrasForClient(client);
    const deletedAt = /* @__PURE__ */ new Date();
    const optimisticUpdateId = store.addOptimisticUpdate({
      type: "delete-all-inbox-notifications",
      deletedAt
    });
    client.deleteAllInboxNotifications().then(
      () => {
        store.deleteAllInboxNotifications(optimisticUpdateId);
      },
      () => {
        store.removeOptimisticUpdate(optimisticUpdateId);
      }
    );
  }, [client]);
}
function useInboxNotificationThread_withClient(client, inboxNotificationId) {
  const { store } = getExtrasForClient(client);
  const selector = useCallback2(
    (state) => {
      const inboxNotification = state.inboxNotificationsById[inboxNotificationId] ?? raise(`Inbox notification with ID "${inboxNotificationId}" not found`);
      if (inboxNotification.kind !== "thread") {
        raise(
          `Inbox notification with ID "${inboxNotificationId}" is not of kind "thread"`
        );
      }
      const thread = state.threadsById[inboxNotification.threadId] ?? raise(
        `Thread with ID "${inboxNotification.threadId}" not found, this inbox notification might not be of kind "thread"`
      );
      return thread;
    },
    [inboxNotificationId]
  );
  return useSyncExternalStoreWithSelector(
    store.subscribeInboxNotifications,
    store.getInboxNotifications,
    store.getInboxNotifications,
    selector
  );
}
function useUser_withClient(client, userId) {
  const usersStore = client[kInternal].usersStore;
  const getUserState = useCallback2(
    () => usersStore.getState(userId),
    [usersStore, userId]
  );
  useEffect3(() => {
    void usersStore.get(userId);
  }, [usersStore, userId]);
  const selector = useCallback2(
    (state) => selectorFor_useUser(state, userId),
    [userId]
  );
  return useSyncExternalStoreWithSelector(
    usersStore.subscribe,
    getUserState,
    getUserState,
    selector,
    shallow3
  );
}
function useUserSuspense_withClient(client, userId) {
  const usersStore = client[kInternal].usersStore;
  const getUserState = useCallback2(
    () => usersStore.getState(userId),
    [usersStore, userId]
  );
  const userState = getUserState();
  if (!userState || userState.isLoading) {
    throw usersStore.get(userId);
  }
  if (userState.error) {
    throw userState.error;
  }
  if (!userState.data) {
    throw missingUserError(userId);
  }
  const state = useSyncExternalStore(
    usersStore.subscribe,
    getUserState,
    getUserState
  );
  assert(state !== void 0, "Unexpected missing state");
  assert(!state.isLoading, "Unexpected loading state");
  assert(!state.error, "Unexpected error state");
  return {
    isLoading: false,
    user: state.data,
    error: void 0
  };
}
function useRoomInfo_withClient(client, roomId) {
  const roomsInfoStore = client[kInternal].roomsInfoStore;
  const getRoomInfoState = useCallback2(
    () => roomsInfoStore.getState(roomId),
    [roomsInfoStore, roomId]
  );
  const selector = useCallback2(
    (state) => selectorFor_useRoomInfo(state, roomId),
    [roomId]
  );
  useEffect3(() => {
    void roomsInfoStore.get(roomId);
  }, [roomsInfoStore, roomId]);
  return useSyncExternalStoreWithSelector(
    roomsInfoStore.subscribe,
    getRoomInfoState,
    getRoomInfoState,
    selector,
    shallow3
  );
}
function useRoomInfoSuspense_withClient(client, roomId) {
  const roomsInfoStore = client[kInternal].roomsInfoStore;
  const getRoomInfoState = useCallback2(
    () => roomsInfoStore.getState(roomId),
    [roomsInfoStore, roomId]
  );
  const roomInfoState = getRoomInfoState();
  if (!roomInfoState || roomInfoState.isLoading) {
    throw roomsInfoStore.get(roomId);
  }
  if (roomInfoState.error) {
    throw roomInfoState.error;
  }
  if (!roomInfoState.data) {
    throw missingRoomInfoError(roomId);
  }
  const state = useSyncExternalStore(
    roomsInfoStore.subscribe,
    getRoomInfoState,
    getRoomInfoState
  );
  assert(state !== void 0, "Unexpected missing state");
  assert(!state.isLoading, "Unexpected loading state");
  assert(!state.error, "Unexpected error state");
  assert(state.data !== void 0, "Unexpected missing room info data");
  return {
    isLoading: false,
    info: state.data,
    error: void 0
  };
}
function createSharedContext(client) {
  const useClient2 = () => client;
  return {
    classic: {
      useClient: useClient2,
      useUser: (userId) => useUser_withClient(client, userId),
      useRoomInfo: (roomId) => useRoomInfo_withClient(client, roomId),
      useIsInsideRoom
    },
    suspense: {
      useClient: useClient2,
      useUser: (userId) => useUserSuspense_withClient(client, userId),
      useRoomInfo: (roomId) => useRoomInfoSuspense_withClient(client, roomId),
      useIsInsideRoom
    }
  };
}
function useEnsureNoLiveblocksProvider(options) {
  const existing = useClientOrNull();
  if (!options?.allowNesting && existing !== null) {
    throw new Error(
      "You cannot nest multiple LiveblocksProvider instances in the same React tree."
    );
  }
}
function useClientOrNull() {
  return useContext2(ClientContext);
}
function useClient() {
  return useClientOrNull() ?? raise("LiveblocksProvider is missing from the React tree.");
}
function LiveblocksProviderWithClient(props) {
  useEnsureNoLiveblocksProvider(props);
  return /* @__PURE__ */ React3.createElement(ClientContext.Provider, { value: props.client }, props.children);
}
function LiveblocksProvider(props) {
  const { children, ...o } = props;
  const options = {
    publicApiKey: useInitial(o.publicApiKey),
    throttle: useInitial(o.throttle),
    lostConnectionTimeout: useInitial(o.lostConnectionTimeout),
    backgroundKeepAliveTimeout: useInitial(o.backgroundKeepAliveTimeout),
    polyfills: useInitial(o.polyfills),
    unstable_fallbackToHTTP: useInitial(o.unstable_fallbackToHTTP),
    unstable_streamData: useInitial(o.unstable_streamData),
    authEndpoint: useInitialUnlessFunction(o.authEndpoint),
    resolveMentionSuggestions: useInitialUnlessFunction(
      o.resolveMentionSuggestions
    ),
    resolveUsers: useInitialUnlessFunction(o.resolveUsers),
    resolveRoomsInfo: useInitialUnlessFunction(o.resolveRoomsInfo),
    baseUrl: useInitial(
      // @ts-expect-error - Hidden config options
      o.baseUrl
    ),
    enableDebugLogging: useInitial(
      // @ts-expect-error - Hidden config options
      o.enableDebugLogging
    )
  };
  const client = useMemo(() => createClient(options), []);
  return /* @__PURE__ */ React3.createElement(LiveblocksProviderWithClient, { client }, children);
}
function createLiveblocksContext(client) {
  return getOrCreateContextBundle(client);
}
function useUserThreads_experimental(options = {
  query: {
    metadata: {}
  }
}) {
  const queryKey = React3.useMemo(
    () => makeUserThreadsQueryKey(options.query),
    [options]
  );
  const client = useClient();
  const { store, incrementUserThreadsQuerySubscribers, getUserThreads } = getExtrasForClient(client);
  useEffect3(() => {
    void getUserThreads(queryKey, options);
    return incrementUserThreadsQuerySubscribers(queryKey);
  }, [queryKey, incrementUserThreadsQuerySubscribers, getUserThreads, options]);
  const selector = useCallback2(
    (state) => {
      const query = state.queries[queryKey];
      if (query === void 0 || query.isLoading) {
        return {
          isLoading: true
        };
      }
      if (query.error !== void 0) {
        return {
          threads: [],
          error: query.error,
          isLoading: false
        };
      }
      return {
        threads: selectThreads(state, {
          roomId: null,
          // Do _not_ filter by roomId
          query: options.query,
          orderBy: "last-update"
        }),
        isLoading: false
      };
    },
    [queryKey, options]
  );
  return useSyncExternalStoreWithSelector(
    store.subscribeThreads,
    store.getThreads,
    store.getThreads,
    selector,
    shallow2
    // NOTE: Using 2-level-deep shallow check here, because the result of selectThreads() is not stable!
  );
}
function useUserThreadsSuspense_experimental(options = {
  query: {
    metadata: {}
  }
}) {
  const queryKey = React3.useMemo(
    () => makeUserThreadsQueryKey(options.query),
    [options]
  );
  const client = useClient();
  const { store, getUserThreads } = getExtrasForClient(client);
  React3.useEffect(() => {
    const { incrementUserThreadsQuerySubscribers } = getExtrasForClient(client);
    return incrementUserThreadsQuerySubscribers(queryKey);
  }, [client, queryKey]);
  const query = store.getThreads().queries[queryKey];
  if (query === void 0 || query.isLoading) {
    throw getUserThreads(queryKey, options);
  }
  if (query.error) {
    throw query.error;
  }
  const selector = useCallback2(
    (state) => {
      return {
        threads: selectThreads(state, {
          roomId: null,
          // Do _not_ filter by roomId
          query: options.query,
          orderBy: "last-update"
        }),
        isLoading: false
      };
    },
    [options]
  );
  return useSyncExternalStoreWithSelector(
    store.subscribeThreads,
    store.getThreads,
    store.getThreads,
    selector,
    shallow2
    // NOTE: Using 2-level-deep shallow check here, because the result of selectThreads() is not stable!
  );
}
function useInboxNotifications() {
  return useInboxNotifications_withClient(useClient());
}
function useInboxNotificationsSuspense() {
  return useInboxNotificationsSuspense_withClient(useClient());
}
function useInboxNotificationThread(inboxNotificationId) {
  return useInboxNotificationThread_withClient(
    useClient(),
    inboxNotificationId
  );
}
function useMarkAllInboxNotificationsAsRead() {
  return useMarkAllInboxNotificationsAsRead_withClient(useClient());
}
function useMarkInboxNotificationAsRead() {
  return useMarkInboxNotificationAsRead_withClient(useClient());
}
function useDeleteAllInboxNotifications() {
  return useDeleteAllInboxNotifications_withClient(useClient());
}
function useDeleteInboxNotification() {
  return useDeleteInboxNotification_withClient(useClient());
}
function useUnreadInboxNotificationsCount() {
  return useUnreadInboxNotificationsCount_withClient(useClient());
}
function useUnreadInboxNotificationsCountSuspense() {
  return useUnreadInboxNotificationsCountSuspense_withClient(useClient());
}
function useUser(userId) {
  const client = useClient();
  return useUser_withClient(client, userId);
}
function useUserSuspense(userId) {
  const client = useClient();
  return useUserSuspense_withClient(client, userId);
}
function useRoomInfo(roomId) {
  return useRoomInfo_withClient(useClient(), roomId);
}
function useRoomInfoSuspense(roomId) {
  return useRoomInfoSuspense_withClient(useClient(), roomId);
}
var _useInboxNotificationThread = useInboxNotificationThread;
var _useUser = useUser;
var _useUserSuspense = useUserSuspense;
var _useUserThreads_experimental = useUserThreads_experimental;
var _useUserThreadsSuspense_experimental = useUserThreadsSuspense_experimental;
var makeUserThreadsQueryKey = (options) => `${USER_THREADS_QUERY}:${stringify(options)}`;

// src/types/errors.ts
var CreateThreadError = class extends Error {
  constructor(cause, context) {
    super("Create thread failed.");
    this.cause = cause;
    this.context = context;
    this.name = "CreateThreadError";
  }
};
var DeleteThreadError = class extends Error {
  constructor(cause, context) {
    super("Delete thread failed.");
    this.cause = cause;
    this.context = context;
    this.name = "DeleteThreadError";
  }
};
var EditThreadMetadataError = class extends Error {
  constructor(cause, context) {
    super("Edit thread metadata failed.");
    this.cause = cause;
    this.context = context;
    this.name = "EditThreadMetadataError";
  }
};
var MarkThreadAsResolvedError = class extends Error {
  constructor(cause, context) {
    super("Mark thread as resolved failed.");
    this.cause = cause;
    this.context = context;
    this.name = "MarkThreadAsResolvedError";
  }
};
var MarkThreadAsUnresolvedError = class extends Error {
  constructor(cause, context) {
    super("Mark thread as unresolved failed.");
    this.cause = cause;
    this.context = context;
    this.name = "MarkThreadAsUnresolvedError";
  }
};
var CreateCommentError = class extends Error {
  constructor(cause, context) {
    super("Create comment failed.");
    this.cause = cause;
    this.context = context;
    this.name = "CreateCommentError";
  }
};
var EditCommentError = class extends Error {
  constructor(cause, context) {
    super("Edit comment failed.");
    this.cause = cause;
    this.context = context;
    this.name = "EditCommentError";
  }
};
var DeleteCommentError = class extends Error {
  constructor(cause, context) {
    super("Delete comment failed.");
    this.cause = cause;
    this.context = context;
    this.name = "DeleteCommentError";
  }
};
var AddReactionError = class extends Error {
  constructor(cause, context) {
    super("Add reaction failed.");
    this.cause = cause;
    this.context = context;
    this.name = "AddReactionError";
  }
};
var RemoveReactionError = class extends Error {
  constructor(cause, context) {
    super("Remove reaction failed.");
    this.cause = cause;
    this.context = context;
    this.name = "RemoveReactionError";
  }
};
var MarkInboxNotificationAsReadError = class extends Error {
  constructor(cause, context) {
    super("Mark inbox notification as read failed.");
    this.cause = cause;
    this.context = context;
    this.name = "MarkInboxNotificationAsReadError";
  }
};
var UpdateNotificationSettingsError = class extends Error {
  constructor(cause, context) {
    super("Update notification settings failed.");
    this.cause = cause;
    this.context = context;
    this.name = "UpdateNotificationSettingsError";
  }
};

// src/room.tsx
import { shallow as shallow4 } from "@liveblocks/client";
import {
  CommentsApiError,
  console as console3,
  createCommentId,
  createThreadId,
  deprecateIf,
  errorIf,
  kInternal as kInternal2,
  makeEventSource,
  makePoller as makePoller2,
  nn,
  NotificationsApiError,
  ServerMsgCode,
  stringify as stringify2
} from "@liveblocks/core";
import * as React5 from "react";
import { useSyncExternalStoreWithSelector as useSyncExternalStoreWithSelector2 } from "use-sync-external-store/shim/with-selector.js";

// src/use-scroll-to-comment-on-load-effect.ts
import * as React4 from "react";
function handleScrollToCommentOnLoad(shouldScrollOnLoad, state) {
  if (shouldScrollOnLoad === false) return;
  if (state.isLoading) return;
  const isWindowDefined = typeof window !== "undefined";
  if (!isWindowDefined) return;
  const hash = window.location.hash;
  const commentId = hash.slice(1);
  if (!commentId.startsWith("cm_")) return;
  const comment = document.getElementById(commentId);
  if (comment === null) return;
  const comments = state.threads.flatMap((thread) => thread.comments);
  const isCommentInThreads = comments.some(
    (comment2) => comment2.id === commentId
  );
  if (!isCommentInThreads) return;
  comment.scrollIntoView();
}
function useScrollToCommentOnLoadEffect(shouldScrollOnLoad, state) {
  React4.useEffect(
    () => {
      handleScrollToCommentOnLoad(shouldScrollOnLoad, state);
    },
    // eslint-disable-next-line react-hooks/exhaustive-deps -- We only want to run this effect once
    [state.isLoading]
  );
}

// src/room.tsx
var SMOOTH_DELAY = 1e3;
var noop2 = () => {
};
var identity = (x) => x;
var missing_unstable_batchedUpdates = (reactVersion, roomId) => `We noticed you\u2019re using React ${reactVersion}. Please pass unstable_batchedUpdates at the RoomProvider level until you\u2019re ready to upgrade to React 18:

    import { unstable_batchedUpdates } from "react-dom";  // or "react-native"

    <RoomProvider id=${JSON.stringify(
  roomId
)} ... unstable_batchedUpdates={unstable_batchedUpdates}>
      ...
    </RoomProvider>

Why? Please see https://liveblocks.io/docs/platform/troubleshooting#stale-props-zombie-child for more information`;
var superfluous_unstable_batchedUpdates = "You don\u2019t need to pass unstable_batchedUpdates to RoomProvider anymore, since you\u2019re on React 18+ already.";
function useSyncExternalStore2(s, gs, gss) {
  return useSyncExternalStoreWithSelector2(s, gs, gss, identity);
}
var STABLE_EMPTY_LIST = Object.freeze([]);
var POLLING_INTERVAL2 = 5 * 60 * 1e3;
function makeNotificationSettingsQueryKey(roomId) {
  return `${roomId}:NOTIFICATION_SETTINGS`;
}
function alwaysEmptyList() {
  return STABLE_EMPTY_LIST;
}
function alwaysNull() {
  return null;
}
function selectorFor_useOthersConnectionIds(others) {
  return others.map((user) => user.connectionId);
}
function selectNotificationSettings(roomId, state) {
  const notificationSettings = state.notificationSettingsByRoomId;
  return nn(notificationSettings[roomId]);
}
function makeMutationContext(room) {
  const cannotUseUntil = "This mutation cannot be used until";
  const needsPresence = `${cannotUseUntil} connected to the Liveblocks room`;
  const needsStorage = `${cannotUseUntil} storage has been loaded`;
  return {
    get storage() {
      const mutableRoot = room.getStorageSnapshot();
      if (mutableRoot === null) {
        throw new Error(needsStorage);
      }
      return mutableRoot;
    },
    get self() {
      const self = room.getSelf();
      if (self === null) {
        throw new Error(needsPresence);
      }
      return self;
    },
    get others() {
      const others = room.getOthers();
      if (room.getSelf() === null) {
        throw new Error(needsPresence);
      }
      return others;
    },
    setMyPresence: room.updatePresence
  };
}
function getCurrentUserId(room) {
  const self = room.getSelf();
  if (self === null || self.id === void 0) {
    return "anonymous";
  } else {
    return self.id;
  }
}
function handleApiError(err) {
  const message = `Request failed with status ${err.status}: ${err.message}`;
  if (err.details?.error === "FORBIDDEN") {
    const detailedMessage = [message, err.details.suggestion, err.details.docs].filter(Boolean).join("\n");
    console3.error(detailedMessage);
  }
  return new Error(message);
}
var _extras2 = /* @__PURE__ */ new WeakMap();
var _bundles2 = /* @__PURE__ */ new WeakMap();
function getOrCreateRoomContextBundle(client) {
  let bundle = _bundles2.get(client);
  if (!bundle) {
    bundle = makeRoomContextBundle(client);
    _bundles2.set(client, bundle);
  }
  return bundle;
}
function getExtrasForClient2(client) {
  let extras = _extras2.get(client);
  if (!extras) {
    extras = makeExtrasForClient2(client);
    _extras2.set(client, extras);
  }
  return extras;
}
function makeExtrasForClient2(client) {
  const store = getUmbrellaStoreForClient(client);
  const DEFAULT_DEDUPING_INTERVAL = 2e3;
  const lastRequestedAtByRoom = /* @__PURE__ */ new Map();
  const requestsByQuery = /* @__PURE__ */ new Map();
  const requestStatusByRoom = /* @__PURE__ */ new Map();
  const subscribersByQuery = /* @__PURE__ */ new Map();
  const poller = makePoller2(refreshThreadsAndNotifications);
  async function refreshThreadsAndNotifications() {
    const requests = [];
    client[kInternal2].getRoomIds().map((roomId) => {
      const room = client.getRoom(roomId);
      if (room === null) return;
      requests.push(getThreadsUpdates(room.id));
    });
    await Promise.allSettled(requests);
  }
  function incrementQuerySubscribers(queryKey) {
    const subscribers = subscribersByQuery.get(queryKey) ?? 0;
    subscribersByQuery.set(queryKey, subscribers + 1);
    poller.start(POLLING_INTERVAL2);
    return () => {
      const subscribers2 = subscribersByQuery.get(queryKey);
      if (subscribers2 === void 0 || subscribers2 <= 0) {
        console3.warn(
          `Internal unexpected behavior. Cannot decrease subscriber count for query "${queryKey}"`
        );
        return;
      }
      subscribersByQuery.set(queryKey, subscribers2 - 1);
      let totalSubscribers = 0;
      for (const subscribers3 of subscribersByQuery.values()) {
        totalSubscribers += subscribers3;
      }
      if (totalSubscribers <= 0) {
        poller.stop();
      }
    };
  }
  async function getThreadsUpdates(roomId) {
    const room = client.getRoom(roomId);
    if (room === null) return;
    const since = lastRequestedAtByRoom.get(room.id);
    if (since === void 0) return;
    const isFetchingThreadsUpdates = requestStatusByRoom.get(room.id) ?? false;
    if (isFetchingThreadsUpdates === true) return;
    try {
      requestStatusByRoom.set(room.id, true);
      const updates = await room.getThreadsSince({ since });
      setTimeout(() => {
        requestStatusByRoom.set(room.id, false);
      }, DEFAULT_DEDUPING_INTERVAL);
      store.updateThreadsAndNotifications(
        updates.threads.updated,
        updates.inboxNotifications.updated,
        updates.threads.deleted,
        updates.inboxNotifications.deleted
      );
      lastRequestedAtByRoom.set(room.id, updates.requestedAt);
    } catch (err) {
      requestStatusByRoom.set(room.id, false);
      return;
    }
  }
  async function getRoomVersions(room, { retryCount } = { retryCount: 0 }) {
    const queryKey = getVersionsQueryKey(room.id);
    const existingRequest = requestsByQuery.get(queryKey);
    if (existingRequest !== void 0) return existingRequest;
    const request = room[kInternal2].listTextVersions();
    requestsByQuery.set(queryKey, request);
    store.setQueryLoading(queryKey);
    try {
      const result = await request;
      const data = await result.json();
      const versions = data.versions.map(({ createdAt, ...version2 }) => {
        return {
          createdAt: new Date(createdAt),
          ...version2
        };
      });
      store.updateRoomVersions(room.id, versions, queryKey);
      requestsByQuery.delete(queryKey);
    } catch (err) {
      requestsByQuery.delete(queryKey);
      retryError(() => {
        void getRoomVersions(room, {
          retryCount: retryCount + 1
        });
      }, retryCount);
      store.setQueryError(queryKey, err);
    }
    return;
  }
  async function getThreadsAndInboxNotifications(room, queryKey, options, { retryCount } = { retryCount: 0 }) {
    const existingRequest = requestsByQuery.get(queryKey);
    if (existingRequest !== void 0) return existingRequest;
    const request = room.getThreads(options);
    requestsByQuery.set(queryKey, request);
    store.setQueryLoading(queryKey);
    try {
      const result = await request;
      store.updateThreadsAndNotifications(
        result.threads,
        // TODO: Figure out how to remove this casting
        result.inboxNotifications,
        [],
        [],
        queryKey
      );
      const lastRequestedAt = lastRequestedAtByRoom.get(room.id);
      if (lastRequestedAt === void 0 || lastRequestedAt > result.requestedAt) {
        lastRequestedAtByRoom.set(room.id, result.requestedAt);
      }
      poller.start(POLLING_INTERVAL2);
    } catch (err) {
      requestsByQuery.delete(queryKey);
      retryError(() => {
        void getThreadsAndInboxNotifications(room, queryKey, options, {
          retryCount: retryCount + 1
        });
      }, retryCount);
      store.setQueryError(queryKey, err);
    }
    return;
  }
  async function getInboxNotificationSettings(room, queryKey, { retryCount } = { retryCount: 0 }) {
    const existingRequest = requestsByQuery.get(queryKey);
    if (existingRequest !== void 0) return existingRequest;
    try {
      const request = room.getNotificationSettings();
      requestsByQuery.set(queryKey, request);
      store.setQueryLoading(queryKey);
      const settings = await request;
      store.updateRoomInboxNotificationSettings(room.id, settings, queryKey);
    } catch (err) {
      requestsByQuery.delete(queryKey);
      retryError(() => {
        void getInboxNotificationSettings(room, queryKey, {
          retryCount: retryCount + 1
        });
      }, retryCount);
      store.setQueryError(queryKey, err);
    }
    return;
  }
  const commentsErrorEventSource = makeEventSource();
  function onMutationFailure(innerError, optimisticUpdateId, createPublicError) {
    store.removeOptimisticUpdate(optimisticUpdateId);
    if (innerError instanceof CommentsApiError) {
      const error = handleApiError(innerError);
      commentsErrorEventSource.notify(createPublicError(error));
      return;
    }
    if (innerError instanceof NotificationsApiError) {
      handleApiError(innerError);
      return;
    }
    throw innerError;
  }
  return {
    store,
    incrementQuerySubscribers,
    commentsErrorEventSource,
    getThreadsUpdates,
    getThreadsAndInboxNotifications,
    getInboxNotificationSettings,
    getRoomVersions,
    onMutationFailure
  };
}
function makeRoomContextBundle(client) {
  function RoomProvider_withImplicitLiveblocksProvider(props) {
    return /* @__PURE__ */ React5.createElement(LiveblocksProviderWithClient, { client, allowNesting: true }, /* @__PURE__ */ React5.createElement(RoomProvider, { ...props }));
  }
  const shared = createSharedContext(client);
  const bundle = {
    RoomContext,
    RoomProvider: RoomProvider_withImplicitLiveblocksProvider,
    useRoom,
    useStatus,
    useStorageStatus,
    useBatch,
    useBroadcastEvent,
    useOthersListener,
    useLostConnectionListener,
    useErrorListener,
    useEventListener,
    useHistory,
    useUndo,
    useRedo,
    useCanRedo,
    useCanUndo,
    useStorageRoot,
    useStorage,
    useSelf,
    useMyPresence,
    useUpdateMyPresence,
    useOthers,
    useOthersMapped,
    useOthersConnectionIds,
    useOther,
    useMutation,
    useThreads,
    useCreateThread,
    useDeleteThread,
    useEditThreadMetadata,
    useMarkThreadAsResolved,
    useMarkThreadAsUnresolved,
    useCreateComment,
    useEditComment,
    useDeleteComment,
    useAddReaction,
    useRemoveReaction,
    useMarkThreadAsRead,
    useThreadSubscription,
    useHistoryVersions,
    useHistoryVersionData,
    useRoomNotificationSettings,
    useUpdateRoomNotificationSettings,
    ...shared.classic,
    suspense: {
      RoomContext,
      RoomProvider: RoomProvider_withImplicitLiveblocksProvider,
      useRoom,
      useStatus,
      useStorageStatus: useStorageStatusSuspense,
      useBatch,
      useBroadcastEvent,
      useOthersListener,
      useLostConnectionListener,
      useErrorListener,
      useEventListener,
      useHistory,
      useUndo,
      useRedo,
      useCanRedo,
      useCanUndo,
      useStorageRoot,
      useStorage: useStorageSuspense,
      useSelf: useSelfSuspense,
      useMyPresence,
      useUpdateMyPresence,
      useOthers: useOthersSuspense,
      useOthersMapped: useOthersMappedSuspense,
      useOthersConnectionIds: useOthersConnectionIdsSuspense,
      useOther: useOtherSuspense,
      useMutation,
      useThreads: useThreadsSuspense,
      useCreateThread,
      useDeleteThread,
      useEditThreadMetadata,
      useMarkThreadAsResolved,
      useMarkThreadAsUnresolved,
      useCreateComment,
      useEditComment,
      useDeleteComment,
      useAddReaction,
      useRemoveReaction,
      useMarkThreadAsRead,
      useThreadSubscription,
      // TODO: useHistoryVersionData: useHistoryVersionDataSuspense,
      useHistoryVersions: useHistoryVersionsSuspense,
      useRoomNotificationSettings: useRoomNotificationSettingsSuspense,
      useUpdateRoomNotificationSettings,
      ...shared.suspense
    },
    useCommentsErrorListener
  };
  return Object.defineProperty(bundle, kInternal2, {
    enumerable: false
  });
}
function RoomProvider(props) {
  const client = useClient();
  const [cache] = React5.useState(
    () => /* @__PURE__ */ new Map()
  );
  const stableEnterRoom = React5.useCallback(
    (roomId, options) => {
      const cached = cache.get(roomId);
      if (cached) return cached;
      const rv = client.enterRoom(roomId, options);
      const origLeave = rv.leave;
      rv.leave = () => {
        origLeave();
        cache.delete(roomId);
      };
      cache.set(roomId, rv);
      return rv;
    },
    [client, cache]
  );
  return /* @__PURE__ */ React5.createElement(
    RoomProviderInner,
    {
      ...props,
      stableEnterRoom
    }
  );
}
function RoomProviderInner(props) {
  const client = useClient();
  const { id: roomId, stableEnterRoom } = props;
  if (process.env.NODE_ENV !== "production") {
    if (!roomId) {
      throw new Error(
        "RoomProvider id property is required. For more information: https://liveblocks.io/docs/errors/liveblocks-react/RoomProvider-id-property-is-required"
      );
    }
    if (!isString(roomId)) {
      throw new Error("RoomProvider id property should be a string.");
    }
    const majorReactVersion = parseInt(React5.version) || 1;
    const oldReactVersion = majorReactVersion < 18;
    errorIf(
      oldReactVersion && props.unstable_batchedUpdates === void 0,
      missing_unstable_batchedUpdates(majorReactVersion, roomId)
    );
    deprecateIf(
      !oldReactVersion && props.unstable_batchedUpdates !== void 0,
      superfluous_unstable_batchedUpdates
    );
  }
  const frozenProps = useInitial({
    initialPresence: props.initialPresence,
    initialStorage: props.initialStorage,
    unstable_batchedUpdates: props.unstable_batchedUpdates,
    autoConnect: props.autoConnect ?? typeof window !== "undefined"
  });
  const [{ room }, setRoomLeavePair] = React5.useState(
    () => stableEnterRoom(roomId, {
      ...frozenProps,
      autoConnect: false
      // Deliberately using false here on the first render, see below
    })
  );
  React5.useEffect(() => {
    const { store } = getExtrasForClient2(client);
    async function handleCommentEvent(message) {
      if (message.type === ServerMsgCode.THREAD_DELETED) {
        store.deleteThread(message.threadId, null);
        return;
      }
      const info = await room.getThread(message.threadId);
      if (!info.thread) {
        store.deleteThread(message.threadId, null);
        return;
      }
      const { thread, inboxNotification } = info;
      const existingThread = store.getThreads().threadsById[message.threadId];
      switch (message.type) {
        case ServerMsgCode.COMMENT_EDITED:
        case ServerMsgCode.THREAD_METADATA_UPDATED:
        case ServerMsgCode.THREAD_UPDATED:
        case ServerMsgCode.COMMENT_REACTION_ADDED:
        case ServerMsgCode.COMMENT_REACTION_REMOVED:
        case ServerMsgCode.COMMENT_DELETED:
          if (!existingThread) break;
          store.updateThreadAndNotification(thread, inboxNotification);
          break;
        case ServerMsgCode.COMMENT_CREATED:
          store.updateThreadAndNotification(thread, inboxNotification);
          break;
        default:
          break;
      }
    }
    return room.events.comments.subscribe(
      (message) => void handleCommentEvent(message)
    );
  }, [client, room]);
  React5.useEffect(() => {
    const { getThreadsUpdates } = getExtrasForClient2(client);
    void getThreadsUpdates(room.id);
  }, [client, room.id]);
  React5.useEffect(() => {
    function handleIsOnline() {
      const { getThreadsUpdates } = getExtrasForClient2(client);
      void getThreadsUpdates(room.id);
    }
    window.addEventListener("online", handleIsOnline);
    return () => {
      window.removeEventListener("online", handleIsOnline);
    };
  }, [client, room.id]);
  React5.useEffect(() => {
    const pair = stableEnterRoom(roomId, frozenProps);
    setRoomLeavePair(pair);
    const { room: room2, leave } = pair;
    if (frozenProps.autoConnect) {
      room2.connect();
    }
    return () => {
      leave();
    };
  }, [roomId, frozenProps, stableEnterRoom]);
  return /* @__PURE__ */ React5.createElement(RoomContext.Provider, { value: room }, props.children);
}
function useRoom() {
  const room = useRoomOrNull();
  if (room === null) {
    throw new Error("RoomProvider is missing from the React tree.");
  }
  return room;
}
function useStatus() {
  const room = useRoom();
  const subscribe = room.events.status.subscribe;
  const getSnapshot = room.getStatus;
  const getServerSnapshot = room.getStatus;
  return useSyncExternalStore2(subscribe, getSnapshot, getServerSnapshot);
}
function useStorageStatus(options) {
  const smooth = useInitial(options?.smooth ?? false);
  if (smooth) {
    return useStorageStatusSmooth();
  } else {
    return useStorageStatusImmediate();
  }
}
function useStorageStatusImmediate() {
  const room = useRoom();
  const subscribe = room.events.storageStatus.subscribe;
  const getSnapshot = room.getStorageStatus;
  const getServerSnapshot = room.getStorageStatus;
  return useSyncExternalStore2(subscribe, getSnapshot, getServerSnapshot);
}
function useStorageStatusSmooth() {
  const room = useRoom();
  const [status, setStatus] = React5.useState(room.getStorageStatus);
  const oldStatus = useLatest(room.getStorageStatus());
  React5.useEffect(() => {
    let timeoutId;
    const unsub = room.events.storageStatus.subscribe((newStatus) => {
      if (oldStatus.current === "synchronizing" && newStatus === "synchronized") {
        timeoutId = setTimeout(() => setStatus(newStatus), SMOOTH_DELAY);
      } else {
        clearTimeout(timeoutId);
        setStatus(newStatus);
      }
    });
    return () => {
      clearTimeout(timeoutId);
      unsub();
    };
  }, [room, oldStatus]);
  return status;
}
function useBatch() {
  return useRoom().batch;
}
function useBroadcastEvent() {
  const room = useRoom();
  return React5.useCallback(
    (event, options = { shouldQueueEventIfNotReady: false }) => {
      room.broadcastEvent(event, options);
    },
    [room]
  );
}
function useOthersListener(callback) {
  const room = useRoom();
  const savedCallback = useLatest(callback);
  React5.useEffect(
    () => room.events.others.subscribe((event) => savedCallback.current(event)),
    [room, savedCallback]
  );
}
function useLostConnectionListener(callback) {
  const room = useRoom();
  const savedCallback = useLatest(callback);
  React5.useEffect(
    () => room.events.lostConnection.subscribe(
      (event) => savedCallback.current(event)
    ),
    [room, savedCallback]
  );
}
function useErrorListener(callback) {
  const room = useRoom();
  const savedCallback = useLatest(callback);
  React5.useEffect(
    () => room.events.error.subscribe((e) => savedCallback.current(e)),
    [room, savedCallback]
  );
}
function useEventListener(callback) {
  const room = useRoom();
  const savedCallback = useLatest(callback);
  React5.useEffect(() => {
    const listener = (eventData) => {
      savedCallback.current(eventData);
    };
    return room.events.customEvent.subscribe(listener);
  }, [room, savedCallback]);
}
function useHistory() {
  return useRoom().history;
}
function useUndo() {
  return useHistory().undo;
}
function useRedo() {
  return useHistory().redo;
}
function useCanUndo() {
  const room = useRoom();
  const subscribe = room.events.history.subscribe;
  const canUndo = room.history.canUndo;
  return useSyncExternalStore2(subscribe, canUndo, canUndo);
}
function useCanRedo() {
  const room = useRoom();
  const subscribe = room.events.history.subscribe;
  const canRedo = room.history.canRedo;
  return useSyncExternalStore2(subscribe, canRedo, canRedo);
}
function useSelf(maybeSelector, isEqual) {
  const room = useRoom();
  const subscribe = room.events.self.subscribe;
  const getSnapshot = room.getSelf;
  const selector = maybeSelector ?? identity;
  const wrappedSelector = React5.useCallback(
    (me) => me !== null ? selector(me) : null,
    [selector]
  );
  const getServerSnapshot = alwaysNull;
  return useSyncExternalStoreWithSelector2(
    subscribe,
    getSnapshot,
    getServerSnapshot,
    wrappedSelector,
    isEqual
  );
}
function useMyPresence() {
  const room = useRoom();
  const subscribe = room.events.myPresence.subscribe;
  const getSnapshot = room.getPresence;
  const presence = useSyncExternalStore2(subscribe, getSnapshot, getSnapshot);
  const setPresence = room.updatePresence;
  return [presence, setPresence];
}
function useUpdateMyPresence() {
  return useRoom().updatePresence;
}
function useOthers(selector, isEqual) {
  const room = useRoom();
  const subscribe = room.events.others.subscribe;
  const getSnapshot = room.getOthers;
  const getServerSnapshot = alwaysEmptyList;
  return useSyncExternalStoreWithSelector2(
    subscribe,
    getSnapshot,
    getServerSnapshot,
    selector ?? identity,
    isEqual
  );
}
function useOthersMapped(itemSelector, itemIsEqual) {
  const wrappedSelector = React5.useCallback(
    (others) => others.map((other) => [other.connectionId, itemSelector(other)]),
    [itemSelector]
  );
  const wrappedIsEqual = React5.useCallback(
    (a, b) => {
      const eq = itemIsEqual ?? Object.is;
      return a.length === b.length && a.every((atuple, index) => {
        const btuple = b[index];
        return atuple[0] === btuple[0] && eq(atuple[1], btuple[1]);
      });
    },
    [itemIsEqual]
  );
  return useOthers(wrappedSelector, wrappedIsEqual);
}
function useOthersConnectionIds() {
  return useOthers(selectorFor_useOthersConnectionIds, shallow4);
}
var NOT_FOUND = Symbol();
function useOther(connectionId, selector, isEqual) {
  const wrappedSelector = React5.useCallback(
    (others) => {
      const other2 = others.find((other3) => other3.connectionId === connectionId);
      return other2 !== void 0 ? selector(other2) : NOT_FOUND;
    },
    [connectionId, selector]
  );
  const wrappedIsEqual = React5.useCallback(
    (prev, curr) => {
      if (prev === NOT_FOUND || curr === NOT_FOUND) {
        return prev === curr;
      }
      const eq = isEqual ?? Object.is;
      return eq(prev, curr);
    },
    [isEqual]
  );
  const other = useOthers(wrappedSelector, wrappedIsEqual);
  if (other === NOT_FOUND) {
    throw new Error(
      `No such other user with connection id ${connectionId} exists`
    );
  }
  return other;
}
function useMutableStorageRoot() {
  const room = useRoom();
  const subscribe = room.events.storageDidLoad.subscribeOnce;
  const getSnapshot = room.getStorageSnapshot;
  const getServerSnapshot = alwaysNull;
  return useSyncExternalStore2(subscribe, getSnapshot, getServerSnapshot);
}
function useStorageRoot() {
  return [useMutableStorageRoot()];
}
function useStorage(selector, isEqual) {
  const room = useRoom();
  const rootOrNull = useMutableStorageRoot();
  const wrappedSelector = React5.useCallback(
    (rootOrNull2) => rootOrNull2 !== null ? selector(rootOrNull2) : null,
    [selector]
  );
  const subscribe = React5.useCallback(
    (onStoreChange) => rootOrNull !== null ? room.subscribe(rootOrNull, onStoreChange, { isDeep: true }) : noop2,
    [room, rootOrNull]
  );
  const getSnapshot = React5.useCallback(() => {
    if (rootOrNull === null) {
      return null;
    } else {
      const root = rootOrNull;
      const imm = root.toImmutable();
      return imm;
    }
  }, [rootOrNull]);
  const getServerSnapshot = alwaysNull;
  return useSyncExternalStoreWithSelector2(
    subscribe,
    getSnapshot,
    getServerSnapshot,
    wrappedSelector,
    isEqual
  );
}
function useMutation(callback, deps) {
  const room = useRoom();
  return React5.useMemo(
    () => {
      return (...args) => (
        // eslint-disable-next-line @typescript-eslint/no-unsafe-return
        room.batch(
          () => (
            // eslint-disable-next-line @typescript-eslint/no-unsafe-return
            callback(
              makeMutationContext(room),
              ...args
            )
          )
        )
      );
    },
    // eslint-disable-next-line react-hooks/exhaustive-deps
    [room, ...deps]
  );
}
function useThreads(options = {
  query: { metadata: {} }
}) {
  const { scrollOnLoad = true } = options;
  const client = useClient();
  const room = useRoom();
  const queryKey = React5.useMemo(
    () => generateQueryKey(room.id, options.query),
    [room, options]
  );
  const { store, getThreadsAndInboxNotifications, incrementQuerySubscribers } = getExtrasForClient2(client);
  React5.useEffect(() => {
    void getThreadsAndInboxNotifications(room, queryKey, options);
    return incrementQuerySubscribers(queryKey);
  }, [room, queryKey]);
  const selector = React5.useCallback(
    (state2) => {
      const query = state2.queries[queryKey];
      if (query === void 0 || query.isLoading) {
        return {
          isLoading: true
        };
      }
      return {
        threads: selectThreads(state2, {
          roomId: room.id,
          query: options.query,
          orderBy: "age"
        }),
        isLoading: false,
        error: query.error
      };
    },
    [room, queryKey]
    // eslint-disable-line react-hooks/exhaustive-deps
  );
  const state = useSyncExternalStoreWithSelector2(
    store.subscribeThreads,
    store.getThreads,
    store.getThreads,
    selector
  );
  useScrollToCommentOnLoadEffect(scrollOnLoad, state);
  return state;
}
function useCommentsErrorListener(callback) {
  const client = useClient();
  const savedCallback = useLatest(callback);
  const { commentsErrorEventSource } = getExtrasForClient2(client);
  React5.useEffect(() => {
    return commentsErrorEventSource.subscribe(savedCallback.current);
  }, [savedCallback, commentsErrorEventSource]);
}
function useCreateThread() {
  const client = useClient();
  const room = useRoom();
  return React5.useCallback(
    (options) => {
      const body = options.body;
      const metadata = options.metadata ?? {};
      const threadId = createThreadId();
      const commentId = createCommentId();
      const createdAt = /* @__PURE__ */ new Date();
      const newComment = {
        id: commentId,
        threadId,
        roomId: room.id,
        createdAt,
        type: "comment",
        userId: getCurrentUserId(room),
        body,
        reactions: []
      };
      const newThread = {
        id: threadId,
        type: "thread",
        createdAt,
        updatedAt: createdAt,
        roomId: room.id,
        metadata,
        comments: [newComment],
        resolved: false
      };
      const { store, onMutationFailure } = getExtrasForClient2(client);
      const optimisticUpdateId = store.addOptimisticUpdate({
        type: "create-thread",
        thread: newThread,
        roomId: room.id
      });
      room.createThread({ threadId, commentId, body, metadata }).then(
        (thread) => {
          store.createThread(optimisticUpdateId, thread);
        },
        (err) => onMutationFailure(
          err,
          optimisticUpdateId,
          (err2) => new CreateThreadError(err2, {
            roomId: room.id,
            threadId,
            commentId,
            body,
            metadata
          })
        )
      );
      return newThread;
    },
    [client, room]
  );
}
function useDeleteThread() {
  const client = useClient();
  const room = useRoom();
  return React5.useCallback(
    (threadId) => {
      const { store, onMutationFailure } = getExtrasForClient2(client);
      const thread = store.getThreads().threadsById[threadId];
      const userId = getCurrentUserId(room);
      if (thread?.comments?.[0]?.userId !== userId) {
        throw new Error("Only the thread creator can delete the thread");
      }
      const optimisticUpdateId = store.addOptimisticUpdate({
        type: "delete-thread",
        roomId: room.id,
        threadId,
        deletedAt: /* @__PURE__ */ new Date()
      });
      room.deleteThread(threadId).then(
        () => {
          store.deleteThread(threadId, optimisticUpdateId);
        },
        (err) => onMutationFailure(
          err,
          optimisticUpdateId,
          (err2) => new DeleteThreadError(err2, { roomId: room.id, threadId })
        )
      );
    },
    [client, room]
  );
}
function useEditThreadMetadata() {
  const client = useClient();
  const room = useRoom();
  return React5.useCallback(
    (options) => {
      if (!options.metadata) {
        return;
      }
      const threadId = options.threadId;
      const metadata = options.metadata;
      const updatedAt = /* @__PURE__ */ new Date();
      const { store, onMutationFailure } = getExtrasForClient2(client);
      const optimisticUpdateId = store.addOptimisticUpdate({
        type: "edit-thread-metadata",
        metadata,
        threadId,
        updatedAt
      });
      room.editThreadMetadata({ threadId, metadata }).then(
        (metadata2) => (
          // Replace the optimistic update by the real thing
          store.patchThread(
            threadId,
            optimisticUpdateId,
            { metadata: metadata2 },
            updatedAt
          )
        ),
        (err) => onMutationFailure(
          err,
          optimisticUpdateId,
          (error) => new EditThreadMetadataError(error, {
            roomId: room.id,
            threadId,
            metadata
          })
        )
      );
    },
    [client, room]
  );
}
function useCreateComment() {
  const client = useClient();
  const room = useRoom();
  return React5.useCallback(
    ({ threadId, body }) => {
      const commentId = createCommentId();
      const createdAt = /* @__PURE__ */ new Date();
      const comment = {
        id: commentId,
        threadId,
        roomId: room.id,
        type: "comment",
        createdAt,
        userId: getCurrentUserId(room),
        body,
        reactions: []
      };
      const { store, onMutationFailure } = getExtrasForClient2(client);
      const optimisticUpdateId = store.addOptimisticUpdate({
        type: "create-comment",
        comment
      });
      room.createComment({ threadId, commentId, body }).then(
        (newComment) => {
          store.createComment(newComment, optimisticUpdateId);
        },
        (err) => onMutationFailure(
          err,
          optimisticUpdateId,
          (err2) => new CreateCommentError(err2, {
            roomId: room.id,
            threadId,
            commentId,
            body
          })
        )
      );
      return comment;
    },
    [client, room]
  );
}
function useEditComment() {
  const client = useClient();
  const room = useRoom();
  return React5.useCallback(
    ({ threadId, commentId, body }) => {
      const editedAt = /* @__PURE__ */ new Date();
      const { store, onMutationFailure } = getExtrasForClient2(client);
      const thread = store.getThreads().threadsById[threadId];
      if (thread === void 0) {
        console3.warn(
          `Internal unexpected behavior. Cannot edit comment in thread "${threadId}" because the thread does not exist in the cache.`
        );
        return;
      }
      const comment = thread.comments.find(
        (comment2) => comment2.id === commentId
      );
      if (comment === void 0 || comment.deletedAt !== void 0) {
        console3.warn(
          `Internal unexpected behavior. Cannot edit comment "${commentId}" in thread "${threadId}" because the comment does not exist in the cache.`
        );
        return;
      }
      const optimisticUpdateId = store.addOptimisticUpdate({
        type: "edit-comment",
        comment: {
          ...comment,
          editedAt,
          body
        }
      });
      room.editComment({ threadId, commentId, body }).then(
        (editedComment) => {
          store.editComment(threadId, optimisticUpdateId, editedComment);
        },
        (err) => onMutationFailure(
          err,
          optimisticUpdateId,
          (error) => new EditCommentError(error, {
            roomId: room.id,
            threadId,
            commentId,
            body
          })
        )
      );
    },
    [client, room]
  );
}
function useDeleteComment() {
  const client = useClient();
  const room = useRoom();
  return React5.useCallback(
    ({ threadId, commentId }) => {
      const deletedAt = /* @__PURE__ */ new Date();
      const { store, onMutationFailure } = getExtrasForClient2(client);
      const optimisticUpdateId = store.addOptimisticUpdate({
        type: "delete-comment",
        threadId,
        commentId,
        deletedAt,
        roomId: room.id
      });
      room.deleteComment({ threadId, commentId }).then(
        () => {
          store.deleteComment(
            threadId,
            optimisticUpdateId,
            commentId,
            deletedAt
          );
        },
        (err) => onMutationFailure(
          err,
          optimisticUpdateId,
          (error) => new DeleteCommentError(error, {
            roomId: room.id,
            threadId,
            commentId
          })
        )
      );
    },
    [client, room]
  );
}
function useAddReaction() {
  const client = useClient();
  const room = useRoom();
  return React5.useCallback(
    ({ threadId, commentId, emoji }) => {
      const createdAt = /* @__PURE__ */ new Date();
      const userId = getCurrentUserId(room);
      const { store, onMutationFailure } = getExtrasForClient2(client);
      const optimisticUpdateId = store.addOptimisticUpdate({
        type: "add-reaction",
        threadId,
        commentId,
        reaction: {
          emoji,
          userId,
          createdAt
        }
      });
      room.addReaction({ threadId, commentId, emoji }).then(
        (addedReaction) => {
          store.addReaction(
            threadId,
            optimisticUpdateId,
            commentId,
            addedReaction,
            createdAt
          );
        },
        (err) => onMutationFailure(
          err,
          optimisticUpdateId,
          (error) => new AddReactionError(error, {
            roomId: room.id,
            threadId,
            commentId,
            emoji
          })
        )
      );
    },
    [client, room]
  );
}
function useRemoveReaction() {
  const client = useClient();
  const room = useRoom();
  return React5.useCallback(
    ({ threadId, commentId, emoji }) => {
      const userId = getCurrentUserId(room);
      const removedAt = /* @__PURE__ */ new Date();
      const { store, onMutationFailure } = getExtrasForClient2(client);
      const optimisticUpdateId = store.addOptimisticUpdate({
        type: "remove-reaction",
        threadId,
        commentId,
        emoji,
        userId,
        removedAt
      });
      room.removeReaction({ threadId, commentId, emoji }).then(
        () => {
          store.removeReaction(
            threadId,
            optimisticUpdateId,
            commentId,
            emoji,
            userId,
            removedAt
          );
        },
        (err) => onMutationFailure(
          err,
          optimisticUpdateId,
          (error) => new RemoveReactionError(error, {
            roomId: room.id,
            threadId,
            commentId,
            emoji
          })
        )
      );
    },
    [client, room]
  );
}
function useMarkThreadAsRead() {
  const client = useClient();
  const room = useRoom();
  return React5.useCallback(
    (threadId) => {
      const { store, onMutationFailure } = getExtrasForClient2(client);
      const inboxNotification = Object.values(
        store.getInboxNotifications().inboxNotificationsById
      ).find(
        (inboxNotification2) => inboxNotification2.kind === "thread" && inboxNotification2.threadId === threadId
      );
      if (!inboxNotification) return;
      const now = /* @__PURE__ */ new Date();
      const optimisticUpdateId = store.addOptimisticUpdate({
        type: "mark-inbox-notification-as-read",
        inboxNotificationId: inboxNotification.id,
        readAt: now
      });
      room.markInboxNotificationAsRead(inboxNotification.id).then(
        () => {
          store.updateInboxNotification(
            inboxNotification.id,
            optimisticUpdateId,
            (inboxNotification2) => ({ ...inboxNotification2, readAt: now })
          );
        },
        (err) => {
          onMutationFailure(
            err,
            optimisticUpdateId,
            (error) => new MarkInboxNotificationAsReadError(error, {
              inboxNotificationId: inboxNotification.id
            })
          );
          return;
        }
      );
    },
    [client, room]
  );
}
function useMarkThreadAsResolved() {
  const client = useClient();
  const room = useRoom();
  return React5.useCallback(
    (threadId) => {
      const updatedAt = /* @__PURE__ */ new Date();
      const { store, onMutationFailure } = getExtrasForClient2(client);
      const optimisticUpdateId = store.addOptimisticUpdate({
        type: "mark-thread-as-resolved",
        threadId,
        updatedAt
      });
      room.markThreadAsResolved(threadId).then(
        () => {
          store.patchThread(
            threadId,
            optimisticUpdateId,
            { resolved: true },
            updatedAt
          );
        },
        (err) => onMutationFailure(
          err,
          optimisticUpdateId,
          (error) => new MarkThreadAsResolvedError(error, {
            roomId: room.id,
            threadId
          })
        )
      );
    },
    [client, room]
  );
}
function useMarkThreadAsUnresolved() {
  const client = useClient();
  const room = useRoom();
  return React5.useCallback(
    (threadId) => {
      const updatedAt = /* @__PURE__ */ new Date();
      const { store, onMutationFailure } = getExtrasForClient2(client);
      const optimisticUpdateId = store.addOptimisticUpdate({
        type: "mark-thread-as-unresolved",
        threadId,
        updatedAt
      });
      room.markThreadAsUnresolved(threadId).then(
        () => {
          store.patchThread(
            threadId,
            optimisticUpdateId,
            { resolved: false },
            updatedAt
          );
        },
        (err) => onMutationFailure(
          err,
          optimisticUpdateId,
          (error) => new MarkThreadAsUnresolvedError(error, {
            roomId: room.id,
            threadId
          })
        )
      );
    },
    [client, room]
  );
}
function useThreadSubscription(threadId) {
  const client = useClient();
  const { store } = getExtrasForClient2(client);
  const selector = React5.useCallback(
    (state) => {
      const inboxNotification = state.inboxNotifications.find(
        (inboxNotification2) => inboxNotification2.kind === "thread" && inboxNotification2.threadId === threadId
      );
      const thread = state.threadsById[threadId];
      if (inboxNotification === void 0 || thread === void 0) {
        return {
          status: "not-subscribed"
        };
      }
      return {
        status: "subscribed",
        unreadSince: inboxNotification.readAt
      };
    },
    [threadId]
  );
  return useSyncExternalStoreWithSelector2(
    store.subscribeThreads,
    store.getThreads,
    store.getThreads,
    selector
  );
}
function useRoomNotificationSettings() {
  const client = useClient();
  const room = useRoom();
  const { store } = getExtrasForClient2(client);
  React5.useEffect(() => {
    const { getInboxNotificationSettings } = getExtrasForClient2(client);
    const queryKey = makeNotificationSettingsQueryKey(room.id);
    void getInboxNotificationSettings(room, queryKey);
  }, [client, room]);
  const updateRoomNotificationSettings = useUpdateRoomNotificationSettings();
  const selector = React5.useCallback(
    (state) => {
      const query = state.queries[makeNotificationSettingsQueryKey(room.id)];
      if (query === void 0 || query.isLoading) {
        return { isLoading: true };
      }
      if (query.error !== void 0) {
        return { isLoading: false, error: query.error };
      }
      return {
        isLoading: false,
        settings: selectNotificationSettings(room.id, state)
      };
    },
    [room]
  );
  const settings = useSyncExternalStoreWithSelector2(
    store.subscribeNotificationSettings,
    store.getThreads,
    store.getThreads,
    selector
  );
  return React5.useMemo(() => {
    return [settings, updateRoomNotificationSettings];
  }, [settings, updateRoomNotificationSettings]);
}
function useHistoryVersionData(versionId) {
  const [state, setState] = React5.useState({
    isLoading: true
  });
  const room = useRoom();
  React5.useEffect(() => {
    setState({ isLoading: true });
    const load = async () => {
      try {
        const response = await room[kInternal2].getTextVersion(versionId);
        const buffer = await response.arrayBuffer();
        const data = new Uint8Array(buffer);
        setState({
          isLoading: false,
          data
        });
      } catch (error) {
        setState({
          isLoading: false,
          error: error instanceof Error ? error : new Error(
            "An unknown error occurred while loading this version"
          )
        });
      }
    };
    void load();
  }, [room, versionId]);
  return state;
}
function useHistoryVersions() {
  const client = useClient();
  const room = useRoom();
  const queryKey = getVersionsQueryKey(room.id);
  const { store, getRoomVersions } = getExtrasForClient2(client);
  React5.useEffect(() => {
    void getRoomVersions(room);
  }, [room]);
  const selector = React5.useCallback(
    (state2) => {
      const query = state2.queries[queryKey];
      if (query === void 0 || query.isLoading) {
        return {
          isLoading: true
        };
      }
      return {
        versions: state2.versionsByRoomId[room.id],
        isLoading: false,
        error: query.error
      };
    },
    [room, queryKey]
    // eslint-disable-line react-hooks/exhaustive-deps
  );
  const state = useSyncExternalStoreWithSelector2(
    store.subscribeVersions,
    store.getVersions,
    store.getVersions,
    selector
  );
  return state;
}
function useUpdateRoomNotificationSettings() {
  const client = useClient();
  const room = useRoom();
  return React5.useCallback(
    (settings) => {
      const { store, onMutationFailure } = getExtrasForClient2(client);
      const optimisticUpdateId = store.addOptimisticUpdate({
        type: "update-notification-settings",
        roomId: room.id,
        settings
      });
      room.updateNotificationSettings(settings).then(
        (settings2) => {
          store.updateRoomInboxNotificationSettings2(
            room.id,
            optimisticUpdateId,
            settings2
          );
        },
        (err) => onMutationFailure(
          err,
          optimisticUpdateId,
          (error) => new UpdateNotificationSettingsError(error, {
            roomId: room.id
          })
        )
      );
    },
    [client, room]
  );
}
function ensureNotServerSide() {
  if (typeof window === "undefined") {
    throw new Error(
      "You cannot use the Suspense version of this hook on the server side. Make sure to only call them on the client side.\nFor tips, see https://liveblocks.io/docs/api-reference/liveblocks-react#suspense-avoid-ssr"
    );
  }
}
function useSuspendUntilPresenceReady() {
  ensureNotServerSide();
  const room = useRoom();
  use(room.waitUntilPresenceReady());
}
function useSelfSuspense(selector, isEqual) {
  useSuspendUntilPresenceReady();
  return useSelf(
    selector,
    isEqual
  );
}
function useOthersSuspense(selector, isEqual) {
  useSuspendUntilPresenceReady();
  return useOthers(
    selector,
    isEqual
  );
}
function useOthersConnectionIdsSuspense() {
  useSuspendUntilPresenceReady();
  return useOthersConnectionIds();
}
function useOthersMappedSuspense(itemSelector, itemIsEqual) {
  useSuspendUntilPresenceReady();
  return useOthersMapped(itemSelector, itemIsEqual);
}
function useOtherSuspense(connectionId, selector, isEqual) {
  useSuspendUntilPresenceReady();
  return useOther(connectionId, selector, isEqual);
}
function useSuspendUntilStorageReady() {
  ensureNotServerSide();
  const room = useRoom();
  use(room.waitUntilStorageReady());
}
function useStorageSuspense(selector, isEqual) {
  useSuspendUntilStorageReady();
  return useStorage(
    selector,
    isEqual
  );
}
function useStorageStatusSuspense(options) {
  useSuspendUntilStorageReady();
  return useStorageStatus(options);
}
function useThreadsSuspense(options = {
  query: { metadata: {} }
}) {
  const { scrollOnLoad = true } = options;
  const client = useClient();
  const room = useRoom();
  const queryKey = React5.useMemo(
    () => generateQueryKey(room.id, options.query),
    [room, options]
  );
  const { store, getThreadsAndInboxNotifications } = getExtrasForClient2(client);
  const query = store.getThreads().queries[queryKey];
  if (query === void 0 || query.isLoading) {
    throw getThreadsAndInboxNotifications(room, queryKey, options);
  }
  if (query.error) {
    throw query.error;
  }
  const selector = React5.useCallback(
    (state2) => {
      return {
        threads: selectThreads(state2, {
          roomId: room.id,
          query: options.query,
          orderBy: "age"
        }),
        isLoading: false
      };
    },
    [room, queryKey]
    // eslint-disable-line react-hooks/exhaustive-deps
  );
  React5.useEffect(() => {
    const { incrementQuerySubscribers } = getExtrasForClient2(client);
    return incrementQuerySubscribers(queryKey);
  }, [client, queryKey]);
  const state = useSyncExternalStoreWithSelector2(
    store.subscribeThreads,
    store.getThreads,
    store.getThreads,
    selector
  );
  useScrollToCommentOnLoadEffect(scrollOnLoad, state);
  return state;
}
function useHistoryVersionsSuspense() {
  const client = useClient();
  const room = useRoom();
  const queryKey = getVersionsQueryKey(room.id);
  const { store, getRoomVersions } = getExtrasForClient2(client);
  const query = store.getVersions().queries[queryKey];
  if (query === void 0 || query.isLoading) {
    throw getRoomVersions(room);
  }
  if (query.error) {
    throw query.error;
  }
  const selector = React5.useCallback(
    (state2) => {
      return {
        versions: state2.versionsByRoomId[room.id],
        isLoading: false
      };
    },
    [room, queryKey]
    // eslint-disable-line react-hooks/exhaustive-deps
  );
  const state = useSyncExternalStoreWithSelector2(
    store.subscribeVersions,
    store.getVersions,
    store.getVersions,
    selector
  );
  return state;
}
function useRoomNotificationSettingsSuspense() {
  const updateRoomNotificationSettings = useUpdateRoomNotificationSettings();
  const client = useClient();
  const room = useRoom();
  const queryKey = makeNotificationSettingsQueryKey(room.id);
  const { store, getInboxNotificationSettings } = getExtrasForClient2(client);
  const query = store.getNotificationSettings().queries[queryKey];
  if (query === void 0 || query.isLoading) {
    throw getInboxNotificationSettings(room, queryKey);
  }
  if (query.error) {
    throw query.error;
  }
  const selector = React5.useCallback(
    (state) => {
      return {
        isLoading: false,
        settings: selectNotificationSettings(room.id, state)
      };
    },
    [room]
  );
  const settings = useSyncExternalStoreWithSelector2(
    store.subscribeNotificationSettings,
    store.getNotificationSettings,
    store.getNotificationSettings,
    selector
  );
  return React5.useMemo(() => {
    return [settings, updateRoomNotificationSettings];
  }, [settings, updateRoomNotificationSettings]);
}
function createRoomContext(client) {
  return getOrCreateRoomContextBundle(client);
}
function generateQueryKey(roomId, options) {
  return `${roomId}-${stringify2(options ?? {})}`;
}
function getVersionsQueryKey(roomId) {
  return `${roomId}-VERSIONS`;
}
var _RoomProvider = RoomProvider;
var _useBroadcastEvent = useBroadcastEvent;
var _useOthersListener = useOthersListener;
var _useRoom = useRoom;
var _useIsInsideRoom = useIsInsideRoom;
var _useAddReaction = useAddReaction;
var _useMutation = useMutation;
var _useCreateThread = useCreateThread;
var _useDeleteThread = useDeleteThread;
var _useEditThreadMetadata = useEditThreadMetadata;
var _useEventListener = useEventListener;
var _useMyPresence = useMyPresence;
var _useOthersMapped = useOthersMapped;
var _useOthersMappedSuspense = useOthersMappedSuspense;
var _useThreads = useThreads;
var _useThreadsSuspense = useThreadsSuspense;
var _useHistoryVersions = useHistoryVersions;
var _useHistoryVersionsSuspense = useHistoryVersionsSuspense;
var _useOther = useOther;
function _useOthers(...args) {
  return useOthers(...args);
}
var _useOtherSuspense = useOtherSuspense;
function _useOthersSuspense(...args) {
  return useOthersSuspense(...args);
}
var _useStorage = useStorage;
var _useStorageSuspense = useStorageSuspense;
function _useSelf(...args) {
  return useSelf(...args);
}
function _useSelfSuspense(...args) {
  return useSelfSuspense(...args);
}
var _useStorageRoot = useStorageRoot;
var _useUpdateMyPresence = useUpdateMyPresence;

export {
  PKG_NAME,
  PKG_VERSION,
  PKG_FORMAT,
  ClientSideSuspense,
  RoomContext,
  ClientContext,
  selectThreads,
  getUmbrellaStoreForClient,
  useClient,
  LiveblocksProvider,
  createLiveblocksContext,
  useInboxNotifications,
  useInboxNotificationsSuspense,
  useMarkAllInboxNotificationsAsRead,
  useMarkInboxNotificationAsRead,
  useDeleteAllInboxNotifications,
  useDeleteInboxNotification,
  useUnreadInboxNotificationsCount,
  useUnreadInboxNotificationsCountSuspense,
  useRoomInfo,
  useRoomInfoSuspense,
  _useInboxNotificationThread,
  _useUser,
  _useUserSuspense,
  _useUserThreads_experimental,
  _useUserThreadsSuspense_experimental,
  CreateThreadError,
  useStatus,
  useStorageStatus,
  useBatch,
  useLostConnectionListener,
  useErrorListener,
  useHistory,
  useUndo,
  useRedo,
  useCanUndo,
  useCanRedo,
  useOthersConnectionIds,
  useCommentsErrorListener,
  useCreateComment,
  useEditComment,
  useDeleteComment,
  useRemoveReaction,
  useMarkThreadAsRead,
  useMarkThreadAsResolved,
  useMarkThreadAsUnresolved,
  useThreadSubscription,
  useRoomNotificationSettings,
  useHistoryVersionData,
  useUpdateRoomNotificationSettings,
  useOthersConnectionIdsSuspense,
  useStorageStatusSuspense,
  createRoomContext,
  _RoomProvider,
  _useBroadcastEvent,
  _useOthersListener,
  _useRoom,
  _useIsInsideRoom,
  _useAddReaction,
  _useMutation,
  _useCreateThread,
  _useDeleteThread,
  _useEditThreadMetadata,
  _useEventListener,
  _useMyPresence,
  _useOthersMapped,
  _useOthersMappedSuspense,
  _useThreads,
  _useThreadsSuspense,
  _useHistoryVersions,
  _useHistoryVersionsSuspense,
  _useOther,
  _useOthers,
  _useOtherSuspense,
  _useOthersSuspense,
  _useStorage,
  _useStorageSuspense,
  _useSelf,
  _useSelfSuspense,
  _useStorageRoot,
  _useUpdateMyPresence
};
//# sourceMappingURL=chunk-XK5NTOJJ.mjs.map