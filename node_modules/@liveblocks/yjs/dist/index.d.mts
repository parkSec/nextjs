import { JsonObject, LsonObject, BaseUserMeta, Json, BaseMetadata, Room, User } from '@liveblocks/client';
import { DP, DS, DU, DE, BaseMetadata as BaseMetadata$1, DM } from '@liveblocks/core';
import { Observable } from 'lib0/observable';
import * as Y from 'yjs';

declare type MetaClientState = {
    clock: number;
    lastUpdated: number;
};
/**
 * This class will store Yjs awareness in Liveblock's presence under the __yjs key
 * IMPORTANT: The Yjs awareness protocol uses ydoc.clientId to reference users
 * to their respective documents. To avoid mapping Yjs clientIds to liveblock's connectionId,
 * we simply set the clientId of the doc to the connectionId. Then no further mapping is required
 */
declare class Awareness<P extends JsonObject, S extends LsonObject, U extends BaseUserMeta, E extends Json, M extends BaseMetadata> extends Observable<unknown> {
    private room;
    doc: Y.Doc;
    states: Map<number, unknown>;
    actorToClientMap: Map<number, number>;
    meta: Map<number, MetaClientState>;
    _checkInterval: number;
    private othersUnsub;
    constructor(doc: Y.Doc, room: Room<P, S, U, E, M>);
    rebuildActorToClientMap(others: readonly User<JsonObject, BaseUserMeta>[]): void;
    destroy(): void;
    getLocalState(): JsonObject | null;
    setLocalState(state: Partial<JsonObject> | null): void;
    setLocalStateField(field: string, value: JsonObject | null): void;
    getStates(): Map<number, unknown>;
}

declare class yDocHandler extends Observable<unknown> {
    private unsubscribers;
    private _synced;
    private doc;
    private updateRoomDoc;
    private fetchRoomDoc;
    constructor({ doc, isRoot, updateDoc, fetchDoc, }: {
        doc: Y.Doc;
        isRoot: boolean;
        updateDoc: (update: Uint8Array, guid?: string) => void;
        fetchDoc: (vector: string, guid?: string) => void;
    });
    handleServerUpdate: ({ update, stateVector, readOnly, }: {
        update: Uint8Array;
        stateVector: string | null;
        readOnly: boolean;
    }) => void;
    syncDoc: () => void;
    get synced(): boolean;
    set synced(state: boolean);
    private updateHandler;
    destroy(): void;
}

declare type ProviderOptions = {
    autoloadSubdocs?: boolean;
};
declare enum SyncStatus {
    Loading = "loading",
    Synchronizing = "synchronizing",
    Synchronized = "synchronized"
}
declare class LiveblocksYjsProvider<P extends JsonObject = DP, S extends LsonObject = DS, U extends BaseUserMeta = DU, E extends Json = DE, M extends BaseMetadata$1 = DM> extends Observable<unknown> {
    private room;
    private rootDoc;
    private options;
    private unsubscribers;
    awareness: Awareness<P, S, U, E, M>;
    rootDocHandler: yDocHandler;
    subdocHandlers: Map<string, yDocHandler>;
    private pending;
    constructor(room: Room<P, S, U, E, M>, doc: Y.Doc, options?: ProviderOptions | undefined);
    private handleSubdocs;
    private getUniqueUpdateId;
    private updateDoc;
    private fetchDoc;
    private createSubdocHandler;
    loadSubdoc: (guid: string) => boolean;
    private syncDoc;
    get synced(): boolean;
    getStatus(): SyncStatus;
    destroy(): void;
    disconnect(): void;
    connect(): void;
}

export { LiveblocksYjsProvider };
